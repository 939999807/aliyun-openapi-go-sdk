// Copyright 2015 Chen Xianren. All rights reserved.
// Code generated by openapi-meta; DO NOT EDIT

package ots // import "github.com/cxr29/aliyun-openapi-go-sdk/apis/ots/v20130912"

import (
	"errors"
	"fmt"

	"github.com/cxr29/aliyun-openapi-go-sdk"
)

var (
	_ = errors.New("")
	_ = fmt.Sprint("")
)

type API struct {
	openapi.Service
}

func New(accessKeyId, accessKeySecret string) API {
	return API{openapi.NewService(accessKeyId, accessKeySecret)}
}

func NewParams() openapi.Params {
	args := openapi.NewParams()
	args.Product = Product
	args.Style = Style
	args.Version = Version
	return args
}

const (
	Product = "Ots"
	Style   = "RPC"
	Version = "2013-09-12"
)

// DeleteInstance version 2013-09-12
//
// required parameters:
//  name: InstanceName, type: string
//
// optional parameters:
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DeleteInstance(InstanceName string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteInstance")
	args.Method = "POST"
	args.Query.Set("InstanceName", InstanceName)
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteUser version 2013-09-12
//
// optional parameters:
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DeleteUser(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteUser")
	args.Method = "POST"
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetInstance version 2013-09-12
//
// required parameters:
//  name: InstanceName, type: string
//
// optional parameters:
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) GetInstance(InstanceName string, optional openapi.M) (*GetInstanceResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetInstance")
	args.Method = "GET"
	args.Query.Set("InstanceName", InstanceName)
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(GetInstanceResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetInstanceResponse represents the response of the api GetInstance.
type GetInstanceResponse struct {
	InstanceInfo struct {
		ClusterName  string
		CreateTime   string
		Description  string
		InstanceName string
		Quota        struct {
			EntityQuota int
		}
		ReadCapacity  int
		Status        int
		UserId        string
		WriteCapacity int
	}
}

// GetUser version 2013-09-12
//
// optional parameters:
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) GetUser(optional openapi.M) (*GetUserResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetUser")
	args.Method = "GET"
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(GetUserResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetUserResponse represents the response of the api GetUser.
type GetUserResponse struct {
	UserInfo struct {
		CreateTime  string
		Description string
		Quota       struct {
			InstanceQuota int
		}
		UserId string
	}
}

// InsertInstance version 2013-09-12
//
// required parameters:
//  name: InstanceName, type: string
//
// optional parameters:
//  name: ClusterName, type: string
//  name: Description, type: string
//  name: EntityQuota, type: int
//  name: ReadCapacity, type: int
//  name: WriteCapacity, type: int
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) InsertInstance(InstanceName string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "InsertInstance")
	args.Method = "POST"
	args.Query.Set("InstanceName", InstanceName)
	if v, ok := optional["ClusterName"]; ok {
		if ClusterName, ok := v.(string); ok {
			args.Query.Set("ClusterName", ClusterName)
		} else {
			return nil, errors.New("ClusterName must be string")
		}
	}
	if v, ok := optional["Description"]; ok {
		if Description, ok := v.(string); ok {
			args.Query.Set("Description", Description)
		} else {
			return nil, errors.New("Description must be string")
		}
	}
	if v, ok := optional["EntityQuota"]; ok {
		if EntityQuota, ok := v.(int); ok {
			args.Query.Set("EntityQuota", fmt.Sprint(EntityQuota))
		} else {
			return nil, errors.New("EntityQuota must be int")
		}
	}
	if v, ok := optional["ReadCapacity"]; ok {
		if ReadCapacity, ok := v.(int); ok {
			args.Query.Set("ReadCapacity", fmt.Sprint(ReadCapacity))
		} else {
			return nil, errors.New("ReadCapacity must be int")
		}
	}
	if v, ok := optional["WriteCapacity"]; ok {
		if WriteCapacity, ok := v.(int); ok {
			args.Query.Set("WriteCapacity", fmt.Sprint(WriteCapacity))
		} else {
			return nil, errors.New("WriteCapacity must be int")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// InsertUser version 2013-09-12
//
// optional parameters:
//  name: Description, type: string
//  name: InstanceQuota, type: int
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) InsertUser(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "InsertUser")
	args.Method = "POST"
	if v, ok := optional["Description"]; ok {
		if Description, ok := v.(string); ok {
			args.Query.Set("Description", Description)
		} else {
			return nil, errors.New("Description must be string")
		}
	}
	if v, ok := optional["InstanceQuota"]; ok {
		if InstanceQuota, ok := v.(int); ok {
			args.Query.Set("InstanceQuota", fmt.Sprint(InstanceQuota))
		} else {
			return nil, errors.New("InstanceQuota must be int")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListInstance version 2013-09-12
//
// optional parameters:
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ListInstance(optional openapi.M) (*ListInstanceResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListInstance")
	args.Method = "GET"
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(ListInstanceResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListInstanceResponse represents the response of the api ListInstance.
type ListInstanceResponse struct {
	InstanceInfos struct {
		InstanceInfo []struct {
			InstanceId   string
			InstanceName string
			Timestamp    string
			Version      string
		}
	}
}

// UpdateInstance version 2013-09-12
//
// required parameters:
//  name: InstanceName, type: string
//
// optional parameters:
//  name: Description, type: string
//  name: EntityQuota, type: int
//  name: ReadCapacity, type: int
//  name: WriteCapacity, type: int
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) UpdateInstance(InstanceName string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "UpdateInstance")
	args.Method = "POST"
	args.Query.Set("InstanceName", InstanceName)
	if v, ok := optional["Description"]; ok {
		if Description, ok := v.(string); ok {
			args.Query.Set("Description", Description)
		} else {
			return nil, errors.New("Description must be string")
		}
	}
	if v, ok := optional["EntityQuota"]; ok {
		if EntityQuota, ok := v.(int); ok {
			args.Query.Set("EntityQuota", fmt.Sprint(EntityQuota))
		} else {
			return nil, errors.New("EntityQuota must be int")
		}
	}
	if v, ok := optional["ReadCapacity"]; ok {
		if ReadCapacity, ok := v.(int); ok {
			args.Query.Set("ReadCapacity", fmt.Sprint(ReadCapacity))
		} else {
			return nil, errors.New("ReadCapacity must be int")
		}
	}
	if v, ok := optional["WriteCapacity"]; ok {
		if WriteCapacity, ok := v.(int); ok {
			args.Query.Set("WriteCapacity", fmt.Sprint(WriteCapacity))
		} else {
			return nil, errors.New("WriteCapacity must be int")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// UpdateUser version 2013-09-12
//
// optional parameters:
//  name: Description, type: string
//  name: InstanceQuota, type: int
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) UpdateUser(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "UpdateUser")
	args.Method = "POST"
	if v, ok := optional["Description"]; ok {
		if Description, ok := v.(string); ok {
			args.Query.Set("Description", Description)
		} else {
			return nil, errors.New("Description must be string")
		}
	}
	if v, ok := optional["InstanceQuota"]; ok {
		if InstanceQuota, ok := v.(int); ok {
			args.Query.Set("InstanceQuota", fmt.Sprint(InstanceQuota))
		} else {
			return nil, errors.New("InstanceQuota must be int")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}
