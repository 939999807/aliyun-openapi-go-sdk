// Copyright 2015 Chen Xianren. All rights reserved.
// Code generated by openapi-meta; DO NOT EDIT

package yundun

import (
	"errors"
	"fmt"

	"git.oschina.net/cxr29/aliyun-openapi-go-sdk"
)

var (
	_ = errors.New("")
	_ = fmt.Sprint("")
)

type API struct {
	openapi.Service
}

func New(accessKeyId, accessKeySecret string) API {
	return API{openapi.NewService(accessKeyId, accessKeySecret)}
}

func NewParams() openapi.Params {
	args := openapi.NewParams()
	args.Product = Product
	args.Style = Style
	args.Version = Version
	return args
}

const (
	Product = "Yundun"
	Style   = "RPC"
	Version = "2015-04-16"
)

// AddCNameWaf version 2015-04-16
//
// required parameters:
//  name: Domain, type: string
//  name: InstanceId, type: string
//
// optional parameters:
//  name: InstanceType, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) AddCNameWaf(Domain, InstanceId string, optional openapi.M) (*AddCNameWafResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "AddCNameWaf")
	args.Query.Set("Domain", Domain)
	args.Query.Set("InstanceId", InstanceId)
	if v, ok := optional["InstanceType"]; ok {
		if InstanceType, ok := v.(string); ok {
			args.Query.Set("InstanceType", InstanceType)
		} else {
			return nil, errors.New("InstanceType must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(AddCNameWafResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// AddCNameWafResponse represents the response of the api AddCNameWaf.
type AddCNameWafResponse struct {
	WafInfoList struct {
		WafInfo []struct {
			Cname  string
			Domain string
			Id     int
			Status int
		}
	}
}

// BruteforceLog version 2015-04-16
//
// required parameters:
//  name: InstanceId, type: string
//
// optional parameters:
//  name: JstOwnerId, type: int64
//  name: PageNumber, type: int
//  name: PageSize, type: int
//  name: RecordType, type: int
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) BruteforceLog(InstanceId string, optional openapi.M) (*BruteforceLogResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "BruteforceLog")
	args.Query.Set("InstanceId", InstanceId)
	if v, ok := optional["JstOwnerId"]; ok {
		if JstOwnerId, ok := v.(int64); ok {
			args.Query.Set("JstOwnerId", fmt.Sprint(JstOwnerId))
		} else {
			return nil, errors.New("JstOwnerId must be int64")
		}
	}
	if v, ok := optional["PageNumber"]; ok {
		if PageNumber, ok := v.(int); ok {
			args.Query.Set("PageNumber", fmt.Sprint(PageNumber))
		} else {
			return nil, errors.New("PageNumber must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["RecordType"]; ok {
		if RecordType, ok := v.(int); ok {
			args.Query.Set("RecordType", fmt.Sprint(RecordType))
		} else {
			return nil, errors.New("RecordType must be int")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(BruteforceLogResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// BruteforceLogResponse represents the response of the api BruteforceLog.
type BruteforceLogResponse struct {
	EndTime string
	LogList struct {
		BruteforceLog []struct {
			BlockTimes int
			Location   string
			SourceIp   string
			Status     int
			Time       string
		}
	}
	PageNumber int
	PageSize   int
	StartTime  string
	TotalCount int
}

// CloseCCProtect version 2015-04-16
//
// required parameters:
//  name: InstanceId, type: string
//
// optional parameters:
//  name: InstanceType, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) CloseCCProtect(InstanceId string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "CloseCCProtect")
	args.Query.Set("InstanceId", InstanceId)
	if v, ok := optional["InstanceType"]; ok {
		if InstanceType, ok := v.(string); ok {
			args.Query.Set("InstanceType", InstanceType)
		} else {
			return nil, errors.New("InstanceType must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ClosePortScan version 2015-04-16
//
// required parameters:
//  name: InstanceId, type: string
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ClosePortScan(InstanceId string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "ClosePortScan")
	args.Query.Set("InstanceId", InstanceId)
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CloseVulScan version 2015-04-16
//
// required parameters:
//  name: InstanceId, type: string
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) CloseVulScan(InstanceId string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "CloseVulScan")
	args.Query.Set("InstanceId", InstanceId)
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ConfigDdos version 2015-04-16
//
// required parameters:
//  name: FlowPosition, type: int
//  name: InstanceId, type: string
//  name: Level, type: int
//  name: StrategyPosition, type: int
//
// optional parameters:
//  name: InstanceType, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ConfigDdos(FlowPosition int, InstanceId string, Level, StrategyPosition int, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "ConfigDdos")
	args.Query.Set("FlowPosition", fmt.Sprint(FlowPosition))
	args.Query.Set("InstanceId", InstanceId)
	args.Query.Set("Level", fmt.Sprint(Level))
	args.Query.Set("StrategyPosition", fmt.Sprint(StrategyPosition))
	if v, ok := optional["InstanceType"]; ok {
		if InstanceType, ok := v.(string); ok {
			args.Query.Set("InstanceType", InstanceType)
		} else {
			return nil, errors.New("InstanceType must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ConfirmLogin version 2015-04-16
//
// required parameters:
//  name: InstanceId, type: string
//  name: SourceIp, type: string
//  name: Time, type: string
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ConfirmLogin(InstanceId, SourceIp, Time string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "ConfirmLogin")
	args.Query.Set("InstanceId", InstanceId)
	args.Query.Set("SourceIp", SourceIp)
	args.Query.Set("Time", Time)
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DdosFlowGraph version 2015-04-16
//
// required parameters:
//  name: InstanceId, type: string
//
// optional parameters:
//  name: InstanceType, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DdosFlowGraph(InstanceId string, optional openapi.M) (*DdosFlowGraphResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DdosFlowGraph")
	args.Query.Set("InstanceId", InstanceId)
	if v, ok := optional["InstanceType"]; ok {
		if InstanceType, ok := v.(string); ok {
			args.Query.Set("InstanceType", InstanceType)
		} else {
			return nil, errors.New("InstanceType must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DdosFlowGraphResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DdosFlowGraphResponse represents the response of the api DdosFlowGraph.
type DdosFlowGraphResponse struct {
	NormalFlows struct {
		NormalFlow []struct {
			BitRecv int64
			BitSend int64
			PktRecv int64
			PktSend int64
			Time    int64 `json:"time" xml:"time"`
		}
	}
	TotalFlows struct {
		TotalFlow []struct {
			BitRecv int64
			PktRecv int64
			Time    int64 `json:"time" xml:"time"`
		}
	}
}

// DdosLog version 2015-04-16
//
// required parameters:
//  name: InstanceId, type: string
//
// optional parameters:
//  name: InstanceType, type: string
//  name: JstOwnerId, type: int64
//  name: PageNumber, type: int
//  name: PageSize, type: int
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DdosLog(InstanceId string, optional openapi.M) (*DdosLogResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DdosLog")
	args.Query.Set("InstanceId", InstanceId)
	if v, ok := optional["InstanceType"]; ok {
		if InstanceType, ok := v.(string); ok {
			args.Query.Set("InstanceType", InstanceType)
		} else {
			return nil, errors.New("InstanceType must be string")
		}
	}
	if v, ok := optional["JstOwnerId"]; ok {
		if JstOwnerId, ok := v.(int64); ok {
			args.Query.Set("JstOwnerId", fmt.Sprint(JstOwnerId))
		} else {
			return nil, errors.New("JstOwnerId must be int64")
		}
	}
	if v, ok := optional["PageNumber"]; ok {
		if PageNumber, ok := v.(int); ok {
			args.Query.Set("PageNumber", fmt.Sprint(PageNumber))
		} else {
			return nil, errors.New("PageNumber must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DdosLogResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DdosLogResponse represents the response of the api DdosLog.
type DdosLogResponse struct {
	AttackStatus int
	EndTime      string
	LogList      struct {
		DdosLog []struct {
			AttackIpList string
			AttackType   string
			Bps          int64
			EndTime      string
			Pps          int64
			Qps          int64
			Reason       string
			StartTime    string
			Status       int
			Type         int
		}
	}
	PageNumber int
	PageSize   int
	StartTime  string
	TotalCount int
}

// DeleteBackDoorFile version 2015-04-16
//
// required parameters:
//  name: InstanceId, type: string
//  name: Path, type: string
//
// optional parameters:
//  name: JstOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DeleteBackDoorFile(InstanceId, Path string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteBackDoorFile")
	args.Query.Set("InstanceId", InstanceId)
	args.Query.Set("Path", Path)
	if v, ok := optional["JstOwnerId"]; ok {
		if JstOwnerId, ok := v.(int64); ok {
			args.Query.Set("JstOwnerId", fmt.Sprint(JstOwnerId))
		} else {
			return nil, errors.New("JstOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteCNameWaf version 2015-04-16
//
// required parameters:
//  name: CnameId, type: int
//  name: Domain, type: string
//  name: InstanceId, type: string
//
// optional parameters:
//  name: InstanceType, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DeleteCNameWaf(CnameId int, Domain, InstanceId string, optional openapi.M) (*DeleteCNameWafResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteCNameWaf")
	args.Query.Set("CnameId", fmt.Sprint(CnameId))
	args.Query.Set("Domain", Domain)
	args.Query.Set("InstanceId", InstanceId)
	if v, ok := optional["InstanceType"]; ok {
		if InstanceType, ok := v.(string); ok {
			args.Query.Set("InstanceType", InstanceType)
		} else {
			return nil, errors.New("InstanceType must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DeleteCNameWafResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteCNameWafResponse represents the response of the api DeleteCNameWaf.
type DeleteCNameWafResponse struct {
	WafInfoList struct {
		WafInfo []struct {
			Cname  string
			Domain string
			Id     int
			Status int
		}
	}
}

// DetectVulById version 2015-04-16
//
// required parameters:
//  name: InstanceId, type: string
//  name: VulId, type: int
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DetectVulById(InstanceId string, VulId int, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DetectVulById")
	args.Query.Set("InstanceId", InstanceId)
	args.Query.Set("VulId", fmt.Sprint(VulId))
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DetectVulByIp version 2015-04-16
//
// required parameters:
//  name: InstanceId, type: string
//  name: VulIp, type: string
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DetectVulByIp(InstanceId, VulIp string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DetectVulByIp")
	args.Query.Set("InstanceId", InstanceId)
	args.Query.Set("VulIp", VulIp)
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetDdosConfigOptions version 2015-04-16
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) GetDdosConfigOptions(optional openapi.M) (*GetDdosConfigOptionsResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetDdosConfigOptions")
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(GetDdosConfigOptionsResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetDdosConfigOptionsResponse represents the response of the api GetDdosConfigOptions.
type GetDdosConfigOptionsResponse struct {
	ConnectionThresholdOptions struct {
		ConnectionThresholdOption []struct {
			Sipconn int64
			Sipnew  int64
		}
	}
	RequestThresholdOptions1 struct {
		RequestThresholdOption []struct {
			Bps int64
			Pps int64
		}
	}
	RequestThresholdOptions2 struct {
		RequestThresholdOption []struct {
			Bps int64
			Pps int64
		}
	}
}

// ListInstanceInfos version 2015-04-16
//
// optional parameters:
//  name: EventType, type: string
//  name: InstanceIds, type: string
//  name: InstanceName, type: string
//  name: InstanceType, type: string
//  name: JstOwnerId, type: int64
//  name: PageNumber, type: int
//  name: PageSize, type: int
//  name: Region, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ListInstanceInfos(optional openapi.M) (*ListInstanceInfosResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListInstanceInfos")
	if v, ok := optional["EventType"]; ok {
		if EventType, ok := v.(string); ok {
			args.Query.Set("EventType", EventType)
		} else {
			return nil, errors.New("EventType must be string")
		}
	}
	if v, ok := optional["InstanceIds"]; ok {
		if InstanceIds, ok := v.(string); ok {
			args.Query.Set("InstanceIds", InstanceIds)
		} else {
			return nil, errors.New("InstanceIds must be string")
		}
	}
	if v, ok := optional["InstanceName"]; ok {
		if InstanceName, ok := v.(string); ok {
			args.Query.Set("InstanceName", InstanceName)
		} else {
			return nil, errors.New("InstanceName must be string")
		}
	}
	if v, ok := optional["InstanceType"]; ok {
		if InstanceType, ok := v.(string); ok {
			args.Query.Set("InstanceType", InstanceType)
		} else {
			return nil, errors.New("InstanceType must be string")
		}
	}
	if v, ok := optional["JstOwnerId"]; ok {
		if JstOwnerId, ok := v.(int64); ok {
			args.Query.Set("JstOwnerId", fmt.Sprint(JstOwnerId))
		} else {
			return nil, errors.New("JstOwnerId must be int64")
		}
	}
	if v, ok := optional["PageNumber"]; ok {
		if PageNumber, ok := v.(int); ok {
			args.Query.Set("PageNumber", fmt.Sprint(PageNumber))
		} else {
			return nil, errors.New("PageNumber must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["Region"]; ok {
		if Region, ok := v.(string); ok {
			args.Query.Set("Region", Region)
		} else {
			return nil, errors.New("Region must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(ListInstanceInfosResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListInstanceInfosResponse represents the response of the api ListInstanceInfos.
type ListInstanceInfosResponse struct {
	InfosList struct {
		InstanceInfo []struct {
			AegisStatus  int
			Ddos         int
			HostEvent    int
			InstanceId   string
			InstanceName string
			InternetIp   string
			IntranetIp   string
			Ip           string
			IsLock       bool
			LockType     string
			Region       string
			RegionEnName string
			RegionName   string
			SecureCheck  int
			TriggerTime  string
			UnLockTimes  int
			Waf          int
		}
	}
	PageNumber int
	PageSize   int
	TotalCount int
}

// LogineventLog version 2015-04-16
//
// required parameters:
//  name: InstanceId, type: string
//
// optional parameters:
//  name: JstOwnerId, type: int64
//  name: PageNumber, type: int
//  name: PageSize, type: int
//  name: RecordType, type: int
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) LogineventLog(InstanceId string, optional openapi.M) (*LogineventLogResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "LogineventLog")
	args.Query.Set("InstanceId", InstanceId)
	if v, ok := optional["JstOwnerId"]; ok {
		if JstOwnerId, ok := v.(int64); ok {
			args.Query.Set("JstOwnerId", fmt.Sprint(JstOwnerId))
		} else {
			return nil, errors.New("JstOwnerId must be int64")
		}
	}
	if v, ok := optional["PageNumber"]; ok {
		if PageNumber, ok := v.(int); ok {
			args.Query.Set("PageNumber", fmt.Sprint(PageNumber))
		} else {
			return nil, errors.New("PageNumber must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["RecordType"]; ok {
		if RecordType, ok := v.(int); ok {
			args.Query.Set("RecordType", fmt.Sprint(RecordType))
		} else {
			return nil, errors.New("RecordType must be int")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(LogineventLogResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// LogineventLogResponse represents the response of the api LogineventLog.
type LogineventLogResponse struct {
	EndTime string
	LogList struct {
		LoginEventLog []struct {
			BlockTimes int
			Location   string
			SourceIp   string
			Status     int
			Time       string
		}
	}
	PageNumber int
	PageSize   int
	StartTime  string
	TotalCount int
}

// OpenCCProtect version 2015-04-16
//
// required parameters:
//  name: InstanceId, type: string
//
// optional parameters:
//  name: InstanceType, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) OpenCCProtect(InstanceId string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "OpenCCProtect")
	args.Query.Set("InstanceId", InstanceId)
	if v, ok := optional["InstanceType"]; ok {
		if InstanceType, ok := v.(string); ok {
			args.Query.Set("InstanceType", InstanceType)
		} else {
			return nil, errors.New("InstanceType must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// OpenPortScan version 2015-04-16
//
// required parameters:
//  name: InstanceId, type: string
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) OpenPortScan(InstanceId string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "OpenPortScan")
	args.Query.Set("InstanceId", InstanceId)
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// OpenVulScan version 2015-04-16
//
// required parameters:
//  name: InstanceId, type: string
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) OpenVulScan(InstanceId string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "OpenVulScan")
	args.Query.Set("InstanceId", InstanceId)
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// QueryDdosConfig version 2015-04-16
//
// required parameters:
//  name: InstanceId, type: string
//
// optional parameters:
//  name: InstanceType, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) QueryDdosConfig(InstanceId string, optional openapi.M) (*QueryDdosConfigResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "QueryDdosConfig")
	args.Query.Set("InstanceId", InstanceId)
	if v, ok := optional["InstanceType"]; ok {
		if InstanceType, ok := v.(string); ok {
			args.Query.Set("InstanceType", InstanceType)
		} else {
			return nil, errors.New("InstanceType must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(QueryDdosConfigResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// QueryDdosConfigResponse represents the response of the api QueryDdosConfig.
type QueryDdosConfigResponse struct {
	Bps              int64
	ConfigType       string
	FlowPosition     int
	HoleBps          string
	Layer7Config     bool
	Level            int
	Pps              int64
	Qps              int64
	QpsPosition      int
	Sipconn          int64
	Sipnew           int64
	StrategyPosition int
}

// SecureCheck version 2015-04-16
//
// optional parameters:
//  name: InstanceIds, type: string
//  name: JstOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) SecureCheck(optional openapi.M) (*SecureCheckResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "SecureCheck")
	if v, ok := optional["InstanceIds"]; ok {
		if InstanceIds, ok := v.(string); ok {
			args.Query.Set("InstanceIds", InstanceIds)
		} else {
			return nil, errors.New("InstanceIds must be string")
		}
	}
	if v, ok := optional["JstOwnerId"]; ok {
		if JstOwnerId, ok := v.(int64); ok {
			args.Query.Set("JstOwnerId", fmt.Sprint(JstOwnerId))
		} else {
			return nil, errors.New("JstOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(SecureCheckResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// SecureCheckResponse represents the response of the api SecureCheck.
type SecureCheckResponse struct {
	InnerIpList struct {
		Info []struct {
			InstanceId string
			Ip         string
			Status     string
			VulNum     string
		}
	}
	NoProblemList struct {
		Info []struct {
			InstanceId string
			Ip         string
			Status     string
			VulNum     string
		}
	}
	NoScanList struct {
		Info []struct {
			InstanceId string
			Ip         string
			Status     string
			VulNum     string
		}
	}
	ProblemList struct {
		Info []struct {
			InstanceId string
			Ip         string
			Status     string
			VulNum     string
		}
	}
	RecentInstanceId string
	ScanningList     struct {
		Info []struct {
			InstanceId string
			Ip         string
			Status     string
			VulNum     string
		}
	}
}

// ServiceStatus version 2015-04-16
//
// required parameters:
//  name: InstanceId, type: string
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ServiceStatus(InstanceId string, optional openapi.M) (*ServiceStatusResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ServiceStatus")
	args.Query.Set("InstanceId", InstanceId)
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(ServiceStatusResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ServiceStatusResponse represents the response of the api ServiceStatus.
type ServiceStatusResponse struct {
	PortScan bool
	VulScan  bool
}

// SetDdosAuto version 2015-04-16
//
// required parameters:
//  name: InstanceId, type: string
//
// optional parameters:
//  name: InstanceType, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) SetDdosAuto(InstanceId string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "SetDdosAuto")
	args.Query.Set("InstanceId", InstanceId)
	if v, ok := optional["InstanceType"]; ok {
		if InstanceType, ok := v.(string); ok {
			args.Query.Set("InstanceType", InstanceType)
		} else {
			return nil, errors.New("InstanceType must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// SetDdosQps version 2015-04-16
//
// required parameters:
//  name: InstanceId, type: string
//  name: Level, type: int
//  name: QpsPosition, type: int
//
// optional parameters:
//  name: InstanceType, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) SetDdosQps(InstanceId string, Level, QpsPosition int, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "SetDdosQps")
	args.Query.Set("InstanceId", InstanceId)
	args.Query.Set("Level", fmt.Sprint(Level))
	args.Query.Set("QpsPosition", fmt.Sprint(QpsPosition))
	if v, ok := optional["InstanceType"]; ok {
		if InstanceType, ok := v.(string); ok {
			args.Query.Set("InstanceType", InstanceType)
		} else {
			return nil, errors.New("InstanceType must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// Summary version 2015-04-16
//
// optional parameters:
//  name: InstanceIds, type: string
//  name: JstOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) Summary(optional openapi.M) (*SummaryResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "Summary")
	if v, ok := optional["InstanceIds"]; ok {
		if InstanceIds, ok := v.(string); ok {
			args.Query.Set("InstanceIds", InstanceIds)
		} else {
			return nil, errors.New("InstanceIds must be string")
		}
	}
	if v, ok := optional["JstOwnerId"]; ok {
		if JstOwnerId, ok := v.(int64); ok {
			args.Query.Set("JstOwnerId", fmt.Sprint(JstOwnerId))
		} else {
			return nil, errors.New("JstOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(SummaryResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// SummaryResponse represents the response of the api Summary.
type SummaryResponse struct {
	AbnormalHostCount int64
	BruteForce        struct {
		Count     int64
		HostCount int64
	}
	Ddos struct {
		Count     int64
		HostCount int64
	}
	RemoteLogin struct {
		Count     int64
		HostCount int64
	}
	Status    int64
	WebAttack struct {
		Count     int64
		HostCount int64
	}
	WebLeak struct {
		Count     int64
		HostCount int64
	}
	Webshell struct {
		Count     int64
		HostCount int64
	}
}

// VulScanLog version 2015-04-16
//
// required parameters:
//  name: InstanceId, type: string
//
// optional parameters:
//  name: JstOwnerId, type: int64
//  name: PageNumber, type: int
//  name: PageSize, type: int
//  name: VulStatus, type: int
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) VulScanLog(InstanceId string, optional openapi.M) (*VulScanLogResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "VulScanLog")
	args.Query.Set("InstanceId", InstanceId)
	if v, ok := optional["JstOwnerId"]; ok {
		if JstOwnerId, ok := v.(int64); ok {
			args.Query.Set("JstOwnerId", fmt.Sprint(JstOwnerId))
		} else {
			return nil, errors.New("JstOwnerId must be int64")
		}
	}
	if v, ok := optional["PageNumber"]; ok {
		if PageNumber, ok := v.(int); ok {
			args.Query.Set("PageNumber", fmt.Sprint(PageNumber))
		} else {
			return nil, errors.New("PageNumber must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["VulStatus"]; ok {
		if VulStatus, ok := v.(int); ok {
			args.Query.Set("VulStatus", fmt.Sprint(VulStatus))
		} else {
			return nil, errors.New("VulStatus must be int")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(VulScanLogResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// VulScanLogResponse represents the response of the api VulScanLog.
type VulScanLogResponse struct {
	EndTime string
	LogList struct {
		VulScanLog []struct {
			HelpAddress  string
			Id           int
			Status       int
			Type         string
			Url          string
			VulParameter string
		}
	}
	PageNumber int
	PageSize   int
	StartTime  string
	TotalCount int
}

// WafInfo version 2015-04-16
//
// required parameters:
//  name: InstanceId, type: string
//
// optional parameters:
//  name: InstanceType, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) WafInfo(InstanceId string, optional openapi.M) (*WafInfoResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "WafInfo")
	args.Query.Set("InstanceId", InstanceId)
	if v, ok := optional["InstanceType"]; ok {
		if InstanceType, ok := v.(string); ok {
			args.Query.Set("InstanceType", InstanceType)
		} else {
			return nil, errors.New("InstanceType must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(WafInfoResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// WafInfoResponse represents the response of the api WafInfo.
type WafInfoResponse struct {
	WafDomainNum int
	WafInfos     struct {
		WafInfo []struct {
			Cname  string
			Domain string
			Id     int
			Status int
		}
	}
}

// WafLog version 2015-04-16
//
// required parameters:
//  name: InstanceId, type: string
//
// optional parameters:
//  name: InstanceType, type: string
//  name: JstOwnerId, type: int64
//  name: PageNumber, type: int
//  name: PageSize, type: int
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) WafLog(InstanceId string, optional openapi.M) (*WafLogResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "WafLog")
	args.Query.Set("InstanceId", InstanceId)
	if v, ok := optional["InstanceType"]; ok {
		if InstanceType, ok := v.(string); ok {
			args.Query.Set("InstanceType", InstanceType)
		} else {
			return nil, errors.New("InstanceType must be string")
		}
	}
	if v, ok := optional["JstOwnerId"]; ok {
		if JstOwnerId, ok := v.(int64); ok {
			args.Query.Set("JstOwnerId", fmt.Sprint(JstOwnerId))
		} else {
			return nil, errors.New("JstOwnerId must be int64")
		}
	}
	if v, ok := optional["PageNumber"]; ok {
		if PageNumber, ok := v.(int); ok {
			args.Query.Set("PageNumber", fmt.Sprint(PageNumber))
		} else {
			return nil, errors.New("PageNumber must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(WafLogResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// WafLogResponse represents the response of the api WafLog.
type WafLogResponse struct {
	DomainCount int
	EndTime     string
	InWhiteList bool
	LogList     struct {
		WafLog []struct {
			SourceIp string
			Status   int
			Time     string
			Type     string
			Url      string
		}
	}
	NewWafUser bool
	PageNumber int
	PageSize   int
	StartTime  string
	TotalCount int
	WafOpened  bool
	WebAttack  int
}

// WebshellLog version 2015-04-16
//
// required parameters:
//  name: InstanceId, type: string
//
// optional parameters:
//  name: JstOwnerId, type: int64
//  name: PageNumber, type: int
//  name: PageSize, type: int
//  name: RecordType, type: int
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) WebshellLog(InstanceId string, optional openapi.M) (*WebshellLogResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "WebshellLog")
	args.Query.Set("InstanceId", InstanceId)
	if v, ok := optional["JstOwnerId"]; ok {
		if JstOwnerId, ok := v.(int64); ok {
			args.Query.Set("JstOwnerId", fmt.Sprint(JstOwnerId))
		} else {
			return nil, errors.New("JstOwnerId must be int64")
		}
	}
	if v, ok := optional["PageNumber"]; ok {
		if PageNumber, ok := v.(int); ok {
			args.Query.Set("PageNumber", fmt.Sprint(PageNumber))
		} else {
			return nil, errors.New("PageNumber must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["RecordType"]; ok {
		if RecordType, ok := v.(int); ok {
			args.Query.Set("RecordType", fmt.Sprint(RecordType))
		} else {
			return nil, errors.New("RecordType must be int")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(WebshellLogResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// WebshellLogResponse represents the response of the api WebshellLog.
type WebshellLogResponse struct {
	LogList struct {
		WebshellLog []struct {
			Id     string
			Path   string
			Status int
			Time   string
		}
	}
	PageNumber int
	PageSize   int
	TotalCount int
}
