// Copyright 2015 Chen Xianren. All rights reserved.
// Code generated by openapi-meta; DO NOT EDIT

package ram

import (
	"errors"
	"fmt"

	"git.oschina.net/cxr29/aliyun-openapi-go-sdk"
)

var (
	_ = errors.New("")
	_ = fmt.Sprint("")
	_ = make(openapi.M)
)

type API struct {
	openapi.Service
}

func New(accessKeyId, accessKeySecret string) API {
	return API{openapi.NewService(accessKeyId, accessKeySecret)}
}

func NewParams() openapi.Params {
	args := openapi.NewParams()
	args.Product = Product
	args.Style = Style
	args.Version = Version
	return args
}

const (
	Product = "Ram"
	Style   = "RPC"
	Version = "2014-02-14"
)

// AddUser version 2014-02-14
//
// required parameters:
//  name: UserName, type: string
//
// optional parameters:
//  name: Comments, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) AddUser(UserName string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "AddUser")
	args.Query.Set("UserName", UserName)
	args.Scheme = "https"
	if v, ok := optional["Comments"]; ok {
		if Comments, ok := v.(string); ok {
			args.Query.Set("Comments", Comments)
		} else {
			return nil, errors.New("Comments must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteUserPolicy version 2014-02-14
//
// required parameters:
//  name: PolicyName, type: string
//  name: UserName, type: string
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) DeleteUserPolicy(PolicyName, UserName string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteUserPolicy")
	args.Query.Set("PolicyName", PolicyName)
	args.Query.Set("UserName", UserName)
	args.Scheme = "https"
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetUser version 2014-02-14
//
// required parameters:
//  name: UserName, type: string
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) GetUser(UserName string, optional openapi.M) (*GetUserResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetUser")
	args.Query.Set("UserName", UserName)
	args.Scheme = "https"
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GetUserResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetUserResponse represents the response of the api GetUser.
type GetUserResponse struct {
	Comments string
	UserName string
}

// GetUserPolicy version 2014-02-14
//
// required parameters:
//  name: PolicyName, type: string
//  name: UserName, type: string
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) GetUserPolicy(PolicyName, UserName string, optional openapi.M) (*GetUserPolicyResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetUserPolicy")
	args.Query.Set("PolicyName", PolicyName)
	args.Query.Set("UserName", UserName)
	args.Scheme = "https"
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GetUserPolicyResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetUserPolicyResponse represents the response of the api GetUserPolicy.
type GetUserPolicyResponse struct {
	PolicyDocument string
	PolicyName     string
	UserName       string
}

// ListUserPolicies version 2014-02-14
//
// required parameters:
//  name: UserName, type: string
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) ListUserPolicies(UserName string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "ListUserPolicies")
	args.Query.Set("UserName", UserName)
	args.Scheme = "https"
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListUsers version 2014-02-14
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) ListUsers(optional openapi.M) (*ListUsersResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListUsers")
	args.Scheme = "https"
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListUsersResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListUsersResponse represents the response of the api ListUsers.
type ListUsersResponse struct {
	Users struct {
		User []struct {
			Comments string
			UserName string
		}
	}
}

// PutUserPolicy version 2014-02-14
//
// required parameters:
//  name: PolicyDocument, type: string
//  name: PolicyName, type: string
//  name: UserName, type: string
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) PutUserPolicy(PolicyDocument, PolicyName, UserName string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "PutUserPolicy")
	args.Query.Set("PolicyDocument", PolicyDocument)
	args.Query.Set("PolicyName", PolicyName)
	args.Query.Set("UserName", UserName)
	args.Scheme = "https"
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// RemoveUser version 2014-02-14
//
// required parameters:
//  name: UserName, type: string
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) RemoveUser(UserName string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "RemoveUser")
	args.Query.Set("UserName", UserName)
	args.Scheme = "https"
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}
