// Copyright 2015 Chen Xianren. All rights reserved.
// Code generated by openapi-meta; DO NOT EDIT

package ram // import "github.com/cxr29/aliyun-openapi-go-sdk/apis/ram/v20150501"

import (
	"errors"
	"fmt"

	"github.com/cxr29/aliyun-openapi-go-sdk"
)

var (
	_ = errors.New("")
	_ = fmt.Sprint("")
)

type API struct {
	openapi.Service
}

func New(accessKeyId, accessKeySecret string) API {
	return API{openapi.NewService(accessKeyId, accessKeySecret)}
}

func NewParams() openapi.Params {
	args := openapi.NewParams()
	args.Product = Product
	args.Style = Style
	args.Version = Version
	return args
}

const (
	Product = "Ram"
	Style   = "RPC"
	Version = "2015-05-01"
)

// ActivateService version 2015-05-01
//
// optional parameters:
//  name: AccountId, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) ActivateService(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "ActivateService")
	args.Scheme = "https"
	if v, ok := optional["AccountId"]; ok {
		if AccountId, ok := v.(string); ok {
			args.Query.Set("AccountId", AccountId)
		} else {
			return nil, errors.New("AccountId must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// AddUserToGroup version 2015-05-01
//
// optional parameters:
//  name: GroupName, type: string
//  name: UserName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) AddUserToGroup(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "AddUserToGroup")
	args.Scheme = "https"
	if v, ok := optional["GroupName"]; ok {
		if GroupName, ok := v.(string); ok {
			args.Query.Set("GroupName", GroupName)
		} else {
			return nil, errors.New("GroupName must be string")
		}
	}
	if v, ok := optional["UserName"]; ok {
		if UserName, ok := v.(string); ok {
			args.Query.Set("UserName", UserName)
		} else {
			return nil, errors.New("UserName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// AttachPolicyToGroup version 2015-05-01
//
// optional parameters:
//  name: GroupName, type: string
//  name: PolicyName, type: string
//  name: PolicyType, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) AttachPolicyToGroup(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "AttachPolicyToGroup")
	args.Scheme = "https"
	if v, ok := optional["GroupName"]; ok {
		if GroupName, ok := v.(string); ok {
			args.Query.Set("GroupName", GroupName)
		} else {
			return nil, errors.New("GroupName must be string")
		}
	}
	if v, ok := optional["PolicyName"]; ok {
		if PolicyName, ok := v.(string); ok {
			args.Query.Set("PolicyName", PolicyName)
		} else {
			return nil, errors.New("PolicyName must be string")
		}
	}
	if v, ok := optional["PolicyType"]; ok {
		if PolicyType, ok := v.(string); ok {
			args.Query.Set("PolicyType", PolicyType)
		} else {
			return nil, errors.New("PolicyType must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// AttachPolicyToRole version 2015-05-01
//
// optional parameters:
//  name: PolicyName, type: string
//  name: PolicyType, type: string
//  name: RoleName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) AttachPolicyToRole(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "AttachPolicyToRole")
	args.Scheme = "https"
	if v, ok := optional["PolicyName"]; ok {
		if PolicyName, ok := v.(string); ok {
			args.Query.Set("PolicyName", PolicyName)
		} else {
			return nil, errors.New("PolicyName must be string")
		}
	}
	if v, ok := optional["PolicyType"]; ok {
		if PolicyType, ok := v.(string); ok {
			args.Query.Set("PolicyType", PolicyType)
		} else {
			return nil, errors.New("PolicyType must be string")
		}
	}
	if v, ok := optional["RoleName"]; ok {
		if RoleName, ok := v.(string); ok {
			args.Query.Set("RoleName", RoleName)
		} else {
			return nil, errors.New("RoleName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// AttachPolicyToUser version 2015-05-01
//
// optional parameters:
//  name: PolicyName, type: string
//  name: PolicyType, type: string
//  name: UserName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) AttachPolicyToUser(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "AttachPolicyToUser")
	args.Scheme = "https"
	if v, ok := optional["PolicyName"]; ok {
		if PolicyName, ok := v.(string); ok {
			args.Query.Set("PolicyName", PolicyName)
		} else {
			return nil, errors.New("PolicyName must be string")
		}
	}
	if v, ok := optional["PolicyType"]; ok {
		if PolicyType, ok := v.(string); ok {
			args.Query.Set("PolicyType", PolicyType)
		} else {
			return nil, errors.New("PolicyType must be string")
		}
	}
	if v, ok := optional["UserName"]; ok {
		if UserName, ok := v.(string); ok {
			args.Query.Set("UserName", UserName)
		} else {
			return nil, errors.New("UserName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// BindMFADevice version 2015-05-01
//
// optional parameters:
//  name: AuthenticationCode1, type: string
//  name: AuthenticationCode2, type: string
//  name: SerialNumber, type: string
//  name: UserName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) BindMFADevice(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "BindMFADevice")
	args.Scheme = "https"
	if v, ok := optional["AuthenticationCode1"]; ok {
		if AuthenticationCode1, ok := v.(string); ok {
			args.Query.Set("AuthenticationCode1", AuthenticationCode1)
		} else {
			return nil, errors.New("AuthenticationCode1 must be string")
		}
	}
	if v, ok := optional["AuthenticationCode2"]; ok {
		if AuthenticationCode2, ok := v.(string); ok {
			args.Query.Set("AuthenticationCode2", AuthenticationCode2)
		} else {
			return nil, errors.New("AuthenticationCode2 must be string")
		}
	}
	if v, ok := optional["SerialNumber"]; ok {
		if SerialNumber, ok := v.(string); ok {
			args.Query.Set("SerialNumber", SerialNumber)
		} else {
			return nil, errors.New("SerialNumber must be string")
		}
	}
	if v, ok := optional["UserName"]; ok {
		if UserName, ok := v.(string); ok {
			args.Query.Set("UserName", UserName)
		} else {
			return nil, errors.New("UserName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ClearAccountAlias version 2015-05-01
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) ClearAccountAlias(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "ClearAccountAlias")
	args.Scheme = "https"
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateAccessKey version 2015-05-01
//
// optional parameters:
//  name: UserName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) CreateAccessKey(optional openapi.M) (*CreateAccessKeyResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateAccessKey")
	args.Scheme = "https"
	if v, ok := optional["UserName"]; ok {
		if UserName, ok := v.(string); ok {
			args.Query.Set("UserName", UserName)
		} else {
			return nil, errors.New("UserName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(CreateAccessKeyResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateAccessKeyResponse represents the response of the api CreateAccessKey.
type CreateAccessKeyResponse struct {
	AccessKey struct {
		AccessKeyId     string
		AccessKeySecret string
		CreateDate      string
		Status          string
	}
}

// CreateGroup version 2015-05-01
//
// optional parameters:
//  name: Comments, type: string
//  name: GroupName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) CreateGroup(optional openapi.M) (*CreateGroupResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateGroup")
	args.Scheme = "https"
	if v, ok := optional["Comments"]; ok {
		if Comments, ok := v.(string); ok {
			args.Query.Set("Comments", Comments)
		} else {
			return nil, errors.New("Comments must be string")
		}
	}
	if v, ok := optional["GroupName"]; ok {
		if GroupName, ok := v.(string); ok {
			args.Query.Set("GroupName", GroupName)
		} else {
			return nil, errors.New("GroupName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(CreateGroupResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateGroupResponse represents the response of the api CreateGroup.
type CreateGroupResponse struct {
	Group struct {
		Comments   string
		CreateDate string
		GroupName  string
	}
}

// CreateLoginProfile version 2015-05-01
//
// optional parameters:
//  name: MFABindRequired, type: bool
//  name: Password, type: string
//  name: PasswordResetRequired, type: bool
//  name: UserName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) CreateLoginProfile(optional openapi.M) (*CreateLoginProfileResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateLoginProfile")
	args.Scheme = "https"
	if v, ok := optional["MFABindRequired"]; ok {
		if MFABindRequired, ok := v.(bool); ok {
			args.Query.Set("MFABindRequired", fmt.Sprint(MFABindRequired))
		} else {
			return nil, errors.New("MFABindRequired must be bool")
		}
	}
	if v, ok := optional["Password"]; ok {
		if Password, ok := v.(string); ok {
			args.Query.Set("Password", Password)
		} else {
			return nil, errors.New("Password must be string")
		}
	}
	if v, ok := optional["PasswordResetRequired"]; ok {
		if PasswordResetRequired, ok := v.(bool); ok {
			args.Query.Set("PasswordResetRequired", fmt.Sprint(PasswordResetRequired))
		} else {
			return nil, errors.New("PasswordResetRequired must be bool")
		}
	}
	if v, ok := optional["UserName"]; ok {
		if UserName, ok := v.(string); ok {
			args.Query.Set("UserName", UserName)
		} else {
			return nil, errors.New("UserName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(CreateLoginProfileResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateLoginProfileResponse represents the response of the api CreateLoginProfile.
type CreateLoginProfileResponse struct {
	LoginProfile struct {
		CreateDate            string
		MFABindRequired       bool
		PasswordResetRequired bool
		UserName              string
	}
}

// CreatePolicy version 2015-05-01
//
// optional parameters:
//  name: Description, type: string
//  name: PolicyDocument, type: string
//  name: PolicyName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) CreatePolicy(optional openapi.M) (*CreatePolicyResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreatePolicy")
	args.Scheme = "https"
	if v, ok := optional["Description"]; ok {
		if Description, ok := v.(string); ok {
			args.Query.Set("Description", Description)
		} else {
			return nil, errors.New("Description must be string")
		}
	}
	if v, ok := optional["PolicyDocument"]; ok {
		if PolicyDocument, ok := v.(string); ok {
			args.Query.Set("PolicyDocument", PolicyDocument)
		} else {
			return nil, errors.New("PolicyDocument must be string")
		}
	}
	if v, ok := optional["PolicyName"]; ok {
		if PolicyName, ok := v.(string); ok {
			args.Query.Set("PolicyName", PolicyName)
		} else {
			return nil, errors.New("PolicyName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(CreatePolicyResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreatePolicyResponse represents the response of the api CreatePolicy.
type CreatePolicyResponse struct {
	Policy struct {
		CreateDate     string
		DefaultVersion string
		Description    string
		PolicyName     string
		PolicyType     string
	}
}

// CreatePolicyVersion version 2015-05-01
//
// optional parameters:
//  name: PolicyDocument, type: string
//  name: PolicyName, type: string
//  name: SetAsDefault, type: bool
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) CreatePolicyVersion(optional openapi.M) (*CreatePolicyVersionResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreatePolicyVersion")
	args.Scheme = "https"
	if v, ok := optional["PolicyDocument"]; ok {
		if PolicyDocument, ok := v.(string); ok {
			args.Query.Set("PolicyDocument", PolicyDocument)
		} else {
			return nil, errors.New("PolicyDocument must be string")
		}
	}
	if v, ok := optional["PolicyName"]; ok {
		if PolicyName, ok := v.(string); ok {
			args.Query.Set("PolicyName", PolicyName)
		} else {
			return nil, errors.New("PolicyName must be string")
		}
	}
	if v, ok := optional["SetAsDefault"]; ok {
		if SetAsDefault, ok := v.(bool); ok {
			args.Query.Set("SetAsDefault", fmt.Sprint(SetAsDefault))
		} else {
			return nil, errors.New("SetAsDefault must be bool")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(CreatePolicyVersionResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreatePolicyVersionResponse represents the response of the api CreatePolicyVersion.
type CreatePolicyVersionResponse struct {
	PolicyVersion struct {
		CreateDate       string
		IsDefaultVersion bool
		PolicyDocument   string
		VersionId        string
	}
}

// CreateRole version 2015-05-01
//
// optional parameters:
//  name: AssumeRolePolicyDocument, type: string
//  name: Description, type: string
//  name: RoleName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) CreateRole(optional openapi.M) (*CreateRoleResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateRole")
	args.Scheme = "https"
	if v, ok := optional["AssumeRolePolicyDocument"]; ok {
		if AssumeRolePolicyDocument, ok := v.(string); ok {
			args.Query.Set("AssumeRolePolicyDocument", AssumeRolePolicyDocument)
		} else {
			return nil, errors.New("AssumeRolePolicyDocument must be string")
		}
	}
	if v, ok := optional["Description"]; ok {
		if Description, ok := v.(string); ok {
			args.Query.Set("Description", Description)
		} else {
			return nil, errors.New("Description must be string")
		}
	}
	if v, ok := optional["RoleName"]; ok {
		if RoleName, ok := v.(string); ok {
			args.Query.Set("RoleName", RoleName)
		} else {
			return nil, errors.New("RoleName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(CreateRoleResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateRoleResponse represents the response of the api CreateRole.
type CreateRoleResponse struct {
	Role struct {
		Arn                      string
		AssumeRolePolicyDocument string
		CreateDate               string
		Description              string
		RoleId                   string
		RoleName                 string
	}
}

// CreateUser version 2015-05-01
//
// optional parameters:
//  name: Comments, type: string
//  name: DisplayName, type: string
//  name: Email, type: string
//  name: MobilePhone, type: string
//  name: UserName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) CreateUser(optional openapi.M) (*CreateUserResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateUser")
	args.Scheme = "https"
	if v, ok := optional["Comments"]; ok {
		if Comments, ok := v.(string); ok {
			args.Query.Set("Comments", Comments)
		} else {
			return nil, errors.New("Comments must be string")
		}
	}
	if v, ok := optional["DisplayName"]; ok {
		if DisplayName, ok := v.(string); ok {
			args.Query.Set("DisplayName", DisplayName)
		} else {
			return nil, errors.New("DisplayName must be string")
		}
	}
	if v, ok := optional["Email"]; ok {
		if Email, ok := v.(string); ok {
			args.Query.Set("Email", Email)
		} else {
			return nil, errors.New("Email must be string")
		}
	}
	if v, ok := optional["MobilePhone"]; ok {
		if MobilePhone, ok := v.(string); ok {
			args.Query.Set("MobilePhone", MobilePhone)
		} else {
			return nil, errors.New("MobilePhone must be string")
		}
	}
	if v, ok := optional["UserName"]; ok {
		if UserName, ok := v.(string); ok {
			args.Query.Set("UserName", UserName)
		} else {
			return nil, errors.New("UserName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(CreateUserResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateUserResponse represents the response of the api CreateUser.
type CreateUserResponse struct {
	User struct {
		Comments    string
		CreateDate  string
		DisplayName string
		Email       string
		MobilePhone string
		UserId      string
		UserName    string
	}
}

// CreateVirtualMFADevice version 2015-05-01
//
// optional parameters:
//  name: VirtualMFADeviceName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) CreateVirtualMFADevice(optional openapi.M) (*CreateVirtualMFADeviceResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateVirtualMFADevice")
	args.Scheme = "https"
	if v, ok := optional["VirtualMFADeviceName"]; ok {
		if VirtualMFADeviceName, ok := v.(string); ok {
			args.Query.Set("VirtualMFADeviceName", VirtualMFADeviceName)
		} else {
			return nil, errors.New("VirtualMFADeviceName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(CreateVirtualMFADeviceResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateVirtualMFADeviceResponse represents the response of the api CreateVirtualMFADevice.
type CreateVirtualMFADeviceResponse struct {
	VirtualMFADevice struct {
		Base32StringSeed string
		QRCodePNG        string
		SerialNumber     string
	}
}

// DeactivateService version 2015-05-01
//
// optional parameters:
//  name: AccountId, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) DeactivateService(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DeactivateService")
	args.Scheme = "https"
	if v, ok := optional["AccountId"]; ok {
		if AccountId, ok := v.(string); ok {
			args.Query.Set("AccountId", AccountId)
		} else {
			return nil, errors.New("AccountId must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteAccessKey version 2015-05-01
//
// optional parameters:
//  name: UserAccessKeyId, type: string
//  name: UserName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) DeleteAccessKey(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteAccessKey")
	args.Scheme = "https"
	if v, ok := optional["UserAccessKeyId"]; ok {
		if UserAccessKeyId, ok := v.(string); ok {
			args.Query.Set("UserAccessKeyId", UserAccessKeyId)
		} else {
			return nil, errors.New("UserAccessKeyId must be string")
		}
	}
	if v, ok := optional["UserName"]; ok {
		if UserName, ok := v.(string); ok {
			args.Query.Set("UserName", UserName)
		} else {
			return nil, errors.New("UserName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteGroup version 2015-05-01
//
// optional parameters:
//  name: GroupName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) DeleteGroup(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteGroup")
	args.Scheme = "https"
	if v, ok := optional["GroupName"]; ok {
		if GroupName, ok := v.(string); ok {
			args.Query.Set("GroupName", GroupName)
		} else {
			return nil, errors.New("GroupName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteLoginProfile version 2015-05-01
//
// optional parameters:
//  name: UserName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) DeleteLoginProfile(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteLoginProfile")
	args.Scheme = "https"
	if v, ok := optional["UserName"]; ok {
		if UserName, ok := v.(string); ok {
			args.Query.Set("UserName", UserName)
		} else {
			return nil, errors.New("UserName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeletePolicy version 2015-05-01
//
// optional parameters:
//  name: PolicyName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) DeletePolicy(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DeletePolicy")
	args.Scheme = "https"
	if v, ok := optional["PolicyName"]; ok {
		if PolicyName, ok := v.(string); ok {
			args.Query.Set("PolicyName", PolicyName)
		} else {
			return nil, errors.New("PolicyName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeletePolicyVersion version 2015-05-01
//
// optional parameters:
//  name: PolicyName, type: string
//  name: VersionId, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) DeletePolicyVersion(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DeletePolicyVersion")
	args.Scheme = "https"
	if v, ok := optional["PolicyName"]; ok {
		if PolicyName, ok := v.(string); ok {
			args.Query.Set("PolicyName", PolicyName)
		} else {
			return nil, errors.New("PolicyName must be string")
		}
	}
	if v, ok := optional["VersionId"]; ok {
		if VersionId, ok := v.(string); ok {
			args.Query.Set("VersionId", VersionId)
		} else {
			return nil, errors.New("VersionId must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteRole version 2015-05-01
//
// optional parameters:
//  name: RoleName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) DeleteRole(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteRole")
	args.Scheme = "https"
	if v, ok := optional["RoleName"]; ok {
		if RoleName, ok := v.(string); ok {
			args.Query.Set("RoleName", RoleName)
		} else {
			return nil, errors.New("RoleName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteUser version 2015-05-01
//
// optional parameters:
//  name: UserName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) DeleteUser(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteUser")
	args.Scheme = "https"
	if v, ok := optional["UserName"]; ok {
		if UserName, ok := v.(string); ok {
			args.Query.Set("UserName", UserName)
		} else {
			return nil, errors.New("UserName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteVirtualMFADevice version 2015-05-01
//
// optional parameters:
//  name: SerialNumber, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) DeleteVirtualMFADevice(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteVirtualMFADevice")
	args.Scheme = "https"
	if v, ok := optional["SerialNumber"]; ok {
		if SerialNumber, ok := v.(string); ok {
			args.Query.Set("SerialNumber", SerialNumber)
		} else {
			return nil, errors.New("SerialNumber must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DetachPolicyFromGroup version 2015-05-01
//
// optional parameters:
//  name: GroupName, type: string
//  name: PolicyName, type: string
//  name: PolicyType, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) DetachPolicyFromGroup(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DetachPolicyFromGroup")
	args.Scheme = "https"
	if v, ok := optional["GroupName"]; ok {
		if GroupName, ok := v.(string); ok {
			args.Query.Set("GroupName", GroupName)
		} else {
			return nil, errors.New("GroupName must be string")
		}
	}
	if v, ok := optional["PolicyName"]; ok {
		if PolicyName, ok := v.(string); ok {
			args.Query.Set("PolicyName", PolicyName)
		} else {
			return nil, errors.New("PolicyName must be string")
		}
	}
	if v, ok := optional["PolicyType"]; ok {
		if PolicyType, ok := v.(string); ok {
			args.Query.Set("PolicyType", PolicyType)
		} else {
			return nil, errors.New("PolicyType must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DetachPolicyFromRole version 2015-05-01
//
// optional parameters:
//  name: PolicyName, type: string
//  name: PolicyType, type: string
//  name: RoleName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) DetachPolicyFromRole(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DetachPolicyFromRole")
	args.Scheme = "https"
	if v, ok := optional["PolicyName"]; ok {
		if PolicyName, ok := v.(string); ok {
			args.Query.Set("PolicyName", PolicyName)
		} else {
			return nil, errors.New("PolicyName must be string")
		}
	}
	if v, ok := optional["PolicyType"]; ok {
		if PolicyType, ok := v.(string); ok {
			args.Query.Set("PolicyType", PolicyType)
		} else {
			return nil, errors.New("PolicyType must be string")
		}
	}
	if v, ok := optional["RoleName"]; ok {
		if RoleName, ok := v.(string); ok {
			args.Query.Set("RoleName", RoleName)
		} else {
			return nil, errors.New("RoleName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DetachPolicyFromUser version 2015-05-01
//
// optional parameters:
//  name: PolicyName, type: string
//  name: PolicyType, type: string
//  name: UserName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) DetachPolicyFromUser(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DetachPolicyFromUser")
	args.Scheme = "https"
	if v, ok := optional["PolicyName"]; ok {
		if PolicyName, ok := v.(string); ok {
			args.Query.Set("PolicyName", PolicyName)
		} else {
			return nil, errors.New("PolicyName must be string")
		}
	}
	if v, ok := optional["PolicyType"]; ok {
		if PolicyType, ok := v.(string); ok {
			args.Query.Set("PolicyType", PolicyType)
		} else {
			return nil, errors.New("PolicyType must be string")
		}
	}
	if v, ok := optional["UserName"]; ok {
		if UserName, ok := v.(string); ok {
			args.Query.Set("UserName", UserName)
		} else {
			return nil, errors.New("UserName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetAccountAlias version 2015-05-01
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) GetAccountAlias(optional openapi.M) (*GetAccountAliasResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetAccountAlias")
	args.Scheme = "https"
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GetAccountAliasResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetAccountAliasResponse represents the response of the api GetAccountAlias.
type GetAccountAliasResponse struct {
	AccountAlias string
}

// GetAccountSummary version 2015-05-01
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) GetAccountSummary(optional openapi.M) (*GetAccountSummaryResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetAccountSummary")
	args.Scheme = "https"
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GetAccountSummaryResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetAccountSummaryResponse represents the response of the api GetAccountSummary.
type GetAccountSummaryResponse struct {
	SummaryMap struct {
		AccessKeysPerUserQuota        int
		AttachedPoliciesPerGroupQuota int
		AttachedPoliciesPerRoleQuota  int
		AttachedPoliciesPerUserQuota  int
		Groups                        int
		GroupsPerUserQuota            int
		GroupsQuota                   int
		MFADevices                    int
		MFADevicesInUse               int
		Policies                      int
		PoliciesQuota                 int
		PolicySizeQuota               int
		Roles                         int
		RolesQuota                    int
		Users                         int
		UsersQuota                    int
		VersionsPerPolicyQuota        int
		VirtualMFADevicesQuota        int
	}
}

// GetGroup version 2015-05-01
//
// optional parameters:
//  name: GroupName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) GetGroup(optional openapi.M) (*GetGroupResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetGroup")
	args.Scheme = "https"
	if v, ok := optional["GroupName"]; ok {
		if GroupName, ok := v.(string); ok {
			args.Query.Set("GroupName", GroupName)
		} else {
			return nil, errors.New("GroupName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GetGroupResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetGroupResponse represents the response of the api GetGroup.
type GetGroupResponse struct {
	Group struct {
		Comments   string
		CreateDate string
		GroupName  string
		UpdateDate string
	}
}

// GetLoginProfile version 2015-05-01
//
// optional parameters:
//  name: UserName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) GetLoginProfile(optional openapi.M) (*GetLoginProfileResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetLoginProfile")
	args.Scheme = "https"
	if v, ok := optional["UserName"]; ok {
		if UserName, ok := v.(string); ok {
			args.Query.Set("UserName", UserName)
		} else {
			return nil, errors.New("UserName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GetLoginProfileResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetLoginProfileResponse represents the response of the api GetLoginProfile.
type GetLoginProfileResponse struct {
	LoginProfile struct {
		CreateDate            string
		MFABindRequired       bool
		PasswordResetRequired bool
		UserName              string
	}
}

// GetPasswordPolicy version 2015-05-01
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) GetPasswordPolicy(optional openapi.M) (*GetPasswordPolicyResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetPasswordPolicy")
	args.Scheme = "https"
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GetPasswordPolicyResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetPasswordPolicyResponse represents the response of the api GetPasswordPolicy.
type GetPasswordPolicyResponse struct {
	PasswordPolicy struct {
		MinimumPasswordLength      int
		RequireLowercaseCharacters bool
		RequireNumbers             bool
		RequireSymbols             bool
		RequireUppercaseCharacters bool
	}
}

// GetPolicy version 2015-05-01
//
// optional parameters:
//  name: PolicyName, type: string
//  name: PolicyType, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) GetPolicy(optional openapi.M) (*GetPolicyResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetPolicy")
	args.Scheme = "https"
	if v, ok := optional["PolicyName"]; ok {
		if PolicyName, ok := v.(string); ok {
			args.Query.Set("PolicyName", PolicyName)
		} else {
			return nil, errors.New("PolicyName must be string")
		}
	}
	if v, ok := optional["PolicyType"]; ok {
		if PolicyType, ok := v.(string); ok {
			args.Query.Set("PolicyType", PolicyType)
		} else {
			return nil, errors.New("PolicyType must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GetPolicyResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetPolicyResponse represents the response of the api GetPolicy.
type GetPolicyResponse struct {
	Policy struct {
		AttachmentCount int
		CreateDate      string
		DefaultVersion  string
		Description     string
		PolicyDocument  string
		PolicyName      string
		PolicyType      string
		UpdateDate      string
	}
}

// GetPolicyVersion version 2015-05-01
//
// optional parameters:
//  name: PolicyName, type: string
//  name: PolicyType, type: string
//  name: VersionId, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) GetPolicyVersion(optional openapi.M) (*GetPolicyVersionResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetPolicyVersion")
	args.Scheme = "https"
	if v, ok := optional["PolicyName"]; ok {
		if PolicyName, ok := v.(string); ok {
			args.Query.Set("PolicyName", PolicyName)
		} else {
			return nil, errors.New("PolicyName must be string")
		}
	}
	if v, ok := optional["PolicyType"]; ok {
		if PolicyType, ok := v.(string); ok {
			args.Query.Set("PolicyType", PolicyType)
		} else {
			return nil, errors.New("PolicyType must be string")
		}
	}
	if v, ok := optional["VersionId"]; ok {
		if VersionId, ok := v.(string); ok {
			args.Query.Set("VersionId", VersionId)
		} else {
			return nil, errors.New("VersionId must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GetPolicyVersionResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetPolicyVersionResponse represents the response of the api GetPolicyVersion.
type GetPolicyVersionResponse struct {
	PolicyVersion struct {
		CreateDate       string
		IsDefaultVersion bool
		PolicyDocument   string
		VersionId        string
	}
}

// GetRole version 2015-05-01
//
// optional parameters:
//  name: RoleName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) GetRole(optional openapi.M) (*GetRoleResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetRole")
	args.Scheme = "https"
	if v, ok := optional["RoleName"]; ok {
		if RoleName, ok := v.(string); ok {
			args.Query.Set("RoleName", RoleName)
		} else {
			return nil, errors.New("RoleName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GetRoleResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetRoleResponse represents the response of the api GetRole.
type GetRoleResponse struct {
	Role struct {
		Arn                      string
		AssumeRolePolicyDocument string
		CreateDate               string
		Description              string
		RoleId                   string
		RoleName                 string
		UpdateDate               string
	}
}

// GetSecurityPreference version 2015-05-01
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) GetSecurityPreference(optional openapi.M) (*GetSecurityPreferenceResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetSecurityPreference")
	args.Scheme = "https"
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GetSecurityPreferenceResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetSecurityPreferenceResponse represents the response of the api GetSecurityPreference.
type GetSecurityPreferenceResponse struct {
	SecurityPreference struct {
		LoginProfilePreference struct {
			EnableSaveMFATicket bool
		}
	}
}

// GetServiceStatus version 2015-05-01
//
// optional parameters:
//  name: AccountId, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) GetServiceStatus(optional openapi.M) (*GetServiceStatusResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetServiceStatus")
	args.Scheme = "https"
	if v, ok := optional["AccountId"]; ok {
		if AccountId, ok := v.(string); ok {
			args.Query.Set("AccountId", AccountId)
		} else {
			return nil, errors.New("AccountId must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GetServiceStatusResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetServiceStatusResponse represents the response of the api GetServiceStatus.
type GetServiceStatusResponse struct {
	Status string
}

// GetUser version 2015-05-01
//
// optional parameters:
//  name: UserName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) GetUser(optional openapi.M) (*GetUserResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetUser")
	args.Scheme = "https"
	if v, ok := optional["UserName"]; ok {
		if UserName, ok := v.(string); ok {
			args.Query.Set("UserName", UserName)
		} else {
			return nil, errors.New("UserName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GetUserResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetUserResponse represents the response of the api GetUser.
type GetUserResponse struct {
	User struct {
		Comments      string
		CreateDate    string
		DisplayName   string
		Email         string
		LastLoginDate string
		MobilePhone   string
		UpdateDate    string
		UserId        string
		UserName      string
	}
}

// GetUserMFAInfo version 2015-05-01
//
// optional parameters:
//  name: UserName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) GetUserMFAInfo(optional openapi.M) (*GetUserMFAInfoResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetUserMFAInfo")
	args.Scheme = "https"
	if v, ok := optional["UserName"]; ok {
		if UserName, ok := v.(string); ok {
			args.Query.Set("UserName", UserName)
		} else {
			return nil, errors.New("UserName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GetUserMFAInfoResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetUserMFAInfoResponse represents the response of the api GetUserMFAInfo.
type GetUserMFAInfoResponse struct {
	MFADevice struct {
		SerialNumber string
	}
}

// ListAccessKeys version 2015-05-01
//
// optional parameters:
//  name: UserName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) ListAccessKeys(optional openapi.M) (*ListAccessKeysResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListAccessKeys")
	args.Scheme = "https"
	if v, ok := optional["UserName"]; ok {
		if UserName, ok := v.(string); ok {
			args.Query.Set("UserName", UserName)
		} else {
			return nil, errors.New("UserName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListAccessKeysResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListAccessKeysResponse represents the response of the api ListAccessKeys.
type ListAccessKeysResponse struct {
	AccessKeys struct {
		AccessKey []struct {
			AccessKeyId string
			CreateDate  string
			Status      string
		}
	}
}

// ListEntitiesForPolicy version 2015-05-01
//
// optional parameters:
//  name: PolicyName, type: string
//  name: PolicyType, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) ListEntitiesForPolicy(optional openapi.M) (*ListEntitiesForPolicyResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListEntitiesForPolicy")
	args.Scheme = "https"
	if v, ok := optional["PolicyName"]; ok {
		if PolicyName, ok := v.(string); ok {
			args.Query.Set("PolicyName", PolicyName)
		} else {
			return nil, errors.New("PolicyName must be string")
		}
	}
	if v, ok := optional["PolicyType"]; ok {
		if PolicyType, ok := v.(string); ok {
			args.Query.Set("PolicyType", PolicyType)
		} else {
			return nil, errors.New("PolicyType must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListEntitiesForPolicyResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListEntitiesForPolicyResponse represents the response of the api ListEntitiesForPolicy.
type ListEntitiesForPolicyResponse struct {
	Groups struct {
		Group []struct {
			AttachDate string
			Comments   string
			GroupName  string
		}
	}
	Roles struct {
		Role []struct {
			Arn         string
			AttachDate  string
			Description string
			RoleId      string
			RoleName    string
		}
	}
	Users struct {
		User []struct {
			AttachDate  string
			DisplayName string
			UserId      string
			UserName    string
		}
	}
}

// ListGroups version 2015-05-01
//
// optional parameters:
//  name: Marker, type: string
//  name: MaxItems, type: int
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) ListGroups(optional openapi.M) (*ListGroupsResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListGroups")
	args.Scheme = "https"
	if v, ok := optional["Marker"]; ok {
		if Marker, ok := v.(string); ok {
			args.Query.Set("Marker", Marker)
		} else {
			return nil, errors.New("Marker must be string")
		}
	}
	if v, ok := optional["MaxItems"]; ok {
		if MaxItems, ok := v.(int); ok {
			args.Query.Set("MaxItems", fmt.Sprint(MaxItems))
		} else {
			return nil, errors.New("MaxItems must be int")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListGroupsResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListGroupsResponse represents the response of the api ListGroups.
type ListGroupsResponse struct {
	Groups struct {
		Group []struct {
			Comments   string
			CreateDate string
			GroupName  string
			UpdateDate string
		}
	}
	IsTruncated bool
	Marker      string
}

// ListGroupsForUser version 2015-05-01
//
// optional parameters:
//  name: UserName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) ListGroupsForUser(optional openapi.M) (*ListGroupsForUserResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListGroupsForUser")
	args.Scheme = "https"
	if v, ok := optional["UserName"]; ok {
		if UserName, ok := v.(string); ok {
			args.Query.Set("UserName", UserName)
		} else {
			return nil, errors.New("UserName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListGroupsForUserResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListGroupsForUserResponse represents the response of the api ListGroupsForUser.
type ListGroupsForUserResponse struct {
	Groups struct {
		Group []struct {
			Comments  string
			GroupName string
			JoinDate  string
		}
	}
}

// ListPolicies version 2015-05-01
//
// optional parameters:
//  name: Marker, type: string
//  name: MaxItems, type: int
//  name: PolicyType, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) ListPolicies(optional openapi.M) (*ListPoliciesResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListPolicies")
	args.Scheme = "https"
	if v, ok := optional["Marker"]; ok {
		if Marker, ok := v.(string); ok {
			args.Query.Set("Marker", Marker)
		} else {
			return nil, errors.New("Marker must be string")
		}
	}
	if v, ok := optional["MaxItems"]; ok {
		if MaxItems, ok := v.(int); ok {
			args.Query.Set("MaxItems", fmt.Sprint(MaxItems))
		} else {
			return nil, errors.New("MaxItems must be int")
		}
	}
	if v, ok := optional["PolicyType"]; ok {
		if PolicyType, ok := v.(string); ok {
			args.Query.Set("PolicyType", PolicyType)
		} else {
			return nil, errors.New("PolicyType must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListPoliciesResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListPoliciesResponse represents the response of the api ListPolicies.
type ListPoliciesResponse struct {
	IsTruncated bool
	Marker      string
	Policies    struct {
		Policy []struct {
			AttachmentCount int
			CreateDate      string
			DefaultVersion  string
			Description     string
			PolicyName      string
			PolicyType      string
			UpdateDate      string
		}
	}
}

// ListPoliciesForGroup version 2015-05-01
//
// optional parameters:
//  name: GroupName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) ListPoliciesForGroup(optional openapi.M) (*ListPoliciesForGroupResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListPoliciesForGroup")
	args.Scheme = "https"
	if v, ok := optional["GroupName"]; ok {
		if GroupName, ok := v.(string); ok {
			args.Query.Set("GroupName", GroupName)
		} else {
			return nil, errors.New("GroupName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListPoliciesForGroupResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListPoliciesForGroupResponse represents the response of the api ListPoliciesForGroup.
type ListPoliciesForGroupResponse struct {
	Policies struct {
		Policy []struct {
			AttachDate     string
			DefaultVersion string
			Description    string
			PolicyName     string
			PolicyType     string
		}
	}
}

// ListPoliciesForRole version 2015-05-01
//
// optional parameters:
//  name: RoleName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) ListPoliciesForRole(optional openapi.M) (*ListPoliciesForRoleResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListPoliciesForRole")
	args.Scheme = "https"
	if v, ok := optional["RoleName"]; ok {
		if RoleName, ok := v.(string); ok {
			args.Query.Set("RoleName", RoleName)
		} else {
			return nil, errors.New("RoleName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListPoliciesForRoleResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListPoliciesForRoleResponse represents the response of the api ListPoliciesForRole.
type ListPoliciesForRoleResponse struct {
	Policies struct {
		Policy []struct {
			AttachDate     string
			DefaultVersion string
			Description    string
			PolicyName     string
			PolicyType     string
		}
	}
}

// ListPoliciesForUser version 2015-05-01
//
// optional parameters:
//  name: UserName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) ListPoliciesForUser(optional openapi.M) (*ListPoliciesForUserResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListPoliciesForUser")
	args.Scheme = "https"
	if v, ok := optional["UserName"]; ok {
		if UserName, ok := v.(string); ok {
			args.Query.Set("UserName", UserName)
		} else {
			return nil, errors.New("UserName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListPoliciesForUserResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListPoliciesForUserResponse represents the response of the api ListPoliciesForUser.
type ListPoliciesForUserResponse struct {
	Policies struct {
		Policy []struct {
			AttachDate     string
			DefaultVersion string
			Description    string
			PolicyName     string
			PolicyType     string
		}
	}
}

// ListPolicyVersions version 2015-05-01
//
// optional parameters:
//  name: PolicyName, type: string
//  name: PolicyType, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) ListPolicyVersions(optional openapi.M) (*ListPolicyVersionsResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListPolicyVersions")
	args.Scheme = "https"
	if v, ok := optional["PolicyName"]; ok {
		if PolicyName, ok := v.(string); ok {
			args.Query.Set("PolicyName", PolicyName)
		} else {
			return nil, errors.New("PolicyName must be string")
		}
	}
	if v, ok := optional["PolicyType"]; ok {
		if PolicyType, ok := v.(string); ok {
			args.Query.Set("PolicyType", PolicyType)
		} else {
			return nil, errors.New("PolicyType must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListPolicyVersionsResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListPolicyVersionsResponse represents the response of the api ListPolicyVersions.
type ListPolicyVersionsResponse struct {
	PolicyVersions struct {
		PolicyVersion []struct {
			CreateDate       string
			IsDefaultVersion bool
			PolicyDocument   string
			VersionId        string
		}
	}
}

// ListRoles version 2015-05-01
//
// optional parameters:
//  name: Marker, type: string
//  name: MaxItems, type: int
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) ListRoles(optional openapi.M) (*ListRolesResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListRoles")
	args.Scheme = "https"
	if v, ok := optional["Marker"]; ok {
		if Marker, ok := v.(string); ok {
			args.Query.Set("Marker", Marker)
		} else {
			return nil, errors.New("Marker must be string")
		}
	}
	if v, ok := optional["MaxItems"]; ok {
		if MaxItems, ok := v.(int); ok {
			args.Query.Set("MaxItems", fmt.Sprint(MaxItems))
		} else {
			return nil, errors.New("MaxItems must be int")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListRolesResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListRolesResponse represents the response of the api ListRoles.
type ListRolesResponse struct {
	IsTruncated bool
	Marker      string
	Roles       struct {
		Role []struct {
			Arn         string
			CreateDate  string
			Description string
			RoleId      string
			RoleName    string
			UpdateDate  string
		}
	}
}

// ListUsers version 2015-05-01
//
// optional parameters:
//  name: Marker, type: string
//  name: MaxItems, type: int
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) ListUsers(optional openapi.M) (*ListUsersResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListUsers")
	args.Scheme = "https"
	if v, ok := optional["Marker"]; ok {
		if Marker, ok := v.(string); ok {
			args.Query.Set("Marker", Marker)
		} else {
			return nil, errors.New("Marker must be string")
		}
	}
	if v, ok := optional["MaxItems"]; ok {
		if MaxItems, ok := v.(int); ok {
			args.Query.Set("MaxItems", fmt.Sprint(MaxItems))
		} else {
			return nil, errors.New("MaxItems must be int")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListUsersResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListUsersResponse represents the response of the api ListUsers.
type ListUsersResponse struct {
	IsTruncated bool
	Marker      string
	Users       struct {
		User []struct {
			Comments    string
			CreateDate  string
			DisplayName string
			Email       string
			MobilePhone string
			UpdateDate  string
			UserId      string
			UserName    string
		}
	}
}

// ListUsersForGroup version 2015-05-01
//
// optional parameters:
//  name: GroupName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) ListUsersForGroup(optional openapi.M) (*ListUsersForGroupResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListUsersForGroup")
	args.Scheme = "https"
	if v, ok := optional["GroupName"]; ok {
		if GroupName, ok := v.(string); ok {
			args.Query.Set("GroupName", GroupName)
		} else {
			return nil, errors.New("GroupName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListUsersForGroupResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListUsersForGroupResponse represents the response of the api ListUsersForGroup.
type ListUsersForGroupResponse struct {
	Users struct {
		User []struct {
			DisplayName string
			JoinDate    string
			UserName    string
		}
	}
}

// ListVirtualMFADevices version 2015-05-01
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) ListVirtualMFADevices(optional openapi.M) (*ListVirtualMFADevicesResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListVirtualMFADevices")
	args.Scheme = "https"
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListVirtualMFADevicesResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListVirtualMFADevicesResponse represents the response of the api ListVirtualMFADevices.
type ListVirtualMFADevicesResponse struct {
	VirtualMFADevices struct {
		VirtualMFADevice []struct {
			ActivateDate string
			SerialNumber string
			User         struct {
				DisplayName string
				UserId      string
				UserName    string
			}
		}
	}
}

// RemoveUserFromGroup version 2015-05-01
//
// optional parameters:
//  name: GroupName, type: string
//  name: UserName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) RemoveUserFromGroup(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "RemoveUserFromGroup")
	args.Scheme = "https"
	if v, ok := optional["GroupName"]; ok {
		if GroupName, ok := v.(string); ok {
			args.Query.Set("GroupName", GroupName)
		} else {
			return nil, errors.New("GroupName must be string")
		}
	}
	if v, ok := optional["UserName"]; ok {
		if UserName, ok := v.(string); ok {
			args.Query.Set("UserName", UserName)
		} else {
			return nil, errors.New("UserName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// SetAccountAlias version 2015-05-01
//
// optional parameters:
//  name: AccountAlias, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) SetAccountAlias(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "SetAccountAlias")
	args.Scheme = "https"
	if v, ok := optional["AccountAlias"]; ok {
		if AccountAlias, ok := v.(string); ok {
			args.Query.Set("AccountAlias", AccountAlias)
		} else {
			return nil, errors.New("AccountAlias must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// SetDefaultPolicyVersion version 2015-05-01
//
// optional parameters:
//  name: PolicyName, type: string
//  name: VersionId, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) SetDefaultPolicyVersion(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "SetDefaultPolicyVersion")
	args.Scheme = "https"
	if v, ok := optional["PolicyName"]; ok {
		if PolicyName, ok := v.(string); ok {
			args.Query.Set("PolicyName", PolicyName)
		} else {
			return nil, errors.New("PolicyName must be string")
		}
	}
	if v, ok := optional["VersionId"]; ok {
		if VersionId, ok := v.(string); ok {
			args.Query.Set("VersionId", VersionId)
		} else {
			return nil, errors.New("VersionId must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// SetPasswordPolicy version 2015-05-01
//
// optional parameters:
//  name: MinimumPasswordLength, type: int
//  name: RequireLowercaseCharacters, type: bool
//  name: RequireNumbers, type: bool
//  name: RequireSymbols, type: bool
//  name: RequireUppercaseCharacters, type: bool
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) SetPasswordPolicy(optional openapi.M) (*SetPasswordPolicyResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "SetPasswordPolicy")
	args.Scheme = "https"
	if v, ok := optional["MinimumPasswordLength"]; ok {
		if MinimumPasswordLength, ok := v.(int); ok {
			args.Query.Set("MinimumPasswordLength", fmt.Sprint(MinimumPasswordLength))
		} else {
			return nil, errors.New("MinimumPasswordLength must be int")
		}
	}
	if v, ok := optional["RequireLowercaseCharacters"]; ok {
		if RequireLowercaseCharacters, ok := v.(bool); ok {
			args.Query.Set("RequireLowercaseCharacters", fmt.Sprint(RequireLowercaseCharacters))
		} else {
			return nil, errors.New("RequireLowercaseCharacters must be bool")
		}
	}
	if v, ok := optional["RequireNumbers"]; ok {
		if RequireNumbers, ok := v.(bool); ok {
			args.Query.Set("RequireNumbers", fmt.Sprint(RequireNumbers))
		} else {
			return nil, errors.New("RequireNumbers must be bool")
		}
	}
	if v, ok := optional["RequireSymbols"]; ok {
		if RequireSymbols, ok := v.(bool); ok {
			args.Query.Set("RequireSymbols", fmt.Sprint(RequireSymbols))
		} else {
			return nil, errors.New("RequireSymbols must be bool")
		}
	}
	if v, ok := optional["RequireUppercaseCharacters"]; ok {
		if RequireUppercaseCharacters, ok := v.(bool); ok {
			args.Query.Set("RequireUppercaseCharacters", fmt.Sprint(RequireUppercaseCharacters))
		} else {
			return nil, errors.New("RequireUppercaseCharacters must be bool")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(SetPasswordPolicyResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// SetPasswordPolicyResponse represents the response of the api SetPasswordPolicy.
type SetPasswordPolicyResponse struct {
	PasswordPolicy struct {
		MinimumPasswordLength      int
		RequireLowercaseCharacters bool
		RequireNumbers             bool
		RequireSymbols             bool
		RequireUppercaseCharacters bool
	}
}

// SetSecurityPreference version 2015-05-01
//
// optional parameters:
//  name: EnableSaveMFATicket, type: bool
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) SetSecurityPreference(optional openapi.M) (*SetSecurityPreferenceResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "SetSecurityPreference")
	args.Scheme = "https"
	if v, ok := optional["EnableSaveMFATicket"]; ok {
		if EnableSaveMFATicket, ok := v.(bool); ok {
			args.Query.Set("EnableSaveMFATicket", fmt.Sprint(EnableSaveMFATicket))
		} else {
			return nil, errors.New("EnableSaveMFATicket must be bool")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(SetSecurityPreferenceResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// SetSecurityPreferenceResponse represents the response of the api SetSecurityPreference.
type SetSecurityPreferenceResponse struct {
	SecurityPreference struct {
		LoginProfilePreference struct {
			EnableSaveMFATicket bool
		}
	}
}

// UnbindMFADevice version 2015-05-01
//
// optional parameters:
//  name: UserName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) UnbindMFADevice(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "UnbindMFADevice")
	args.Scheme = "https"
	if v, ok := optional["UserName"]; ok {
		if UserName, ok := v.(string); ok {
			args.Query.Set("UserName", UserName)
		} else {
			return nil, errors.New("UserName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// UpdateAccessKey version 2015-05-01
//
// optional parameters:
//  name: Status, type: string
//  name: UserAccessKeyId, type: string
//  name: UserName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) UpdateAccessKey(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "UpdateAccessKey")
	args.Scheme = "https"
	if v, ok := optional["Status"]; ok {
		if Status, ok := v.(string); ok {
			args.Query.Set("Status", Status)
		} else {
			return nil, errors.New("Status must be string")
		}
	}
	if v, ok := optional["UserAccessKeyId"]; ok {
		if UserAccessKeyId, ok := v.(string); ok {
			args.Query.Set("UserAccessKeyId", UserAccessKeyId)
		} else {
			return nil, errors.New("UserAccessKeyId must be string")
		}
	}
	if v, ok := optional["UserName"]; ok {
		if UserName, ok := v.(string); ok {
			args.Query.Set("UserName", UserName)
		} else {
			return nil, errors.New("UserName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// UpdateGroup version 2015-05-01
//
// optional parameters:
//  name: GroupName, type: string
//  name: NewComments, type: string
//  name: NewGroupName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) UpdateGroup(optional openapi.M) (*UpdateGroupResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "UpdateGroup")
	args.Scheme = "https"
	if v, ok := optional["GroupName"]; ok {
		if GroupName, ok := v.(string); ok {
			args.Query.Set("GroupName", GroupName)
		} else {
			return nil, errors.New("GroupName must be string")
		}
	}
	if v, ok := optional["NewComments"]; ok {
		if NewComments, ok := v.(string); ok {
			args.Query.Set("NewComments", NewComments)
		} else {
			return nil, errors.New("NewComments must be string")
		}
	}
	if v, ok := optional["NewGroupName"]; ok {
		if NewGroupName, ok := v.(string); ok {
			args.Query.Set("NewGroupName", NewGroupName)
		} else {
			return nil, errors.New("NewGroupName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(UpdateGroupResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// UpdateGroupResponse represents the response of the api UpdateGroup.
type UpdateGroupResponse struct {
	Group struct {
		Comments   string
		CreateDate string
		GroupName  string
		UpdateDate string
	}
}

// UpdateLoginProfile version 2015-05-01
//
// optional parameters:
//  name: MFABindRequired, type: bool
//  name: Password, type: string
//  name: PasswordResetRequired, type: bool
//  name: UserName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) UpdateLoginProfile(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "UpdateLoginProfile")
	args.Scheme = "https"
	if v, ok := optional["MFABindRequired"]; ok {
		if MFABindRequired, ok := v.(bool); ok {
			args.Query.Set("MFABindRequired", fmt.Sprint(MFABindRequired))
		} else {
			return nil, errors.New("MFABindRequired must be bool")
		}
	}
	if v, ok := optional["Password"]; ok {
		if Password, ok := v.(string); ok {
			args.Query.Set("Password", Password)
		} else {
			return nil, errors.New("Password must be string")
		}
	}
	if v, ok := optional["PasswordResetRequired"]; ok {
		if PasswordResetRequired, ok := v.(bool); ok {
			args.Query.Set("PasswordResetRequired", fmt.Sprint(PasswordResetRequired))
		} else {
			return nil, errors.New("PasswordResetRequired must be bool")
		}
	}
	if v, ok := optional["UserName"]; ok {
		if UserName, ok := v.(string); ok {
			args.Query.Set("UserName", UserName)
		} else {
			return nil, errors.New("UserName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// UpdateRole version 2015-05-01
//
// optional parameters:
//  name: NewAssumeRolePolicyDocument, type: string
//  name: RoleName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) UpdateRole(optional openapi.M) (*UpdateRoleResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "UpdateRole")
	args.Scheme = "https"
	if v, ok := optional["NewAssumeRolePolicyDocument"]; ok {
		if NewAssumeRolePolicyDocument, ok := v.(string); ok {
			args.Query.Set("NewAssumeRolePolicyDocument", NewAssumeRolePolicyDocument)
		} else {
			return nil, errors.New("NewAssumeRolePolicyDocument must be string")
		}
	}
	if v, ok := optional["RoleName"]; ok {
		if RoleName, ok := v.(string); ok {
			args.Query.Set("RoleName", RoleName)
		} else {
			return nil, errors.New("RoleName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(UpdateRoleResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// UpdateRoleResponse represents the response of the api UpdateRole.
type UpdateRoleResponse struct {
	Role struct {
		Arn                      string
		AssumeRolePolicyDocument string
		CreateDate               string
		Description              string
		RoleId                   string
		RoleName                 string
		UpdateDate               string
	}
}

// UpdateUser version 2015-05-01
//
// optional parameters:
//  name: NewComments, type: string
//  name: NewDisplayName, type: string
//  name: NewEmail, type: string
//  name: NewMobilePhone, type: string
//  name: NewUserName, type: string
//  name: UserName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) UpdateUser(optional openapi.M) (*UpdateUserResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "UpdateUser")
	args.Scheme = "https"
	if v, ok := optional["NewComments"]; ok {
		if NewComments, ok := v.(string); ok {
			args.Query.Set("NewComments", NewComments)
		} else {
			return nil, errors.New("NewComments must be string")
		}
	}
	if v, ok := optional["NewDisplayName"]; ok {
		if NewDisplayName, ok := v.(string); ok {
			args.Query.Set("NewDisplayName", NewDisplayName)
		} else {
			return nil, errors.New("NewDisplayName must be string")
		}
	}
	if v, ok := optional["NewEmail"]; ok {
		if NewEmail, ok := v.(string); ok {
			args.Query.Set("NewEmail", NewEmail)
		} else {
			return nil, errors.New("NewEmail must be string")
		}
	}
	if v, ok := optional["NewMobilePhone"]; ok {
		if NewMobilePhone, ok := v.(string); ok {
			args.Query.Set("NewMobilePhone", NewMobilePhone)
		} else {
			return nil, errors.New("NewMobilePhone must be string")
		}
	}
	if v, ok := optional["NewUserName"]; ok {
		if NewUserName, ok := v.(string); ok {
			args.Query.Set("NewUserName", NewUserName)
		} else {
			return nil, errors.New("NewUserName must be string")
		}
	}
	if v, ok := optional["UserName"]; ok {
		if UserName, ok := v.(string); ok {
			args.Query.Set("UserName", UserName)
		} else {
			return nil, errors.New("UserName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(UpdateUserResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// UpdateUserResponse represents the response of the api UpdateUser.
type UpdateUserResponse struct {
	User struct {
		Comments    string
		CreateDate  string
		DisplayName string
		Email       string
		MobilePhone string
		UpdateDate  string
		UserId      string
		UserName    string
	}
}
