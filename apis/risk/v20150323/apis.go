// Copyright 2015 Chen Xianren. All rights reserved.
// Code generated by openapi-meta; DO NOT EDIT

package risk // import "github.com/cxr29/aliyun-openapi-go-sdk/apis/risk/v20150323"

import (
	"errors"
	"fmt"

	"github.com/cxr29/aliyun-openapi-go-sdk"
)

var (
	_ = errors.New("")
	_ = fmt.Sprint("")
)

type API struct {
	openapi.Service
}

func New(accessKeyId, accessKeySecret string) API {
	return API{openapi.NewService(accessKeyId, accessKeySecret)}
}

func NewParams() openapi.Params {
	args := openapi.NewParams()
	args.Product = Product
	args.Style = Style
	args.Version = Version
	return args
}

const (
	Product = "Risk"
	Style   = "RPC"
	Version = "2015-03-23"
)

// FindRisk version 2015-03-23
//
// required parameters:
//  name: CodeType, type: string
//  name: IdType, type: string
//  name: MteeCode, type: string
//  name: UserId, type: string
//
// optional parameters:
//  name: Collina, type: string
//  name: Email, type: string
//  name: Ip, type: string
//  name: Phone, type: string
//  name: UmidToken, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) FindRisk(CodeType, IdType, MteeCode, UserId string, optional openapi.M) (*FindRiskResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "FindRisk")
	args.Query.Set("CodeType", CodeType)
	args.Query.Set("IdType", IdType)
	args.Query.Set("MteeCode", MteeCode)
	args.Query.Set("UserId", UserId)
	args.Scheme = "http"
	if v, ok := optional["Collina"]; ok {
		if Collina, ok := v.(string); ok {
			args.Query.Set("Collina", Collina)
		} else {
			return nil, errors.New("Collina must be string")
		}
	}
	if v, ok := optional["Email"]; ok {
		if Email, ok := v.(string); ok {
			args.Query.Set("Email", Email)
		} else {
			return nil, errors.New("Email must be string")
		}
	}
	if v, ok := optional["Ip"]; ok {
		if Ip, ok := v.(string); ok {
			args.Query.Set("Ip", Ip)
		} else {
			return nil, errors.New("Ip must be string")
		}
	}
	if v, ok := optional["Phone"]; ok {
		if Phone, ok := v.(string); ok {
			args.Query.Set("Phone", Phone)
		} else {
			return nil, errors.New("Phone must be string")
		}
	}
	if v, ok := optional["UmidToken"]; ok {
		if UmidToken, ok := v.(string); ok {
			args.Query.Set("UmidToken", UmidToken)
		} else {
			return nil, errors.New("UmidToken must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(FindRiskResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// FindRiskResponse represents the response of the api FindRisk.
type FindRiskResponse struct {
	Code string
	Data struct {
		Action  string
		Message string
		NoRisk  bool
		Tag     string
	}
}

// SendVerifyCode version 2015-03-23
//
// required parameters:
//  name: ChannelType, type: string
//  name: CodeType, type: string
//  name: IdType, type: string
//  name: MteeCode, type: string
//  name: UserId, type: string
//
// optional parameters:
//  name: BizId, type: string
//  name: EventId, type: string
//  name: MessageReiver, type: string
//  name: RequestId, type: string
//  name: TimeInterval, type: int
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) SendVerifyCode(ChannelType, CodeType, IdType, MteeCode, UserId string, optional openapi.M) (*SendVerifyCodeResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "SendVerifyCode")
	args.Query.Set("ChannelType", ChannelType)
	args.Query.Set("CodeType", CodeType)
	args.Query.Set("IdType", IdType)
	args.Query.Set("MteeCode", MteeCode)
	args.Query.Set("UserId", UserId)
	args.Scheme = "http"
	if v, ok := optional["BizId"]; ok {
		if BizId, ok := v.(string); ok {
			args.Query.Set("BizId", BizId)
		} else {
			return nil, errors.New("BizId must be string")
		}
	}
	if v, ok := optional["EventId"]; ok {
		if EventId, ok := v.(string); ok {
			args.Query.Set("EventId", EventId)
		} else {
			return nil, errors.New("EventId must be string")
		}
	}
	if v, ok := optional["MessageReiver"]; ok {
		if MessageReiver, ok := v.(string); ok {
			args.Query.Set("MessageReiver", MessageReiver)
		} else {
			return nil, errors.New("MessageReiver must be string")
		}
	}
	if v, ok := optional["RequestId"]; ok {
		if RequestId, ok := v.(string); ok {
			args.Query.Set("RequestId", RequestId)
		} else {
			return nil, errors.New("RequestId must be string")
		}
	}
	if v, ok := optional["TimeInterval"]; ok {
		if TimeInterval, ok := v.(int); ok {
			args.Query.Set("TimeInterval", fmt.Sprint(TimeInterval))
		} else {
			return nil, errors.New("TimeInterval must be int")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(SendVerifyCodeResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// SendVerifyCodeResponse represents the response of the api SendVerifyCode.
type SendVerifyCodeResponse struct {
	Code string
}

// ValidateVerifyCode version 2015-03-23
//
// required parameters:
//  name: ChannelType, type: string
//  name: CodeType, type: string
//  name: IdType, type: string
//  name: MteeCode, type: string
//  name: UserId, type: string
//  name: VerifyCode, type: string
//
// optional parameters:
//  name: Collina, type: string
//  name: Ip, type: string
//  name: RequestId, type: string
//  name: UmidToken, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
func (api API) ValidateVerifyCode(ChannelType, CodeType, IdType, MteeCode, UserId, VerifyCode string, optional openapi.M) (*ValidateVerifyCodeResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ValidateVerifyCode")
	args.Query.Set("ChannelType", ChannelType)
	args.Query.Set("CodeType", CodeType)
	args.Query.Set("IdType", IdType)
	args.Query.Set("MteeCode", MteeCode)
	args.Query.Set("UserId", UserId)
	args.Query.Set("VerifyCode", VerifyCode)
	args.Scheme = "http"
	if v, ok := optional["Collina"]; ok {
		if Collina, ok := v.(string); ok {
			args.Query.Set("Collina", Collina)
		} else {
			return nil, errors.New("Collina must be string")
		}
	}
	if v, ok := optional["Ip"]; ok {
		if Ip, ok := v.(string); ok {
			args.Query.Set("Ip", Ip)
		} else {
			return nil, errors.New("Ip must be string")
		}
	}
	if v, ok := optional["RequestId"]; ok {
		if RequestId, ok := v.(string); ok {
			args.Query.Set("RequestId", RequestId)
		} else {
			return nil, errors.New("RequestId must be string")
		}
	}
	if v, ok := optional["UmidToken"]; ok {
		if UmidToken, ok := v.(string); ok {
			args.Query.Set("UmidToken", UmidToken)
		} else {
			return nil, errors.New("UmidToken must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ValidateVerifyCodeResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ValidateVerifyCodeResponse represents the response of the api ValidateVerifyCode.
type ValidateVerifyCodeResponse struct {
	Code string
}
