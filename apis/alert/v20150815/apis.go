// Copyright 2015 Chen Xianren. All rights reserved.
// Code generated by openapi-meta; DO NOT EDIT

package alert

import (
	"errors"
	"fmt"

	"git.oschina.net/cxr29/aliyun-openapi-go-sdk"
)

var (
	_ = errors.New("")
	_ = fmt.Sprint("")
	_ = make(openapi.M)
)

type API struct {
	openapi.Service
}

func New(accessKeyId, accessKeySecret string) API {
	return API{openapi.NewService(accessKeyId, accessKeySecret)}
}

func NewParams() openapi.Params {
	args := openapi.NewParams()
	args.Product = Product
	args.Style = Style
	args.Version = Version
	return args
}

const (
	Product = "Alert"
	Style   = "ROA"
	Version = "2015-08-15"
)

// BatchQueryProject version 2015-08-15
//
// optional parameters:
//  name: Names, type: string
//  name: Page, type: int
//  name: PageSize, type: int
//  name: _region, type: string
func (api API) BatchQueryProject(optional openapi.M) (*BatchQueryProjectResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "BatchQueryProject")
	args.Method = "GET"
	args.Pattern = `/projects/batchQuery`
	args.Scheme = "http"
	if v, ok := optional["Names"]; ok {
		if Names, ok := v.(string); ok {
			args.Query.Set("Names", Names)
		} else {
			return nil, errors.New("Names must be string")
		}
	}
	if v, ok := optional["Page"]; ok {
		if Page, ok := v.(int); ok {
			args.Query.Set("Page", fmt.Sprint(Page))
		} else {
			return nil, errors.New("Page must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(BatchQueryProjectResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// BatchQueryProjectResponse represents the response of the api BatchQueryProject.
type BatchQueryProjectResponse struct {
	Code       string `json:"code" xml:"code"`
	Datapoints string `json:"datapoints" xml:"datapoints"`
	Message    string `json:"message" xml:"message"`
	Success    string `json:"success" xml:"success"`
	Total      string `json:"total" xml:"total"`
	TraceId    string `json:"traceId" xml:"traceId"`
}

// CreateAlert version 2015-08-15
//
// required parameters:
//  name: ProjectName, type: string
//
// optional parameters:
//  name: Alert, type: string
//  name: _region, type: string
func (api API) CreateAlert(ProjectName string, optional openapi.M) (*CreateAlertResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateAlert")
	args.Method = "POST"
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/alerts`
	args.Scheme = "http"
	if v, ok := optional["Alert"]; ok {
		if Alert, ok := v.(string); ok {
			args.Body.Set("Alert", Alert)
		} else {
			return nil, errors.New("Alert must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(CreateAlertResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateAlertResponse represents the response of the api CreateAlert.
type CreateAlertResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Result  string `json:"result" xml:"result"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// CreateContact version 2015-08-15
//
// required parameters:
//  name: ProjectName, type: string
//
// optional parameters:
//  name: Contact, type: string
//  name: _region, type: string
func (api API) CreateContact(ProjectName string, optional openapi.M) (*CreateContactResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateContact")
	args.Method = "POST"
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/contacts`
	args.Scheme = "http"
	if v, ok := optional["Contact"]; ok {
		if Contact, ok := v.(string); ok {
			args.Body.Set("Contact", Contact)
		} else {
			return nil, errors.New("Contact must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(CreateContactResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateContactResponse represents the response of the api CreateContact.
type CreateContactResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Result  string `json:"result" xml:"result"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// CreateContactGroup version 2015-08-15
//
// required parameters:
//  name: ProjectName, type: string
//
// optional parameters:
//  name: ContactGroup, type: string
//  name: _region, type: string
func (api API) CreateContactGroup(ProjectName string, optional openapi.M) (*CreateContactGroupResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateContactGroup")
	args.Method = "POST"
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/groups`
	args.Scheme = "http"
	if v, ok := optional["ContactGroup"]; ok {
		if ContactGroup, ok := v.(string); ok {
			args.Body.Set("ContactGroup", ContactGroup)
		} else {
			return nil, errors.New("ContactGroup must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(CreateContactGroupResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateContactGroupResponse represents the response of the api CreateContactGroup.
type CreateContactGroupResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Result  string `json:"result" xml:"result"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// CreateDBMetric version 2015-08-15
//
// required parameters:
//  name: ProjectName, type: string
//
// optional parameters:
//  name: Metric, type: string
//  name: _region, type: string
func (api API) CreateDBMetric(ProjectName string, optional openapi.M) (*CreateDBMetricResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateDBMetric")
	args.Method = "POST"
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/dbMetrics`
	args.Scheme = "http"
	if v, ok := optional["Metric"]; ok {
		if Metric, ok := v.(string); ok {
			args.Body.Set("Metric", Metric)
		} else {
			return nil, errors.New("Metric must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(CreateDBMetricResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateDBMetricResponse represents the response of the api CreateDBMetric.
type CreateDBMetricResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Result  string `json:"result" xml:"result"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// CreateDBSource version 2015-08-15
//
// required parameters:
//  name: ProjectName, type: string
//
// optional parameters:
//  name: Source, type: string
//  name: _region, type: string
func (api API) CreateDBSource(ProjectName string, optional openapi.M) (*CreateDBSourceResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateDBSource")
	args.Method = "POST"
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/sources`
	args.Scheme = "http"
	if v, ok := optional["Source"]; ok {
		if Source, ok := v.(string); ok {
			args.Body.Set("Source", Source)
		} else {
			return nil, errors.New("Source must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(CreateDBSourceResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateDBSourceResponse represents the response of the api CreateDBSource.
type CreateDBSourceResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Result  string `json:"result" xml:"result"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// CreateDimensions version 2015-08-15
//
// required parameters:
//  name: AlertName, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: Dimensions, type: string
//  name: _region, type: string
func (api API) CreateDimensions(AlertName, ProjectName string, optional openapi.M) (*CreateDimensionsResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateDimensions")
	args.Method = "POST"
	args.Path["AlertName"] = AlertName
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/alerts/[AlertName]/dimensions`
	args.Scheme = "http"
	if v, ok := optional["Dimensions"]; ok {
		if Dimensions, ok := v.(string); ok {
			args.Body.Set("Dimensions", Dimensions)
		} else {
			return nil, errors.New("Dimensions must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(CreateDimensionsResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateDimensionsResponse represents the response of the api CreateDimensions.
type CreateDimensionsResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Result  string `json:"result" xml:"result"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// CreateLevelChannel version 2015-08-15
//
// required parameters:
//  name: ProjectName, type: string
//
// optional parameters:
//  name: LevelChannelSetting, type: string
//  name: _region, type: string
func (api API) CreateLevelChannel(ProjectName string, optional openapi.M) (*CreateLevelChannelResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateLevelChannel")
	args.Method = "POST"
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/level_channels`
	args.Scheme = "http"
	if v, ok := optional["LevelChannelSetting"]; ok {
		if LevelChannelSetting, ok := v.(string); ok {
			args.Body.Set("LevelChannelSetting", LevelChannelSetting)
		} else {
			return nil, errors.New("LevelChannelSetting must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(CreateLevelChannelResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateLevelChannelResponse represents the response of the api CreateLevelChannel.
type CreateLevelChannelResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Result  string `json:"result" xml:"result"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// CreateLogHubMetric version 2015-08-15
//
// required parameters:
//  name: ProjectName, type: string
//
// optional parameters:
//  name: Metric, type: string
//  name: _region, type: string
func (api API) CreateLogHubMetric(ProjectName string, optional openapi.M) (*CreateLogHubMetricResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateLogHubMetric")
	args.Method = "POST"
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/logHubMetrics`
	args.Scheme = "http"
	if v, ok := optional["Metric"]; ok {
		if Metric, ok := v.(string); ok {
			args.Body.Set("Metric", Metric)
		} else {
			return nil, errors.New("Metric must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(CreateLogHubMetricResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateLogHubMetricResponse represents the response of the api CreateLogHubMetric.
type CreateLogHubMetricResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Result  string `json:"result" xml:"result"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// CreateProject version 2015-08-15
//
// optional parameters:
//  name: Project, type: string
//  name: _region, type: string
func (api API) CreateProject(optional openapi.M) (*CreateProjectResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateProject")
	args.Method = "POST"
	args.Pattern = `/projects`
	args.Scheme = "http"
	if v, ok := optional["Project"]; ok {
		if Project, ok := v.(string); ok {
			args.Body.Set("Project", Project)
		} else {
			return nil, errors.New("Project must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(CreateProjectResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateProjectResponse represents the response of the api CreateProject.
type CreateProjectResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Result  string `json:"result" xml:"result"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// DeleteAlert version 2015-08-15
//
// required parameters:
//  name: AlertName, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: _region, type: string
func (api API) DeleteAlert(AlertName, ProjectName string, optional openapi.M) (*DeleteAlertResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteAlert")
	args.Method = "DELETE"
	args.Path["AlertName"] = AlertName
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/alerts/[AlertName]`
	args.Scheme = "http"
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(DeleteAlertResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteAlertResponse represents the response of the api DeleteAlert.
type DeleteAlertResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// DeleteContact version 2015-08-15
//
// required parameters:
//  name: ContactName, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: _region, type: string
func (api API) DeleteContact(ContactName, ProjectName string, optional openapi.M) (*DeleteContactResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteContact")
	args.Method = "DELETE"
	args.Path["ContactName"] = ContactName
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/contacts/[ContactName]`
	args.Scheme = "http"
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(DeleteContactResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteContactResponse represents the response of the api DeleteContact.
type DeleteContactResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// DeleteContactGroup version 2015-08-15
//
// required parameters:
//  name: GroupName, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: _region, type: string
func (api API) DeleteContactGroup(GroupName, ProjectName string, optional openapi.M) (*DeleteContactGroupResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteContactGroup")
	args.Method = "DELETE"
	args.Path["GroupName"] = GroupName
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/groups/[GroupName]`
	args.Scheme = "http"
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(DeleteContactGroupResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteContactGroupResponse represents the response of the api DeleteContactGroup.
type DeleteContactGroupResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// DeleteDBMetric version 2015-08-15
//
// required parameters:
//  name: MetricName, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: _region, type: string
func (api API) DeleteDBMetric(MetricName, ProjectName string, optional openapi.M) (*DeleteDBMetricResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteDBMetric")
	args.Method = "DELETE"
	args.Path["MetricName"] = MetricName
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/dbMetrics/[MetricName]`
	args.Scheme = "http"
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(DeleteDBMetricResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteDBMetricResponse represents the response of the api DeleteDBMetric.
type DeleteDBMetricResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// DeleteDBSource version 2015-08-15
//
// required parameters:
//  name: ProjectName, type: string
//  name: SourceName, type: string
//
// optional parameters:
//  name: _region, type: string
func (api API) DeleteDBSource(ProjectName, SourceName string, optional openapi.M) (*DeleteDBSourceResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteDBSource")
	args.Method = "DELETE"
	args.Path["ProjectName"] = ProjectName
	args.Path["SourceName"] = SourceName
	args.Pattern = `/projects/[ProjectName]/sources/[SourceName]`
	args.Scheme = "http"
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(DeleteDBSourceResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteDBSourceResponse represents the response of the api DeleteDBSource.
type DeleteDBSourceResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// DeleteDimensions version 2015-08-15
//
// required parameters:
//  name: AlertName, type: string
//  name: DimensionsId, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: _region, type: string
func (api API) DeleteDimensions(AlertName, DimensionsId, ProjectName string, optional openapi.M) (*DeleteDimensionsResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteDimensions")
	args.Method = "DELETE"
	args.Path["AlertName"] = AlertName
	args.Path["DimensionsId"] = DimensionsId
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/alerts/[AlertName]/dimensions/[DimensionsId]`
	args.Scheme = "http"
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(DeleteDimensionsResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteDimensionsResponse represents the response of the api DeleteDimensions.
type DeleteDimensionsResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// DeleteLevelChannel version 2015-08-15
//
// required parameters:
//  name: Level, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: _region, type: string
func (api API) DeleteLevelChannel(Level, ProjectName string, optional openapi.M) (*DeleteLevelChannelResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteLevelChannel")
	args.Method = "DELETE"
	args.Path["Level"] = Level
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/level_channels/[Level]`
	args.Scheme = "http"
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(DeleteLevelChannelResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteLevelChannelResponse represents the response of the api DeleteLevelChannel.
type DeleteLevelChannelResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// DeleteLogHubMetric version 2015-08-15
//
// required parameters:
//  name: MetricName, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: _region, type: string
func (api API) DeleteLogHubMetric(MetricName, ProjectName string, optional openapi.M) (*DeleteLogHubMetricResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteLogHubMetric")
	args.Method = "DELETE"
	args.Path["MetricName"] = MetricName
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/logHubMetrics/[MetricName]`
	args.Scheme = "http"
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(DeleteLogHubMetricResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteLogHubMetricResponse represents the response of the api DeleteLogHubMetric.
type DeleteLogHubMetricResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// DeleteProject version 2015-08-15
//
// optional parameters:
//  name: ProjectName, type: string
//  name: _region, type: string
func (api API) DeleteProject(optional openapi.M) (*DeleteProjectResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteProject")
	args.Method = "DELETE"
	args.Pattern = `/projects/[ProjectName]`
	args.Scheme = "http"
	if v, ok := optional["ProjectName"]; ok {
		if ProjectName, ok := v.(string); ok {
			args.Path["ProjectName"] = ProjectName
		} else {
			return nil, errors.New("ProjectName must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(DeleteProjectResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteProjectResponse represents the response of the api DeleteProject.
type DeleteProjectResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// DisableAlert version 2015-08-15
//
// required parameters:
//  name: AlertName, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: _region, type: string
func (api API) DisableAlert(AlertName, ProjectName string, optional openapi.M) (*DisableAlertResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DisableAlert")
	args.Method = "PUT"
	args.Path["AlertName"] = AlertName
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/alerts/[AlertName]/disable`
	args.Scheme = "http"
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(DisableAlertResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DisableAlertResponse represents the response of the api DisableAlert.
type DisableAlertResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// EnableAlert version 2015-08-15
//
// required parameters:
//  name: AlertName, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: _region, type: string
func (api API) EnableAlert(AlertName, ProjectName string, optional openapi.M) (*EnableAlertResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "EnableAlert")
	args.Method = "PUT"
	args.Path["AlertName"] = AlertName
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/alerts/[AlertName]/enable`
	args.Scheme = "http"
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(EnableAlertResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// EnableAlertResponse represents the response of the api EnableAlert.
type EnableAlertResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// GetAlert version 2015-08-15
//
// required parameters:
//  name: AlertName, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: _region, type: string
func (api API) GetAlert(AlertName, ProjectName string, optional openapi.M) (*GetAlertResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetAlert")
	args.Method = "GET"
	args.Path["AlertName"] = AlertName
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/alerts/[AlertName]`
	args.Scheme = "http"
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GetAlertResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetAlertResponse represents the response of the api GetAlert.
type GetAlertResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Result  string `json:"result" xml:"result"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// GetContact version 2015-08-15
//
// required parameters:
//  name: ContactName, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: _region, type: string
func (api API) GetContact(ContactName, ProjectName string, optional openapi.M) (*GetContactResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetContact")
	args.Method = "GET"
	args.Path["ContactName"] = ContactName
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/contacts/[ContactName]`
	args.Scheme = "http"
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GetContactResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetContactResponse represents the response of the api GetContact.
type GetContactResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Result  string `json:"result" xml:"result"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// GetContactGroup version 2015-08-15
//
// required parameters:
//  name: GroupName, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: _region, type: string
func (api API) GetContactGroup(GroupName, ProjectName string, optional openapi.M) (*GetContactGroupResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetContactGroup")
	args.Method = "GET"
	args.Path["GroupName"] = GroupName
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/groups/[GroupName]`
	args.Scheme = "http"
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GetContactGroupResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetContactGroupResponse represents the response of the api GetContactGroup.
type GetContactGroupResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Result  string `json:"result" xml:"result"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// GetDBMetric version 2015-08-15
//
// required parameters:
//  name: MetricName, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: _region, type: string
func (api API) GetDBMetric(MetricName, ProjectName string, optional openapi.M) (*GetDBMetricResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetDBMetric")
	args.Method = "GET"
	args.Path["MetricName"] = MetricName
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/dbMetrics/[MetricName]`
	args.Scheme = "http"
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GetDBMetricResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetDBMetricResponse represents the response of the api GetDBMetric.
type GetDBMetricResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Result  string `json:"result" xml:"result"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// GetDBSource version 2015-08-15
//
// required parameters:
//  name: ProjectName, type: string
//  name: SourceName, type: string
//
// optional parameters:
//  name: _region, type: string
func (api API) GetDBSource(ProjectName, SourceName string, optional openapi.M) (*GetDBSourceResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetDBSource")
	args.Method = "GET"
	args.Path["ProjectName"] = ProjectName
	args.Path["SourceName"] = SourceName
	args.Pattern = `/projects/[ProjectName]/sources/[SourceName]`
	args.Scheme = "http"
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GetDBSourceResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetDBSourceResponse represents the response of the api GetDBSource.
type GetDBSourceResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Result  string `json:"result" xml:"result"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// GetDimensions version 2015-08-15
//
// required parameters:
//  name: AlertName, type: string
//  name: DimensionsId, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: _region, type: string
func (api API) GetDimensions(AlertName, DimensionsId, ProjectName string, optional openapi.M) (*GetDimensionsResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetDimensions")
	args.Method = "GET"
	args.Path["AlertName"] = AlertName
	args.Path["DimensionsId"] = DimensionsId
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/alerts/[AlertName]/dimensions/[DimensionsId]`
	args.Scheme = "http"
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GetDimensionsResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetDimensionsResponse represents the response of the api GetDimensions.
type GetDimensionsResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Result  string `json:"result" xml:"result"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// GetLevelChannel version 2015-08-15
//
// required parameters:
//  name: Level, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: _region, type: string
func (api API) GetLevelChannel(Level, ProjectName string, optional openapi.M) (*GetLevelChannelResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetLevelChannel")
	args.Method = "GET"
	args.Path["Level"] = Level
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/level_channels/[Level]`
	args.Scheme = "http"
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GetLevelChannelResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetLevelChannelResponse represents the response of the api GetLevelChannel.
type GetLevelChannelResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Result  string `json:"result" xml:"result"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// GetLogHubMetric version 2015-08-15
//
// required parameters:
//  name: MetricName, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: _region, type: string
func (api API) GetLogHubMetric(MetricName, ProjectName string, optional openapi.M) (*GetLogHubMetricResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetLogHubMetric")
	args.Method = "GET"
	args.Path["MetricName"] = MetricName
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/logHubMetrics/[MetricName]`
	args.Scheme = "http"
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GetLogHubMetricResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetLogHubMetricResponse represents the response of the api GetLogHubMetric.
type GetLogHubMetricResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Result  string `json:"result" xml:"result"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// GetProject version 2015-08-15
//
// optional parameters:
//  name: ProjectName, type: string
//  name: _region, type: string
func (api API) GetProject(optional openapi.M) (*GetProjectResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetProject")
	args.Method = "GET"
	args.Pattern = `/projects/[ProjectName]`
	args.Scheme = "http"
	if v, ok := optional["ProjectName"]; ok {
		if ProjectName, ok := v.(string); ok {
			args.Path["ProjectName"] = ProjectName
		} else {
			return nil, errors.New("ProjectName must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GetProjectResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetProjectResponse represents the response of the api GetProject.
type GetProjectResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Result  string `json:"result" xml:"result"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// GrantProjectOwner version 2015-08-15
//
// optional parameters:
//  name: Owners, type: string
//  name: ProjectName, type: string
//  name: _region, type: string
func (api API) GrantProjectOwner(optional openapi.M) (*GrantProjectOwnerResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GrantProjectOwner")
	args.Method = "GET"
	args.Pattern = `/projects/grantOwner`
	args.Scheme = "http"
	if v, ok := optional["Owners"]; ok {
		if Owners, ok := v.(string); ok {
			args.Query.Set("Owners", Owners)
		} else {
			return nil, errors.New("Owners must be string")
		}
	}
	if v, ok := optional["ProjectName"]; ok {
		if ProjectName, ok := v.(string); ok {
			args.Query.Set("ProjectName", ProjectName)
		} else {
			return nil, errors.New("ProjectName must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(GrantProjectOwnerResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GrantProjectOwnerResponse represents the response of the api GrantProjectOwner.
type GrantProjectOwnerResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// ListAlert version 2015-08-15
//
// required parameters:
//  name: ProjectName, type: string
//
// optional parameters:
//  name: AlertName, type: string
//  name: Page, type: int
//  name: PageSize, type: int
//  name: _region, type: string
func (api API) ListAlert(ProjectName string, optional openapi.M) (*ListAlertResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListAlert")
	args.Method = "GET"
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/alerts`
	args.Scheme = "http"
	if v, ok := optional["AlertName"]; ok {
		if AlertName, ok := v.(string); ok {
			args.Query.Set("AlertName", AlertName)
		} else {
			return nil, errors.New("AlertName must be string")
		}
	}
	if v, ok := optional["Page"]; ok {
		if Page, ok := v.(int); ok {
			args.Query.Set("Page", fmt.Sprint(Page))
		} else {
			return nil, errors.New("Page must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListAlertResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListAlertResponse represents the response of the api ListAlert.
type ListAlertResponse struct {
	Code       string `json:"code" xml:"code"`
	Datapoints string `json:"datapoints" xml:"datapoints"`
	Message    string `json:"message" xml:"message"`
	Success    string `json:"success" xml:"success"`
	Total      string `json:"total" xml:"total"`
	TraceId    string `json:"traceId" xml:"traceId"`
}

// ListAlertState version 2015-08-15
//
// required parameters:
//  name: ProjectName, type: string
//
// optional parameters:
//  name: AlertName, type: string
//  name: Dimensions, type: string
//  name: EndTime, type: string
//  name: Page, type: int
//  name: PageSize, type: int
//  name: StartTime, type: string
//  name: _region, type: string
func (api API) ListAlertState(ProjectName string, optional openapi.M) (*ListAlertStateResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListAlertState")
	args.Method = "GET"
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/alerts_state`
	args.Scheme = "http"
	if v, ok := optional["AlertName"]; ok {
		if AlertName, ok := v.(string); ok {
			args.Query.Set("AlertName", AlertName)
		} else {
			return nil, errors.New("AlertName must be string")
		}
	}
	if v, ok := optional["Dimensions"]; ok {
		if Dimensions, ok := v.(string); ok {
			args.Query.Set("Dimensions", Dimensions)
		} else {
			return nil, errors.New("Dimensions must be string")
		}
	}
	if v, ok := optional["EndTime"]; ok {
		if EndTime, ok := v.(string); ok {
			args.Query.Set("EndTime", EndTime)
		} else {
			return nil, errors.New("EndTime must be string")
		}
	}
	if v, ok := optional["Page"]; ok {
		if Page, ok := v.(int); ok {
			args.Query.Set("Page", fmt.Sprint(Page))
		} else {
			return nil, errors.New("Page must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["StartTime"]; ok {
		if StartTime, ok := v.(string); ok {
			args.Query.Set("StartTime", StartTime)
		} else {
			return nil, errors.New("StartTime must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListAlertStateResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListAlertStateResponse represents the response of the api ListAlertState.
type ListAlertStateResponse struct {
	Code       string `json:"code" xml:"code"`
	Datapoints string `json:"datapoints" xml:"datapoints"`
	Message    string `json:"message" xml:"message"`
	Success    string `json:"success" xml:"success"`
	Total      string `json:"total" xml:"total"`
	TraceId    string `json:"traceId" xml:"traceId"`
}

// ListContact version 2015-08-15
//
// required parameters:
//  name: ProjectName, type: string
//
// optional parameters:
//  name: ContactName, type: string
//  name: Page, type: int
//  name: PageSize, type: int
//  name: _region, type: string
func (api API) ListContact(ProjectName string, optional openapi.M) (*ListContactResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListContact")
	args.Method = "GET"
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/contacts`
	args.Scheme = "http"
	if v, ok := optional["ContactName"]; ok {
		if ContactName, ok := v.(string); ok {
			args.Query.Set("ContactName", ContactName)
		} else {
			return nil, errors.New("ContactName must be string")
		}
	}
	if v, ok := optional["Page"]; ok {
		if Page, ok := v.(int); ok {
			args.Query.Set("Page", fmt.Sprint(Page))
		} else {
			return nil, errors.New("Page must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListContactResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListContactResponse represents the response of the api ListContact.
type ListContactResponse struct {
	Code       string `json:"code" xml:"code"`
	Datapoints string `json:"datapoints" xml:"datapoints"`
	Message    string `json:"message" xml:"message"`
	Success    string `json:"success" xml:"success"`
	Total      string `json:"total" xml:"total"`
	TraceId    string `json:"traceId" xml:"traceId"`
}

// ListContactGroup version 2015-08-15
//
// required parameters:
//  name: ProjectName, type: string
//
// optional parameters:
//  name: GroupName, type: string
//  name: Page, type: int
//  name: PageSize, type: int
//  name: _region, type: string
func (api API) ListContactGroup(ProjectName string, optional openapi.M) (*ListContactGroupResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListContactGroup")
	args.Method = "GET"
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/groups`
	args.Scheme = "http"
	if v, ok := optional["GroupName"]; ok {
		if GroupName, ok := v.(string); ok {
			args.Query.Set("GroupName", GroupName)
		} else {
			return nil, errors.New("GroupName must be string")
		}
	}
	if v, ok := optional["Page"]; ok {
		if Page, ok := v.(int); ok {
			args.Query.Set("Page", fmt.Sprint(Page))
		} else {
			return nil, errors.New("Page must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListContactGroupResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListContactGroupResponse represents the response of the api ListContactGroup.
type ListContactGroupResponse struct {
	Code       string `json:"code" xml:"code"`
	Datapoints string `json:"datapoints" xml:"datapoints"`
	Message    string `json:"message" xml:"message"`
	Success    string `json:"success" xml:"success"`
	Total      string `json:"total" xml:"total"`
	TraceId    string `json:"traceId" xml:"traceId"`
}

// ListDBMetric version 2015-08-15
//
// required parameters:
//  name: ProjectName, type: string
//
// optional parameters:
//  name: MetricName, type: string
//  name: Page, type: int
//  name: PageSize, type: int
//  name: _region, type: string
func (api API) ListDBMetric(ProjectName string, optional openapi.M) (*ListDBMetricResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListDBMetric")
	args.Method = "GET"
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/dbMetrics`
	args.Scheme = "http"
	if v, ok := optional["MetricName"]; ok {
		if MetricName, ok := v.(string); ok {
			args.Query.Set("MetricName", MetricName)
		} else {
			return nil, errors.New("MetricName must be string")
		}
	}
	if v, ok := optional["Page"]; ok {
		if Page, ok := v.(int); ok {
			args.Query.Set("Page", fmt.Sprint(Page))
		} else {
			return nil, errors.New("Page must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListDBMetricResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListDBMetricResponse represents the response of the api ListDBMetric.
type ListDBMetricResponse struct {
	Code       string `json:"code" xml:"code"`
	Datapoints string `json:"datapoints" xml:"datapoints"`
	Message    string `json:"message" xml:"message"`
	Success    string `json:"success" xml:"success"`
	Total      string `json:"total" xml:"total"`
	TraceId    string `json:"traceId" xml:"traceId"`
}

// ListDBSource version 2015-08-15
//
// required parameters:
//  name: ProjectName, type: string
//
// optional parameters:
//  name: Page, type: int
//  name: PageSize, type: int
//  name: SourceName, type: string
//  name: _region, type: string
func (api API) ListDBSource(ProjectName string, optional openapi.M) (*ListDBSourceResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListDBSource")
	args.Method = "GET"
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/sources`
	args.Scheme = "http"
	if v, ok := optional["Page"]; ok {
		if Page, ok := v.(int); ok {
			args.Query.Set("Page", fmt.Sprint(Page))
		} else {
			return nil, errors.New("Page must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["SourceName"]; ok {
		if SourceName, ok := v.(string); ok {
			args.Query.Set("SourceName", SourceName)
		} else {
			return nil, errors.New("SourceName must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListDBSourceResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListDBSourceResponse represents the response of the api ListDBSource.
type ListDBSourceResponse struct {
	Code       string `json:"code" xml:"code"`
	Datapoints string `json:"datapoints" xml:"datapoints"`
	Message    string `json:"message" xml:"message"`
	Success    string `json:"success" xml:"success"`
	Total      string `json:"total" xml:"total"`
	TraceId    string `json:"traceId" xml:"traceId"`
}

// ListDimensions version 2015-08-15
//
// required parameters:
//  name: AlertName, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: Page, type: int
//  name: PageSize, type: int
//  name: _region, type: string
func (api API) ListDimensions(AlertName, ProjectName string, optional openapi.M) (*ListDimensionsResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListDimensions")
	args.Method = "GET"
	args.Path["AlertName"] = AlertName
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/alerts/[AlertName]/dimensions`
	args.Scheme = "http"
	if v, ok := optional["Page"]; ok {
		if Page, ok := v.(int); ok {
			args.Query.Set("Page", fmt.Sprint(Page))
		} else {
			return nil, errors.New("Page must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListDimensionsResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListDimensionsResponse represents the response of the api ListDimensions.
type ListDimensionsResponse struct {
	Code       string `json:"code" xml:"code"`
	Datapoints string `json:"datapoints" xml:"datapoints"`
	Message    string `json:"message" xml:"message"`
	Success    string `json:"success" xml:"success"`
	Total      string `json:"total" xml:"total"`
	TraceId    string `json:"traceId" xml:"traceId"`
}

// ListLevelChannel version 2015-08-15
//
// required parameters:
//  name: ProjectName, type: string
//
// optional parameters:
//  name: Level, type: string
//  name: Page, type: int
//  name: PageSize, type: int
//  name: _region, type: string
func (api API) ListLevelChannel(ProjectName string, optional openapi.M) (*ListLevelChannelResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListLevelChannel")
	args.Method = "GET"
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/level_channels`
	args.Scheme = "http"
	if v, ok := optional["Level"]; ok {
		if Level, ok := v.(string); ok {
			args.Query.Set("Level", Level)
		} else {
			return nil, errors.New("Level must be string")
		}
	}
	if v, ok := optional["Page"]; ok {
		if Page, ok := v.(int); ok {
			args.Query.Set("Page", fmt.Sprint(Page))
		} else {
			return nil, errors.New("Page must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListLevelChannelResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListLevelChannelResponse represents the response of the api ListLevelChannel.
type ListLevelChannelResponse struct {
	Code       string `json:"code" xml:"code"`
	Datapoints string `json:"datapoints" xml:"datapoints"`
	Message    string `json:"message" xml:"message"`
	Success    string `json:"success" xml:"success"`
	Total      string `json:"total" xml:"total"`
	TraceId    string `json:"traceId" xml:"traceId"`
}

// ListLogHubMetric version 2015-08-15
//
// required parameters:
//  name: ProjectName, type: string
//
// optional parameters:
//  name: MetricName, type: string
//  name: Page, type: int
//  name: PageSize, type: int
//  name: _region, type: string
func (api API) ListLogHubMetric(ProjectName string, optional openapi.M) (*ListLogHubMetricResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListLogHubMetric")
	args.Method = "GET"
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/logHubMetrics`
	args.Scheme = "http"
	if v, ok := optional["MetricName"]; ok {
		if MetricName, ok := v.(string); ok {
			args.Query.Set("MetricName", MetricName)
		} else {
			return nil, errors.New("MetricName must be string")
		}
	}
	if v, ok := optional["Page"]; ok {
		if Page, ok := v.(int); ok {
			args.Query.Set("Page", fmt.Sprint(Page))
		} else {
			return nil, errors.New("Page must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListLogHubMetricResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListLogHubMetricResponse represents the response of the api ListLogHubMetric.
type ListLogHubMetricResponse struct {
	Code       string `json:"code" xml:"code"`
	Datapoints string `json:"datapoints" xml:"datapoints"`
	Message    string `json:"message" xml:"message"`
	Success    string `json:"success" xml:"success"`
	Total      string `json:"total" xml:"total"`
	TraceId    string `json:"traceId" xml:"traceId"`
}

// ListNotifyHistory version 2015-08-15
//
// required parameters:
//  name: ProjectName, type: string
//
// optional parameters:
//  name: AlertName, type: string
//  name: Dimensions, type: string
//  name: EndTime, type: string
//  name: Page, type: int
//  name: PageSize, type: int
//  name: StartTime, type: string
//  name: _region, type: string
func (api API) ListNotifyHistory(ProjectName string, optional openapi.M) (*ListNotifyHistoryResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListNotifyHistory")
	args.Method = "GET"
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/notify_history`
	args.Scheme = "http"
	if v, ok := optional["AlertName"]; ok {
		if AlertName, ok := v.(string); ok {
			args.Query.Set("AlertName", AlertName)
		} else {
			return nil, errors.New("AlertName must be string")
		}
	}
	if v, ok := optional["Dimensions"]; ok {
		if Dimensions, ok := v.(string); ok {
			args.Query.Set("Dimensions", Dimensions)
		} else {
			return nil, errors.New("Dimensions must be string")
		}
	}
	if v, ok := optional["EndTime"]; ok {
		if EndTime, ok := v.(string); ok {
			args.Query.Set("EndTime", EndTime)
		} else {
			return nil, errors.New("EndTime must be string")
		}
	}
	if v, ok := optional["Page"]; ok {
		if Page, ok := v.(int); ok {
			args.Query.Set("Page", fmt.Sprint(Page))
		} else {
			return nil, errors.New("Page must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["StartTime"]; ok {
		if StartTime, ok := v.(string); ok {
			args.Query.Set("StartTime", StartTime)
		} else {
			return nil, errors.New("StartTime must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListNotifyHistoryResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListNotifyHistoryResponse represents the response of the api ListNotifyHistory.
type ListNotifyHistoryResponse struct {
	Code       string `json:"code" xml:"code"`
	Datapoints string `json:"datapoints" xml:"datapoints"`
	Message    string `json:"message" xml:"message"`
	Success    string `json:"success" xml:"success"`
	Total      string `json:"total" xml:"total"`
	TraceId    string `json:"traceId" xml:"traceId"`
}

// ListProject version 2015-08-15
//
// optional parameters:
//  name: Page, type: int
//  name: PageSize, type: int
//  name: ProjectOwner, type: string
//  name: _region, type: string
func (api API) ListProject(optional openapi.M) (*ListProjectResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListProject")
	args.Method = "GET"
	args.Pattern = `/projects`
	args.Scheme = "http"
	if v, ok := optional["Page"]; ok {
		if Page, ok := v.(int); ok {
			args.Query.Set("Page", fmt.Sprint(Page))
		} else {
			return nil, errors.New("Page must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["ProjectOwner"]; ok {
		if ProjectOwner, ok := v.(string); ok {
			args.Query.Set("ProjectOwner", ProjectOwner)
		} else {
			return nil, errors.New("ProjectOwner must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(ListProjectResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListProjectResponse represents the response of the api ListProject.
type ListProjectResponse struct {
	Code       string `json:"code" xml:"code"`
	Datapoints string `json:"datapoints" xml:"datapoints"`
	Message    string `json:"message" xml:"message"`
	Success    string `json:"success" xml:"success"`
	Total      string `json:"total" xml:"total"`
	TraceId    string `json:"traceId" xml:"traceId"`
}

// RemoveProjectOwner version 2015-08-15
//
// optional parameters:
//  name: Owners, type: string
//  name: ProjectName, type: string
//  name: _region, type: string
func (api API) RemoveProjectOwner(optional openapi.M) (*RemoveProjectOwnerResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "RemoveProjectOwner")
	args.Method = "GET"
	args.Pattern = `/projects/removeOwner`
	args.Scheme = "http"
	if v, ok := optional["Owners"]; ok {
		if Owners, ok := v.(string); ok {
			args.Query.Set("Owners", Owners)
		} else {
			return nil, errors.New("Owners must be string")
		}
	}
	if v, ok := optional["ProjectName"]; ok {
		if ProjectName, ok := v.(string); ok {
			args.Query.Set("ProjectName", ProjectName)
		} else {
			return nil, errors.New("ProjectName must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(RemoveProjectOwnerResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// RemoveProjectOwnerResponse represents the response of the api RemoveProjectOwner.
type RemoveProjectOwnerResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// UpdateAlert version 2015-08-15
//
// required parameters:
//  name: AlertName, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: Alert, type: string
//  name: _region, type: string
func (api API) UpdateAlert(AlertName, ProjectName string, optional openapi.M) (*UpdateAlertResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "UpdateAlert")
	args.Method = "PUT"
	args.Path["AlertName"] = AlertName
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/alerts/[AlertName]`
	args.Scheme = "http"
	if v, ok := optional["Alert"]; ok {
		if Alert, ok := v.(string); ok {
			args.Body.Set("Alert", Alert)
		} else {
			return nil, errors.New("Alert must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(UpdateAlertResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// UpdateAlertResponse represents the response of the api UpdateAlert.
type UpdateAlertResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// UpdateContact version 2015-08-15
//
// required parameters:
//  name: ContactName, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: Contact, type: string
//  name: _region, type: string
func (api API) UpdateContact(ContactName, ProjectName string, optional openapi.M) (*UpdateContactResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "UpdateContact")
	args.Method = "PUT"
	args.Path["ContactName"] = ContactName
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/contacts/[ContactName]`
	args.Scheme = "http"
	if v, ok := optional["Contact"]; ok {
		if Contact, ok := v.(string); ok {
			args.Body.Set("Contact", Contact)
		} else {
			return nil, errors.New("Contact must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(UpdateContactResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// UpdateContactResponse represents the response of the api UpdateContact.
type UpdateContactResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// UpdateContactGroup version 2015-08-15
//
// required parameters:
//  name: GroupName, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: ContactGroup, type: string
//  name: _region, type: string
func (api API) UpdateContactGroup(GroupName, ProjectName string, optional openapi.M) (*UpdateContactGroupResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "UpdateContactGroup")
	args.Method = "PUT"
	args.Path["GroupName"] = GroupName
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/groups/[GroupName]`
	args.Scheme = "http"
	if v, ok := optional["ContactGroup"]; ok {
		if ContactGroup, ok := v.(string); ok {
			args.Body.Set("ContactGroup", ContactGroup)
		} else {
			return nil, errors.New("ContactGroup must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(UpdateContactGroupResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// UpdateContactGroupResponse represents the response of the api UpdateContactGroup.
type UpdateContactGroupResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// UpdateDBMetric version 2015-08-15
//
// required parameters:
//  name: MetricName, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: Metric, type: string
//  name: _region, type: string
func (api API) UpdateDBMetric(MetricName, ProjectName string, optional openapi.M) (*UpdateDBMetricResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "UpdateDBMetric")
	args.Method = "PUT"
	args.Path["MetricName"] = MetricName
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/dbMetrics/[MetricName]`
	args.Scheme = "http"
	if v, ok := optional["Metric"]; ok {
		if Metric, ok := v.(string); ok {
			args.Body.Set("Metric", Metric)
		} else {
			return nil, errors.New("Metric must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(UpdateDBMetricResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// UpdateDBMetricResponse represents the response of the api UpdateDBMetric.
type UpdateDBMetricResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// UpdateDBSource version 2015-08-15
//
// required parameters:
//  name: ProjectName, type: string
//  name: SourceName, type: string
//
// optional parameters:
//  name: Source, type: string
//  name: _region, type: string
func (api API) UpdateDBSource(ProjectName, SourceName string, optional openapi.M) (*UpdateDBSourceResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "UpdateDBSource")
	args.Method = "PUT"
	args.Path["ProjectName"] = ProjectName
	args.Path["SourceName"] = SourceName
	args.Pattern = `/projects/[ProjectName]/sources/[SourceName]`
	args.Scheme = "http"
	if v, ok := optional["Source"]; ok {
		if Source, ok := v.(string); ok {
			args.Body.Set("Source", Source)
		} else {
			return nil, errors.New("Source must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(UpdateDBSourceResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// UpdateDBSourceResponse represents the response of the api UpdateDBSource.
type UpdateDBSourceResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// UpdateDimensions version 2015-08-15
//
// required parameters:
//  name: AlertName, type: string
//  name: DimensionsId, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: Dimensions, type: string
//  name: _region, type: string
func (api API) UpdateDimensions(AlertName, DimensionsId, ProjectName string, optional openapi.M) (*UpdateDimensionsResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "UpdateDimensions")
	args.Method = "PUT"
	args.Path["AlertName"] = AlertName
	args.Path["DimensionsId"] = DimensionsId
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/alerts/[AlertName]/dimensions/[DimensionsId]`
	args.Scheme = "http"
	if v, ok := optional["Dimensions"]; ok {
		if Dimensions, ok := v.(string); ok {
			args.Body.Set("Dimensions", Dimensions)
		} else {
			return nil, errors.New("Dimensions must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(UpdateDimensionsResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// UpdateDimensionsResponse represents the response of the api UpdateDimensions.
type UpdateDimensionsResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// UpdateLevelChannel version 2015-08-15
//
// required parameters:
//  name: Level, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: LevelChannelSetting, type: string
//  name: _region, type: string
func (api API) UpdateLevelChannel(Level, ProjectName string, optional openapi.M) (*UpdateLevelChannelResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "UpdateLevelChannel")
	args.Method = "PUT"
	args.Path["Level"] = Level
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/level_channels/[Level]`
	args.Scheme = "http"
	if v, ok := optional["LevelChannelSetting"]; ok {
		if LevelChannelSetting, ok := v.(string); ok {
			args.Body.Set("LevelChannelSetting", LevelChannelSetting)
		} else {
			return nil, errors.New("LevelChannelSetting must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(UpdateLevelChannelResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// UpdateLevelChannelResponse represents the response of the api UpdateLevelChannel.
type UpdateLevelChannelResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// UpdateLogHubMetric version 2015-08-15
//
// required parameters:
//  name: MetricName, type: string
//  name: ProjectName, type: string
//
// optional parameters:
//  name: Metric, type: string
//  name: _region, type: string
func (api API) UpdateLogHubMetric(MetricName, ProjectName string, optional openapi.M) (*UpdateLogHubMetricResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "UpdateLogHubMetric")
	args.Method = "PUT"
	args.Path["MetricName"] = MetricName
	args.Path["ProjectName"] = ProjectName
	args.Pattern = `/projects/[ProjectName]/logHubMetrics/[MetricName]`
	args.Scheme = "http"
	if v, ok := optional["Metric"]; ok {
		if Metric, ok := v.(string); ok {
			args.Body.Set("Metric", Metric)
		} else {
			return nil, errors.New("Metric must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(UpdateLogHubMetricResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// UpdateLogHubMetricResponse represents the response of the api UpdateLogHubMetric.
type UpdateLogHubMetricResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}

// UpdateProject version 2015-08-15
//
// optional parameters:
//  name: Project, type: string
//  name: ProjectName, type: string
//  name: _region, type: string
func (api API) UpdateProject(optional openapi.M) (*UpdateProjectResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "UpdateProject")
	args.Method = "PUT"
	args.Pattern = `/projects/[ProjectName]`
	args.Scheme = "http"
	if v, ok := optional["Project"]; ok {
		if Project, ok := v.(string); ok {
			args.Body.Set("Project", Project)
		} else {
			return nil, errors.New("Project must be string")
		}
	}
	if v, ok := optional["ProjectName"]; ok {
		if ProjectName, ok := v.(string); ok {
			args.Path["ProjectName"] = ProjectName
		} else {
			return nil, errors.New("ProjectName must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}

	result := new(UpdateProjectResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// UpdateProjectResponse represents the response of the api UpdateProject.
type UpdateProjectResponse struct {
	Code    string `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
	Success string `json:"success" xml:"success"`
	TraceId string `json:"traceId" xml:"traceId"`
}
