// Copyright 2015 Chen Xianren. All rights reserved.
// Code generated by openapi-meta; DO NOT EDIT

package aas // import "github.com/cxr29/aliyun-openapi-go-sdk/apis/aas/v20150701"

import (
	"errors"
	"fmt"

	"github.com/cxr29/aliyun-openapi-go-sdk"
)

var (
	_ = errors.New("")
	_ = fmt.Sprint("")
)

type API struct {
	openapi.Service
}

func New(accessKeyId, accessKeySecret string) API {
	return API{openapi.NewService(accessKeyId, accessKeySecret)}
}

func NewParams() openapi.Params {
	args := openapi.NewParams()
	args.Product = Product
	args.Style = Style
	args.Version = Version
	return args
}

const (
	Product = "Aas"
	Style   = "RPC"
	Version = "2015-07-01"
)

// CreateAccessKeyForAccount version 2015-07-01
//
// optional parameters:
//  name: AKSecret, type: string
//  name: PK, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) CreateAccessKeyForAccount(optional openapi.M) (*CreateAccessKeyForAccountResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateAccessKeyForAccount")
	if v, ok := optional["AKSecret"]; ok {
		if AKSecret, ok := v.(string); ok {
			args.Query.Set("AKSecret", AKSecret)
		} else {
			return nil, errors.New("AKSecret must be string")
		}
	}
	if v, ok := optional["PK"]; ok {
		if PK, ok := v.(string); ok {
			args.Query.Set("PK", PK)
		} else {
			return nil, errors.New("PK must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(CreateAccessKeyForAccountResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateAccessKeyForAccountResponse represents the response of the api CreateAccessKeyForAccount.
type CreateAccessKeyForAccountResponse struct {
	AccessKey struct {
		AccessKeyId     string
		AccessKeySecret string
		AccessKeyStatus string // optional values: Active|Inactive
		AccessKeyType   string // optional values: RSAPub|Symmetric
		CreateTime      string
	}
	PK string
}

// CreateAliyunAccount version 2015-07-01
//
// optional parameters:
//  name: AliyunId, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) CreateAliyunAccount(optional openapi.M) (*CreateAliyunAccountResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateAliyunAccount")
	if v, ok := optional["AliyunId"]; ok {
		if AliyunId, ok := v.(string); ok {
			args.Query.Set("AliyunId", AliyunId)
		} else {
			return nil, errors.New("AliyunId must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(CreateAliyunAccountResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateAliyunAccountResponse represents the response of the api CreateAliyunAccount.
type CreateAliyunAccountResponse struct {
	AliyunId string
	PK       string
}

// DeleteAccessKeyForAccount version 2015-07-01
//
// optional parameters:
//  name: AKId, type: string
//  name: PK, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DeleteAccessKeyForAccount(optional openapi.M) (*DeleteAccessKeyForAccountResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteAccessKeyForAccount")
	if v, ok := optional["AKId"]; ok {
		if AKId, ok := v.(string); ok {
			args.Query.Set("AKId", AKId)
		} else {
			return nil, errors.New("AKId must be string")
		}
	}
	if v, ok := optional["PK"]; ok {
		if PK, ok := v.(string); ok {
			args.Query.Set("PK", PK)
		} else {
			return nil, errors.New("PK must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DeleteAccessKeyForAccountResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteAccessKeyForAccountResponse represents the response of the api DeleteAccessKeyForAccount.
type DeleteAccessKeyForAccountResponse struct {
	PK     string
	Result string // optional values: Fail|Success
}

// GetBasicInfoForAccount version 2015-07-01
//
// optional parameters:
//  name: AliyunId, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) GetBasicInfoForAccount(optional openapi.M) (*GetBasicInfoForAccountResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetBasicInfoForAccount")
	if v, ok := optional["AliyunId"]; ok {
		if AliyunId, ok := v.(string); ok {
			args.Query.Set("AliyunId", AliyunId)
		} else {
			return nil, errors.New("AliyunId must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(GetBasicInfoForAccountResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetBasicInfoForAccountResponse represents the response of the api GetBasicInfoForAccount.
type GetBasicInfoForAccountResponse struct {
	LastLoginDate string
	PK            string
}

// ListAccessKeysForAccount version 2015-07-01
//
// optional parameters:
//  name: AKStatus, type: string
//  name: AKType, type: string
//  name: PK, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ListAccessKeysForAccount(optional openapi.M) (*ListAccessKeysForAccountResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListAccessKeysForAccount")
	if v, ok := optional["AKStatus"]; ok {
		if AKStatus, ok := v.(string); ok {
			args.Query.Set("AKStatus", AKStatus)
		} else {
			return nil, errors.New("AKStatus must be string")
		}
	}
	if v, ok := optional["AKType"]; ok {
		if AKType, ok := v.(string); ok {
			args.Query.Set("AKType", AKType)
		} else {
			return nil, errors.New("AKType must be string")
		}
	}
	if v, ok := optional["PK"]; ok {
		if PK, ok := v.(string); ok {
			args.Query.Set("PK", PK)
		} else {
			return nil, errors.New("PK must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(ListAccessKeysForAccountResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListAccessKeysForAccountResponse represents the response of the api ListAccessKeysForAccount.
type ListAccessKeysForAccountResponse struct {
	AccessKeys struct {
		AccessKey []struct {
			AccessKeyId     string
			AccessKeySecret string
			AccessKeyStatus string // optional values: Active|Inactive
			AccessKeyType   string // optional values: RSAPub|Symmetric
			CreateTime      string
		}
	}
	PK string
}

// UpdateAccessKeyStatusForAccount version 2015-07-01
//
// optional parameters:
//  name: AKId, type: string
//  name: AKStatus, type: string
//  name: PK, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) UpdateAccessKeyStatusForAccount(optional openapi.M) (*UpdateAccessKeyStatusForAccountResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "UpdateAccessKeyStatusForAccount")
	if v, ok := optional["AKId"]; ok {
		if AKId, ok := v.(string); ok {
			args.Query.Set("AKId", AKId)
		} else {
			return nil, errors.New("AKId must be string")
		}
	}
	if v, ok := optional["AKStatus"]; ok {
		if AKStatus, ok := v.(string); ok {
			args.Query.Set("AKStatus", AKStatus)
		} else {
			return nil, errors.New("AKStatus must be string")
		}
	}
	if v, ok := optional["PK"]; ok {
		if PK, ok := v.(string); ok {
			args.Query.Set("PK", PK)
		} else {
			return nil, errors.New("PK must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(UpdateAccessKeyStatusForAccountResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// UpdateAccessKeyStatusForAccountResponse represents the response of the api UpdateAccessKeyStatusForAccount.
type UpdateAccessKeyStatusForAccountResponse struct {
	PK     string
	Result string // optional values: Fail|Success
}
