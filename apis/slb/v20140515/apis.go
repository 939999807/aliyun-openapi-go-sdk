// Copyright 2015 Chen Xianren. All rights reserved.
// Code generated by openapi-meta; DO NOT EDIT

package slb

import (
	"errors"
	"fmt"

	"git.oschina.net/cxr29/aliyun-openapi-go-sdk"
)

var (
	_ = errors.New("")
	_ = fmt.Sprint("")
	_ = make(openapi.M)
)

type API struct {
	openapi.Service
}

func New(accessKeyId, accessKeySecret string) API {
	return API{openapi.NewService(accessKeyId, accessKeySecret)}
}

func NewParams() openapi.Params {
	args := openapi.NewParams()
	args.Product = Product
	args.Style = Style
	args.Version = Version
	return args
}

const (
	Product = "Slb"
	Style   = "RPC"
	Version = "2014-05-15"
)

// AddBackendServers version 2014-05-15
//
// required parameters:
//  name: LoadBalancerId, type: string
//
// optional parameters:
//  name: BackendServers, type: string
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) AddBackendServers(LoadBalancerId string, optional openapi.M) (*AddBackendServersResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "AddBackendServers")
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	if v, ok := optional["BackendServers"]; ok {
		if BackendServers, ok := v.(string); ok {
			args.Query.Set("BackendServers", BackendServers)
		} else {
			return nil, errors.New("BackendServers must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(AddBackendServersResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// AddBackendServersResponse represents the response of the api AddBackendServers.
type AddBackendServersResponse struct {
	BackendServers struct {
		BackendServer []struct {
			ServerId string
			Weight   string
		}
	}
	LoadBalancerId string
}

// AddListenerWhiteListItem version 2014-05-15
//
// required parameters:
//  name: ListenerPort, type: int, min value: 1, max value: 65535
//  name: LoadBalancerId, type: string
//  name: SourceItems, type: string
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) AddListenerWhiteListItem(ListenerPort int, LoadBalancerId, SourceItems string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "AddListenerWhiteListItem")
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	args.Query.Set("SourceItems", SourceItems)
	if ListenerPort < 1 {
		return nil, errors.New("ListenerPort must be equal or greater than 1")
	}
	if ListenerPort > 65535 {
		return nil, errors.New("ListenerPort must be equal or less than 65535")
	}
	args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateLoadBalancer version 2014-05-15
//
// optional parameters:
//  name: AddressType, type: string
//  name: Bandwidth, type: int, min value: -1, max value: 1000
//  name: ClientToken, type: string
//  name: InternetChargeType, type: string
//  name: LoadBalancerName, type: string
//  name: MasterZoneId, type: string
//  name: MaxConnLimit, type: int
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: SecurityStatus, type: string
//  name: SlaveZoneId, type: string
//  name: VSwitchId, type: string
//  name: VpcId, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) CreateLoadBalancer(optional openapi.M) (*CreateLoadBalancerResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateLoadBalancer")
	if v, ok := optional["AddressType"]; ok {
		if AddressType, ok := v.(string); ok {
			args.Query.Set("AddressType", AddressType)
		} else {
			return nil, errors.New("AddressType must be string")
		}
	}
	if v, ok := optional["Bandwidth"]; ok {
		if Bandwidth, ok := v.(int); ok {
			if Bandwidth < -1 {
				return nil, errors.New("Bandwidth must be equal or greater than -1")
			}
			if Bandwidth > 1000 {
				return nil, errors.New("Bandwidth must be equal or less than 1000")
			}
			args.Query.Set("Bandwidth", fmt.Sprint(Bandwidth))
		} else {
			return nil, errors.New("Bandwidth must be int")
		}
	}
	if v, ok := optional["ClientToken"]; ok {
		if ClientToken, ok := v.(string); ok {
			args.Query.Set("ClientToken", ClientToken)
		} else {
			return nil, errors.New("ClientToken must be string")
		}
	}
	if v, ok := optional["InternetChargeType"]; ok {
		if InternetChargeType, ok := v.(string); ok {
			args.Query.Set("InternetChargeType", InternetChargeType)
		} else {
			return nil, errors.New("InternetChargeType must be string")
		}
	}
	if v, ok := optional["LoadBalancerName"]; ok {
		if LoadBalancerName, ok := v.(string); ok {
			args.Query.Set("LoadBalancerName", LoadBalancerName)
		} else {
			return nil, errors.New("LoadBalancerName must be string")
		}
	}
	if v, ok := optional["MasterZoneId"]; ok {
		if MasterZoneId, ok := v.(string); ok {
			args.Query.Set("MasterZoneId", MasterZoneId)
		} else {
			return nil, errors.New("MasterZoneId must be string")
		}
	}
	if v, ok := optional["MaxConnLimit"]; ok {
		if MaxConnLimit, ok := v.(int); ok {
			args.Query.Set("MaxConnLimit", fmt.Sprint(MaxConnLimit))
		} else {
			return nil, errors.New("MaxConnLimit must be int")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["SecurityStatus"]; ok {
		if SecurityStatus, ok := v.(string); ok {
			args.Query.Set("SecurityStatus", SecurityStatus)
		} else {
			return nil, errors.New("SecurityStatus must be string")
		}
	}
	if v, ok := optional["SlaveZoneId"]; ok {
		if SlaveZoneId, ok := v.(string); ok {
			args.Query.Set("SlaveZoneId", SlaveZoneId)
		} else {
			return nil, errors.New("SlaveZoneId must be string")
		}
	}
	if v, ok := optional["VSwitchId"]; ok {
		if VSwitchId, ok := v.(string); ok {
			args.Query.Set("VSwitchId", VSwitchId)
		} else {
			return nil, errors.New("VSwitchId must be string")
		}
	}
	if v, ok := optional["VpcId"]; ok {
		if VpcId, ok := v.(string); ok {
			args.Query.Set("VpcId", VpcId)
		} else {
			return nil, errors.New("VpcId must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(CreateLoadBalancerResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateLoadBalancerResponse represents the response of the api CreateLoadBalancer.
type CreateLoadBalancerResponse struct {
	Address          string
	LoadBalancerId   string
	LoadBalancerName string
	NetworkType      string
	VSwitchId        string
	VpcId            string
}

// CreateLoadBalancerHTTPListener version 2014-05-15
//
// required parameters:
//  name: BackendServerPort, type: int, min value: 1, max value: 65535
//  name: Bandwidth, type: int, min value: -1, max value: 1000
//  name: HealthCheck, type: string
//  name: ListenerPort, type: int, min value: 1, max value: 65535
//  name: LoadBalancerId, type: string
//  name: StickySession, type: string
//
// optional parameters:
//  name: Cookie, type: string
//  name: CookieTimeout, type: int, min value: 1, max value: 86400
//  name: HealthCheckConnectPort, type: int, min value: -520, max value: 65535
//  name: HealthCheckDomain, type: string
//  name: HealthCheckHttpCode, type: string
//  name: HealthCheckInterval, type: int, min value: 1, max value: 5
//  name: HealthCheckTimeout, type: int, min value: 1, max value: 50
//  name: HealthCheckURI, type: string
//  name: HealthyThreshold, type: int, min value: 1, max value: 10
//  name: MaxConnLimit, type: int
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: Scheduler, type: string
//  name: StickySessionType, type: string
//  name: UnhealthyThreshold, type: int, min value: 1, max value: 10
//  name: XForwardedFor, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) CreateLoadBalancerHTTPListener(BackendServerPort, Bandwidth int, HealthCheck string, ListenerPort int, LoadBalancerId, StickySession string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateLoadBalancerHTTPListener")
	args.Query.Set("HealthCheck", HealthCheck)
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	args.Query.Set("StickySession", StickySession)
	if BackendServerPort < 1 {
		return nil, errors.New("BackendServerPort must be equal or greater than 1")
	}
	if BackendServerPort > 65535 {
		return nil, errors.New("BackendServerPort must be equal or less than 65535")
	}
	args.Query.Set("BackendServerPort", fmt.Sprint(BackendServerPort))
	if Bandwidth < -1 {
		return nil, errors.New("Bandwidth must be equal or greater than -1")
	}
	if Bandwidth > 1000 {
		return nil, errors.New("Bandwidth must be equal or less than 1000")
	}
	args.Query.Set("Bandwidth", fmt.Sprint(Bandwidth))
	if ListenerPort < 1 {
		return nil, errors.New("ListenerPort must be equal or greater than 1")
	}
	if ListenerPort > 65535 {
		return nil, errors.New("ListenerPort must be equal or less than 65535")
	}
	args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
	if v, ok := optional["Cookie"]; ok {
		if Cookie, ok := v.(string); ok {
			args.Query.Set("Cookie", Cookie)
		} else {
			return nil, errors.New("Cookie must be string")
		}
	}
	if v, ok := optional["CookieTimeout"]; ok {
		if CookieTimeout, ok := v.(int); ok {
			if CookieTimeout < 1 {
				return nil, errors.New("CookieTimeout must be equal or greater than 1")
			}
			if CookieTimeout > 86400 {
				return nil, errors.New("CookieTimeout must be equal or less than 86400")
			}
			args.Query.Set("CookieTimeout", fmt.Sprint(CookieTimeout))
		} else {
			return nil, errors.New("CookieTimeout must be int")
		}
	}
	if v, ok := optional["HealthCheckConnectPort"]; ok {
		if HealthCheckConnectPort, ok := v.(int); ok {
			if HealthCheckConnectPort < -520 {
				return nil, errors.New("HealthCheckConnectPort must be equal or greater than -520")
			}
			if HealthCheckConnectPort > 65535 {
				return nil, errors.New("HealthCheckConnectPort must be equal or less than 65535")
			}
			args.Query.Set("HealthCheckConnectPort", fmt.Sprint(HealthCheckConnectPort))
		} else {
			return nil, errors.New("HealthCheckConnectPort must be int")
		}
	}
	if v, ok := optional["HealthCheckDomain"]; ok {
		if HealthCheckDomain, ok := v.(string); ok {
			args.Query.Set("HealthCheckDomain", HealthCheckDomain)
		} else {
			return nil, errors.New("HealthCheckDomain must be string")
		}
	}
	if v, ok := optional["HealthCheckHttpCode"]; ok {
		if HealthCheckHttpCode, ok := v.(string); ok {
			args.Query.Set("HealthCheckHttpCode", HealthCheckHttpCode)
		} else {
			return nil, errors.New("HealthCheckHttpCode must be string")
		}
	}
	if v, ok := optional["HealthCheckInterval"]; ok {
		if HealthCheckInterval, ok := v.(int); ok {
			if HealthCheckInterval < 1 {
				return nil, errors.New("HealthCheckInterval must be equal or greater than 1")
			}
			if HealthCheckInterval > 5 {
				return nil, errors.New("HealthCheckInterval must be equal or less than 5")
			}
			args.Query.Set("HealthCheckInterval", fmt.Sprint(HealthCheckInterval))
		} else {
			return nil, errors.New("HealthCheckInterval must be int")
		}
	}
	if v, ok := optional["HealthCheckTimeout"]; ok {
		if HealthCheckTimeout, ok := v.(int); ok {
			if HealthCheckTimeout < 1 {
				return nil, errors.New("HealthCheckTimeout must be equal or greater than 1")
			}
			if HealthCheckTimeout > 50 {
				return nil, errors.New("HealthCheckTimeout must be equal or less than 50")
			}
			args.Query.Set("HealthCheckTimeout", fmt.Sprint(HealthCheckTimeout))
		} else {
			return nil, errors.New("HealthCheckTimeout must be int")
		}
	}
	if v, ok := optional["HealthCheckURI"]; ok {
		if HealthCheckURI, ok := v.(string); ok {
			args.Query.Set("HealthCheckURI", HealthCheckURI)
		} else {
			return nil, errors.New("HealthCheckURI must be string")
		}
	}
	if v, ok := optional["HealthyThreshold"]; ok {
		if HealthyThreshold, ok := v.(int); ok {
			if HealthyThreshold < 1 {
				return nil, errors.New("HealthyThreshold must be equal or greater than 1")
			}
			if HealthyThreshold > 10 {
				return nil, errors.New("HealthyThreshold must be equal or less than 10")
			}
			args.Query.Set("HealthyThreshold", fmt.Sprint(HealthyThreshold))
		} else {
			return nil, errors.New("HealthyThreshold must be int")
		}
	}
	if v, ok := optional["MaxConnLimit"]; ok {
		if MaxConnLimit, ok := v.(int); ok {
			args.Query.Set("MaxConnLimit", fmt.Sprint(MaxConnLimit))
		} else {
			return nil, errors.New("MaxConnLimit must be int")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["Scheduler"]; ok {
		if Scheduler, ok := v.(string); ok {
			args.Query.Set("Scheduler", Scheduler)
		} else {
			return nil, errors.New("Scheduler must be string")
		}
	}
	if v, ok := optional["StickySessionType"]; ok {
		if StickySessionType, ok := v.(string); ok {
			args.Query.Set("StickySessionType", StickySessionType)
		} else {
			return nil, errors.New("StickySessionType must be string")
		}
	}
	if v, ok := optional["UnhealthyThreshold"]; ok {
		if UnhealthyThreshold, ok := v.(int); ok {
			if UnhealthyThreshold < 1 {
				return nil, errors.New("UnhealthyThreshold must be equal or greater than 1")
			}
			if UnhealthyThreshold > 10 {
				return nil, errors.New("UnhealthyThreshold must be equal or less than 10")
			}
			args.Query.Set("UnhealthyThreshold", fmt.Sprint(UnhealthyThreshold))
		} else {
			return nil, errors.New("UnhealthyThreshold must be int")
		}
	}
	if v, ok := optional["XForwardedFor"]; ok {
		if XForwardedFor, ok := v.(string); ok {
			args.Query.Set("XForwardedFor", XForwardedFor)
		} else {
			return nil, errors.New("XForwardedFor must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateLoadBalancerHTTPSListener version 2014-05-15
//
// required parameters:
//  name: BackendServerPort, type: int, min value: 1, max value: 65535
//  name: Bandwidth, type: int, min value: -1, max value: 1000
//  name: HealthCheck, type: string
//  name: ListenerPort, type: int, min value: 1, max value: 65535
//  name: LoadBalancerId, type: string
//  name: ServerCertificateId, type: string
//  name: StickySession, type: string
//
// optional parameters:
//  name: Cookie, type: string
//  name: CookieTimeout, type: int, min value: 1, max value: 86400
//  name: HealthCheckConnectPort, type: int, min value: -520, max value: 65535
//  name: HealthCheckDomain, type: string
//  name: HealthCheckHttpCode, type: string
//  name: HealthCheckInterval, type: int, min value: 1, max value: 5
//  name: HealthCheckTimeout, type: int, min value: 1, max value: 50
//  name: HealthCheckURI, type: string
//  name: HealthyThreshold, type: int, min value: 1, max value: 10
//  name: MaxConnLimit, type: int
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: Scheduler, type: string
//  name: StickySessionType, type: string
//  name: UnhealthyThreshold, type: int, min value: 1, max value: 10
//  name: XForwardedFor, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) CreateLoadBalancerHTTPSListener(BackendServerPort, Bandwidth int, HealthCheck string, ListenerPort int, LoadBalancerId, ServerCertificateId, StickySession string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateLoadBalancerHTTPSListener")
	args.Query.Set("HealthCheck", HealthCheck)
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	args.Query.Set("ServerCertificateId", ServerCertificateId)
	args.Query.Set("StickySession", StickySession)
	if BackendServerPort < 1 {
		return nil, errors.New("BackendServerPort must be equal or greater than 1")
	}
	if BackendServerPort > 65535 {
		return nil, errors.New("BackendServerPort must be equal or less than 65535")
	}
	args.Query.Set("BackendServerPort", fmt.Sprint(BackendServerPort))
	if Bandwidth < -1 {
		return nil, errors.New("Bandwidth must be equal or greater than -1")
	}
	if Bandwidth > 1000 {
		return nil, errors.New("Bandwidth must be equal or less than 1000")
	}
	args.Query.Set("Bandwidth", fmt.Sprint(Bandwidth))
	if ListenerPort < 1 {
		return nil, errors.New("ListenerPort must be equal or greater than 1")
	}
	if ListenerPort > 65535 {
		return nil, errors.New("ListenerPort must be equal or less than 65535")
	}
	args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
	if v, ok := optional["Cookie"]; ok {
		if Cookie, ok := v.(string); ok {
			args.Query.Set("Cookie", Cookie)
		} else {
			return nil, errors.New("Cookie must be string")
		}
	}
	if v, ok := optional["CookieTimeout"]; ok {
		if CookieTimeout, ok := v.(int); ok {
			if CookieTimeout < 1 {
				return nil, errors.New("CookieTimeout must be equal or greater than 1")
			}
			if CookieTimeout > 86400 {
				return nil, errors.New("CookieTimeout must be equal or less than 86400")
			}
			args.Query.Set("CookieTimeout", fmt.Sprint(CookieTimeout))
		} else {
			return nil, errors.New("CookieTimeout must be int")
		}
	}
	if v, ok := optional["HealthCheckConnectPort"]; ok {
		if HealthCheckConnectPort, ok := v.(int); ok {
			if HealthCheckConnectPort < -520 {
				return nil, errors.New("HealthCheckConnectPort must be equal or greater than -520")
			}
			if HealthCheckConnectPort > 65535 {
				return nil, errors.New("HealthCheckConnectPort must be equal or less than 65535")
			}
			args.Query.Set("HealthCheckConnectPort", fmt.Sprint(HealthCheckConnectPort))
		} else {
			return nil, errors.New("HealthCheckConnectPort must be int")
		}
	}
	if v, ok := optional["HealthCheckDomain"]; ok {
		if HealthCheckDomain, ok := v.(string); ok {
			args.Query.Set("HealthCheckDomain", HealthCheckDomain)
		} else {
			return nil, errors.New("HealthCheckDomain must be string")
		}
	}
	if v, ok := optional["HealthCheckHttpCode"]; ok {
		if HealthCheckHttpCode, ok := v.(string); ok {
			args.Query.Set("HealthCheckHttpCode", HealthCheckHttpCode)
		} else {
			return nil, errors.New("HealthCheckHttpCode must be string")
		}
	}
	if v, ok := optional["HealthCheckInterval"]; ok {
		if HealthCheckInterval, ok := v.(int); ok {
			if HealthCheckInterval < 1 {
				return nil, errors.New("HealthCheckInterval must be equal or greater than 1")
			}
			if HealthCheckInterval > 5 {
				return nil, errors.New("HealthCheckInterval must be equal or less than 5")
			}
			args.Query.Set("HealthCheckInterval", fmt.Sprint(HealthCheckInterval))
		} else {
			return nil, errors.New("HealthCheckInterval must be int")
		}
	}
	if v, ok := optional["HealthCheckTimeout"]; ok {
		if HealthCheckTimeout, ok := v.(int); ok {
			if HealthCheckTimeout < 1 {
				return nil, errors.New("HealthCheckTimeout must be equal or greater than 1")
			}
			if HealthCheckTimeout > 50 {
				return nil, errors.New("HealthCheckTimeout must be equal or less than 50")
			}
			args.Query.Set("HealthCheckTimeout", fmt.Sprint(HealthCheckTimeout))
		} else {
			return nil, errors.New("HealthCheckTimeout must be int")
		}
	}
	if v, ok := optional["HealthCheckURI"]; ok {
		if HealthCheckURI, ok := v.(string); ok {
			args.Query.Set("HealthCheckURI", HealthCheckURI)
		} else {
			return nil, errors.New("HealthCheckURI must be string")
		}
	}
	if v, ok := optional["HealthyThreshold"]; ok {
		if HealthyThreshold, ok := v.(int); ok {
			if HealthyThreshold < 1 {
				return nil, errors.New("HealthyThreshold must be equal or greater than 1")
			}
			if HealthyThreshold > 10 {
				return nil, errors.New("HealthyThreshold must be equal or less than 10")
			}
			args.Query.Set("HealthyThreshold", fmt.Sprint(HealthyThreshold))
		} else {
			return nil, errors.New("HealthyThreshold must be int")
		}
	}
	if v, ok := optional["MaxConnLimit"]; ok {
		if MaxConnLimit, ok := v.(int); ok {
			args.Query.Set("MaxConnLimit", fmt.Sprint(MaxConnLimit))
		} else {
			return nil, errors.New("MaxConnLimit must be int")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["Scheduler"]; ok {
		if Scheduler, ok := v.(string); ok {
			args.Query.Set("Scheduler", Scheduler)
		} else {
			return nil, errors.New("Scheduler must be string")
		}
	}
	if v, ok := optional["StickySessionType"]; ok {
		if StickySessionType, ok := v.(string); ok {
			args.Query.Set("StickySessionType", StickySessionType)
		} else {
			return nil, errors.New("StickySessionType must be string")
		}
	}
	if v, ok := optional["UnhealthyThreshold"]; ok {
		if UnhealthyThreshold, ok := v.(int); ok {
			if UnhealthyThreshold < 1 {
				return nil, errors.New("UnhealthyThreshold must be equal or greater than 1")
			}
			if UnhealthyThreshold > 10 {
				return nil, errors.New("UnhealthyThreshold must be equal or less than 10")
			}
			args.Query.Set("UnhealthyThreshold", fmt.Sprint(UnhealthyThreshold))
		} else {
			return nil, errors.New("UnhealthyThreshold must be int")
		}
	}
	if v, ok := optional["XForwardedFor"]; ok {
		if XForwardedFor, ok := v.(string); ok {
			args.Query.Set("XForwardedFor", XForwardedFor)
		} else {
			return nil, errors.New("XForwardedFor must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateLoadBalancerTCPListener version 2014-05-15
//
// required parameters:
//  name: BackendServerPort, type: int, min value: 1, max value: 65535
//  name: Bandwidth, type: int, min value: -1, max value: 1000
//  name: ListenerPort, type: int, min value: 1, max value: 65535
//  name: LoadBalancerId, type: string
//
// optional parameters:
//  name: HealthCheckConnectPort, type: int, min value: 1, max value: 65535
//  name: HealthCheckConnectTimeout, type: int, min value: 1, max value: 50
//  name: HealthCheckDomain, type: string
//  name: HealthCheckHttpCode, type: string
//  name: HealthCheckType, type: string
//  name: HealthCheckURI, type: string
//  name: HealthyThreshold, type: int, min value: 1, max value: 10
//  name: MaxConnLimit, type: int
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: PersistenceTimeout, type: int, min value: 0, max value: 86400
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: Scheduler, type: string
//  name: UnhealthyThreshold, type: int, min value: 1, max value: 10
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
//  name: healthCheckInterval, type: int, min value: 1, max value: 5
func (api API) CreateLoadBalancerTCPListener(BackendServerPort, Bandwidth, ListenerPort int, LoadBalancerId string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateLoadBalancerTCPListener")
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	if BackendServerPort < 1 {
		return nil, errors.New("BackendServerPort must be equal or greater than 1")
	}
	if BackendServerPort > 65535 {
		return nil, errors.New("BackendServerPort must be equal or less than 65535")
	}
	args.Query.Set("BackendServerPort", fmt.Sprint(BackendServerPort))
	if Bandwidth < -1 {
		return nil, errors.New("Bandwidth must be equal or greater than -1")
	}
	if Bandwidth > 1000 {
		return nil, errors.New("Bandwidth must be equal or less than 1000")
	}
	args.Query.Set("Bandwidth", fmt.Sprint(Bandwidth))
	if ListenerPort < 1 {
		return nil, errors.New("ListenerPort must be equal or greater than 1")
	}
	if ListenerPort > 65535 {
		return nil, errors.New("ListenerPort must be equal or less than 65535")
	}
	args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
	if v, ok := optional["HealthCheckConnectPort"]; ok {
		if HealthCheckConnectPort, ok := v.(int); ok {
			if HealthCheckConnectPort < 1 {
				return nil, errors.New("HealthCheckConnectPort must be equal or greater than 1")
			}
			if HealthCheckConnectPort > 65535 {
				return nil, errors.New("HealthCheckConnectPort must be equal or less than 65535")
			}
			args.Query.Set("HealthCheckConnectPort", fmt.Sprint(HealthCheckConnectPort))
		} else {
			return nil, errors.New("HealthCheckConnectPort must be int")
		}
	}
	if v, ok := optional["HealthCheckConnectTimeout"]; ok {
		if HealthCheckConnectTimeout, ok := v.(int); ok {
			if HealthCheckConnectTimeout < 1 {
				return nil, errors.New("HealthCheckConnectTimeout must be equal or greater than 1")
			}
			if HealthCheckConnectTimeout > 50 {
				return nil, errors.New("HealthCheckConnectTimeout must be equal or less than 50")
			}
			args.Query.Set("HealthCheckConnectTimeout", fmt.Sprint(HealthCheckConnectTimeout))
		} else {
			return nil, errors.New("HealthCheckConnectTimeout must be int")
		}
	}
	if v, ok := optional["HealthCheckDomain"]; ok {
		if HealthCheckDomain, ok := v.(string); ok {
			args.Query.Set("HealthCheckDomain", HealthCheckDomain)
		} else {
			return nil, errors.New("HealthCheckDomain must be string")
		}
	}
	if v, ok := optional["HealthCheckHttpCode"]; ok {
		if HealthCheckHttpCode, ok := v.(string); ok {
			args.Query.Set("HealthCheckHttpCode", HealthCheckHttpCode)
		} else {
			return nil, errors.New("HealthCheckHttpCode must be string")
		}
	}
	if v, ok := optional["HealthCheckType"]; ok {
		if HealthCheckType, ok := v.(string); ok {
			args.Query.Set("HealthCheckType", HealthCheckType)
		} else {
			return nil, errors.New("HealthCheckType must be string")
		}
	}
	if v, ok := optional["HealthCheckURI"]; ok {
		if HealthCheckURI, ok := v.(string); ok {
			args.Query.Set("HealthCheckURI", HealthCheckURI)
		} else {
			return nil, errors.New("HealthCheckURI must be string")
		}
	}
	if v, ok := optional["HealthyThreshold"]; ok {
		if HealthyThreshold, ok := v.(int); ok {
			if HealthyThreshold < 1 {
				return nil, errors.New("HealthyThreshold must be equal or greater than 1")
			}
			if HealthyThreshold > 10 {
				return nil, errors.New("HealthyThreshold must be equal or less than 10")
			}
			args.Query.Set("HealthyThreshold", fmt.Sprint(HealthyThreshold))
		} else {
			return nil, errors.New("HealthyThreshold must be int")
		}
	}
	if v, ok := optional["MaxConnLimit"]; ok {
		if MaxConnLimit, ok := v.(int); ok {
			args.Query.Set("MaxConnLimit", fmt.Sprint(MaxConnLimit))
		} else {
			return nil, errors.New("MaxConnLimit must be int")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["PersistenceTimeout"]; ok {
		if PersistenceTimeout, ok := v.(int); ok {
			if PersistenceTimeout < 0 {
				return nil, errors.New("PersistenceTimeout must be equal or greater than 0")
			}
			if PersistenceTimeout > 86400 {
				return nil, errors.New("PersistenceTimeout must be equal or less than 86400")
			}
			args.Query.Set("PersistenceTimeout", fmt.Sprint(PersistenceTimeout))
		} else {
			return nil, errors.New("PersistenceTimeout must be int")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["Scheduler"]; ok {
		if Scheduler, ok := v.(string); ok {
			args.Query.Set("Scheduler", Scheduler)
		} else {
			return nil, errors.New("Scheduler must be string")
		}
	}
	if v, ok := optional["UnhealthyThreshold"]; ok {
		if UnhealthyThreshold, ok := v.(int); ok {
			if UnhealthyThreshold < 1 {
				return nil, errors.New("UnhealthyThreshold must be equal or greater than 1")
			}
			if UnhealthyThreshold > 10 {
				return nil, errors.New("UnhealthyThreshold must be equal or less than 10")
			}
			args.Query.Set("UnhealthyThreshold", fmt.Sprint(UnhealthyThreshold))
		} else {
			return nil, errors.New("UnhealthyThreshold must be int")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}
	if v, ok := optional["healthCheckInterval"]; ok {
		if healthCheckInterval, ok := v.(int); ok {
			if healthCheckInterval < 1 {
				return nil, errors.New("healthCheckInterval must be equal or greater than 1")
			}
			if healthCheckInterval > 5 {
				return nil, errors.New("healthCheckInterval must be equal or less than 5")
			}
			args.Query.Set("healthCheckInterval", fmt.Sprint(healthCheckInterval))
		} else {
			return nil, errors.New("healthCheckInterval must be int")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateLoadBalancerUDPListener version 2014-05-15
//
// required parameters:
//  name: BackendServerPort, type: int, min value: 1, max value: 65535
//  name: Bandwidth, type: int, min value: -1, max value: 1000
//  name: ListenerPort, type: int, min value: 1, max value: 65535
//  name: LoadBalancerId, type: string
//
// optional parameters:
//  name: HealthCheckConnectPort, type: int, min value: 1, max value: 65535
//  name: HealthCheckConnectTimeout, type: int, min value: 1, max value: 50
//  name: HealthyThreshold, type: int, min value: 1, max value: 10
//  name: MaxConnLimit, type: int
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: PersistenceTimeout, type: int, min value: 0, max value: 86400
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: Scheduler, type: string
//  name: UnhealthyThreshold, type: int, min value: 1, max value: 10
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
//  name: healthCheckInterval, type: int, min value: 1, max value: 5
func (api API) CreateLoadBalancerUDPListener(BackendServerPort, Bandwidth, ListenerPort int, LoadBalancerId string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateLoadBalancerUDPListener")
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	if BackendServerPort < 1 {
		return nil, errors.New("BackendServerPort must be equal or greater than 1")
	}
	if BackendServerPort > 65535 {
		return nil, errors.New("BackendServerPort must be equal or less than 65535")
	}
	args.Query.Set("BackendServerPort", fmt.Sprint(BackendServerPort))
	if Bandwidth < -1 {
		return nil, errors.New("Bandwidth must be equal or greater than -1")
	}
	if Bandwidth > 1000 {
		return nil, errors.New("Bandwidth must be equal or less than 1000")
	}
	args.Query.Set("Bandwidth", fmt.Sprint(Bandwidth))
	if ListenerPort < 1 {
		return nil, errors.New("ListenerPort must be equal or greater than 1")
	}
	if ListenerPort > 65535 {
		return nil, errors.New("ListenerPort must be equal or less than 65535")
	}
	args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
	if v, ok := optional["HealthCheckConnectPort"]; ok {
		if HealthCheckConnectPort, ok := v.(int); ok {
			if HealthCheckConnectPort < 1 {
				return nil, errors.New("HealthCheckConnectPort must be equal or greater than 1")
			}
			if HealthCheckConnectPort > 65535 {
				return nil, errors.New("HealthCheckConnectPort must be equal or less than 65535")
			}
			args.Query.Set("HealthCheckConnectPort", fmt.Sprint(HealthCheckConnectPort))
		} else {
			return nil, errors.New("HealthCheckConnectPort must be int")
		}
	}
	if v, ok := optional["HealthCheckConnectTimeout"]; ok {
		if HealthCheckConnectTimeout, ok := v.(int); ok {
			if HealthCheckConnectTimeout < 1 {
				return nil, errors.New("HealthCheckConnectTimeout must be equal or greater than 1")
			}
			if HealthCheckConnectTimeout > 50 {
				return nil, errors.New("HealthCheckConnectTimeout must be equal or less than 50")
			}
			args.Query.Set("HealthCheckConnectTimeout", fmt.Sprint(HealthCheckConnectTimeout))
		} else {
			return nil, errors.New("HealthCheckConnectTimeout must be int")
		}
	}
	if v, ok := optional["HealthyThreshold"]; ok {
		if HealthyThreshold, ok := v.(int); ok {
			if HealthyThreshold < 1 {
				return nil, errors.New("HealthyThreshold must be equal or greater than 1")
			}
			if HealthyThreshold > 10 {
				return nil, errors.New("HealthyThreshold must be equal or less than 10")
			}
			args.Query.Set("HealthyThreshold", fmt.Sprint(HealthyThreshold))
		} else {
			return nil, errors.New("HealthyThreshold must be int")
		}
	}
	if v, ok := optional["MaxConnLimit"]; ok {
		if MaxConnLimit, ok := v.(int); ok {
			args.Query.Set("MaxConnLimit", fmt.Sprint(MaxConnLimit))
		} else {
			return nil, errors.New("MaxConnLimit must be int")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["PersistenceTimeout"]; ok {
		if PersistenceTimeout, ok := v.(int); ok {
			if PersistenceTimeout < 0 {
				return nil, errors.New("PersistenceTimeout must be equal or greater than 0")
			}
			if PersistenceTimeout > 86400 {
				return nil, errors.New("PersistenceTimeout must be equal or less than 86400")
			}
			args.Query.Set("PersistenceTimeout", fmt.Sprint(PersistenceTimeout))
		} else {
			return nil, errors.New("PersistenceTimeout must be int")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["Scheduler"]; ok {
		if Scheduler, ok := v.(string); ok {
			args.Query.Set("Scheduler", Scheduler)
		} else {
			return nil, errors.New("Scheduler must be string")
		}
	}
	if v, ok := optional["UnhealthyThreshold"]; ok {
		if UnhealthyThreshold, ok := v.(int); ok {
			if UnhealthyThreshold < 1 {
				return nil, errors.New("UnhealthyThreshold must be equal or greater than 1")
			}
			if UnhealthyThreshold > 10 {
				return nil, errors.New("UnhealthyThreshold must be equal or less than 10")
			}
			args.Query.Set("UnhealthyThreshold", fmt.Sprint(UnhealthyThreshold))
		} else {
			return nil, errors.New("UnhealthyThreshold must be int")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}
	if v, ok := optional["healthCheckInterval"]; ok {
		if healthCheckInterval, ok := v.(int); ok {
			if healthCheckInterval < 1 {
				return nil, errors.New("healthCheckInterval must be equal or greater than 1")
			}
			if healthCheckInterval > 5 {
				return nil, errors.New("healthCheckInterval must be equal or less than 5")
			}
			args.Query.Set("healthCheckInterval", fmt.Sprint(healthCheckInterval))
		} else {
			return nil, errors.New("healthCheckInterval must be int")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteLoadBalancer version 2014-05-15
//
// required parameters:
//  name: LoadBalancerId, type: string
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DeleteLoadBalancer(LoadBalancerId string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteLoadBalancer")
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteLoadBalancerListener version 2014-05-15
//
// required parameters:
//  name: ListenerPort, type: int, min value: 1, max value: 65535
//  name: LoadBalancerId, type: string
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DeleteLoadBalancerListener(ListenerPort int, LoadBalancerId string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteLoadBalancerListener")
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	if ListenerPort < 1 {
		return nil, errors.New("ListenerPort must be equal or greater than 1")
	}
	if ListenerPort > 65535 {
		return nil, errors.New("ListenerPort must be equal or less than 65535")
	}
	args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteServerCertificate version 2014-05-15
//
// required parameters:
//  name: ServerCertificateId, type: string
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DeleteServerCertificate(ServerCertificateId string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteServerCertificate")
	args.Query.Set("ServerCertificateId", ServerCertificateId)
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeHealthStatus version 2014-05-15
//
// required parameters:
//  name: LoadBalancerId, type: string
//
// optional parameters:
//  name: ListenerPort, type: int, min value: 1, max value: 65535
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DescribeHealthStatus(LoadBalancerId string, optional openapi.M) (*DescribeHealthStatusResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DescribeHealthStatus")
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	if v, ok := optional["ListenerPort"]; ok {
		if ListenerPort, ok := v.(int); ok {
			if ListenerPort < 1 {
				return nil, errors.New("ListenerPort must be equal or greater than 1")
			}
			if ListenerPort > 65535 {
				return nil, errors.New("ListenerPort must be equal or less than 65535")
			}
			args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
		} else {
			return nil, errors.New("ListenerPort must be int")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DescribeHealthStatusResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeHealthStatusResponse represents the response of the api DescribeHealthStatus.
type DescribeHealthStatusResponse struct {
	BackendServers struct {
		BackendServer []struct {
			ServerHealthStatus string
			ServerId           string
		}
	}
}

// DescribeListenerAccessControlAttribute version 2014-05-15
//
// required parameters:
//  name: ListenerPort, type: int
//  name: LoadBalancerId, type: string
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DescribeListenerAccessControlAttribute(ListenerPort int, LoadBalancerId string, optional openapi.M) (*DescribeListenerAccessControlAttributeResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DescribeListenerAccessControlAttribute")
	args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DescribeListenerAccessControlAttributeResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeListenerAccessControlAttributeResponse represents the response of the api DescribeListenerAccessControlAttribute.
type DescribeListenerAccessControlAttributeResponse struct {
	AccessControlStatus string
	SourceItems         string
}

// DescribeLoadBalancerAttribute version 2014-05-15
//
// required parameters:
//  name: LoadBalancerId, type: string
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DescribeLoadBalancerAttribute(LoadBalancerId string, optional openapi.M) (*DescribeLoadBalancerAttributeResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DescribeLoadBalancerAttribute")
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DescribeLoadBalancerAttributeResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeLoadBalancerAttributeResponse represents the response of the api DescribeLoadBalancerAttribute.
type DescribeLoadBalancerAttributeResponse struct {
	Address        string
	AddressType    string
	BackendServers struct {
		BackendServer []struct {
			ServerId string
			Weight   int
		}
	}
	Bandwidth                int
	CreateTime               string
	CreateTimeStamp          int64
	InternetChargeType       string
	ListenerPortsAndProtocal struct {
		ListenerPortAndProtocal []struct {
			ListenerPort     int
			ListenerProtocal string
		}
	}
	ListenerPortsAndProtocol struct {
		ListenerPortAndProtocol []struct {
			ListenerPort     int
			ListenerProtocol string
		}
	}
	LoadBalancerId     string
	LoadBalancerName   string
	LoadBalancerStatus string
	MasterZoneId       string
	MaxConnLimit       int
	NetworkType        string
	RegionId           string
	RegionIdAlias      string
	SecurityStatus     string
	SlaveZoneId        string
	SysBandwidth       int
	VSwitchId          string
	VpcId              string
}

// DescribeLoadBalancerHTTPListenerAttribute version 2014-05-15
//
// required parameters:
//  name: ListenerPort, type: int, min value: 1, max value: 65535
//  name: LoadBalancerId, type: string
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DescribeLoadBalancerHTTPListenerAttribute(ListenerPort int, LoadBalancerId string, optional openapi.M) (*DescribeLoadBalancerHTTPListenerAttributeResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DescribeLoadBalancerHTTPListenerAttribute")
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	if ListenerPort < 1 {
		return nil, errors.New("ListenerPort must be equal or greater than 1")
	}
	if ListenerPort > 65535 {
		return nil, errors.New("ListenerPort must be equal or less than 65535")
	}
	args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DescribeLoadBalancerHTTPListenerAttributeResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeLoadBalancerHTTPListenerAttributeResponse represents the response of the api DescribeLoadBalancerHTTPListenerAttribute.
type DescribeLoadBalancerHTTPListenerAttributeResponse struct {
	BackendServerPort      int
	Bandwidth              int
	Cookie                 string
	CookieTimeout          int
	HealthCheck            string
	HealthCheckConnectPort int
	HealthCheckDomain      string
	HealthCheckHttpCode    string
	HealthCheckInterval    int
	HealthCheckTimeout     int
	HealthCheckURI         string
	HealthyThreshold       int
	ListenerPort           int
	MaxConnLimit           int
	Scheduler              string
	Status                 string
	StickySession          string
	StickySessionType      string
	UnhealthyThreshold     int
	XForwardedFor          string
}

// DescribeLoadBalancerHTTPSListenerAttribute version 2014-05-15
//
// required parameters:
//  name: ListenerPort, type: int, min value: 1, max value: 65535
//  name: LoadBalancerId, type: string
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DescribeLoadBalancerHTTPSListenerAttribute(ListenerPort int, LoadBalancerId string, optional openapi.M) (*DescribeLoadBalancerHTTPSListenerAttributeResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DescribeLoadBalancerHTTPSListenerAttribute")
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	if ListenerPort < 1 {
		return nil, errors.New("ListenerPort must be equal or greater than 1")
	}
	if ListenerPort > 65535 {
		return nil, errors.New("ListenerPort must be equal or less than 65535")
	}
	args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DescribeLoadBalancerHTTPSListenerAttributeResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeLoadBalancerHTTPSListenerAttributeResponse represents the response of the api DescribeLoadBalancerHTTPSListenerAttribute.
type DescribeLoadBalancerHTTPSListenerAttributeResponse struct {
	BackendServerPort      int
	Bandwidth              int
	Cookie                 string
	CookieTimeout          int
	HealthCheck            string
	HealthCheckConnectPort int
	HealthCheckDomain      string
	HealthCheckHttpCode    string
	HealthCheckInterval    int
	HealthCheckTimeout     int
	HealthCheckURI         string
	HealthyThreshold       int
	ListenerPort           int
	MaxConnLimit           int
	Scheduler              string
	ServerCertificateId    string
	Status                 string
	StickySession          string
	StickySessionType      string
	UnhealthyThreshold     int
	XForwardedFor          string
}

// DescribeLoadBalancerTCPListenerAttribute version 2014-05-15
//
// required parameters:
//  name: ListenerPort, type: int, min value: 1, max value: 65535
//  name: LoadBalancerId, type: string
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DescribeLoadBalancerTCPListenerAttribute(ListenerPort int, LoadBalancerId string, optional openapi.M) (*DescribeLoadBalancerTCPListenerAttributeResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DescribeLoadBalancerTCPListenerAttribute")
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	if ListenerPort < 1 {
		return nil, errors.New("ListenerPort must be equal or greater than 1")
	}
	if ListenerPort > 65535 {
		return nil, errors.New("ListenerPort must be equal or less than 65535")
	}
	args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DescribeLoadBalancerTCPListenerAttributeResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeLoadBalancerTCPListenerAttributeResponse represents the response of the api DescribeLoadBalancerTCPListenerAttribute.
type DescribeLoadBalancerTCPListenerAttributeResponse struct {
	BackendServerPort         int
	Bandwidth                 int
	HealthCheck               string
	HealthCheckConnectPort    int
	HealthCheckConnectTimeout int
	HealthCheckDomain         string
	HealthCheckHttpCode       string
	HealthCheckInterval       int
	HealthCheckType           string
	HealthCheckURI            string
	HealthyThreshold          int
	ListenerPort              int
	MaxConnLimit              int
	PersistenceTimeout        int
	Scheduler                 string
	Status                    string
	SynProxy                  string
	UnhealthyThreshold        int
}

// DescribeLoadBalancerUDPListenerAttribute version 2014-05-15
//
// required parameters:
//  name: ListenerPort, type: int, min value: 1, max value: 65535
//  name: LoadBalancerId, type: string
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DescribeLoadBalancerUDPListenerAttribute(ListenerPort int, LoadBalancerId string, optional openapi.M) (*DescribeLoadBalancerUDPListenerAttributeResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DescribeLoadBalancerUDPListenerAttribute")
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	if ListenerPort < 1 {
		return nil, errors.New("ListenerPort must be equal or greater than 1")
	}
	if ListenerPort > 65535 {
		return nil, errors.New("ListenerPort must be equal or less than 65535")
	}
	args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DescribeLoadBalancerUDPListenerAttributeResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeLoadBalancerUDPListenerAttributeResponse represents the response of the api DescribeLoadBalancerUDPListenerAttribute.
type DescribeLoadBalancerUDPListenerAttributeResponse struct {
	BackendServerPort         int
	Bandwidth                 int
	HealthCheck               string
	HealthCheckConnectPort    int
	HealthCheckConnectTimeout int
	HealthCheckInterval       int
	HealthyThreshold          int
	ListenerPort              int
	MaxConnLimit              int
	PersistenceTimeout        int
	Scheduler                 string
	Status                    string
	UnhealthyThreshold        int
}

// DescribeLoadBalancers version 2014-05-15
//
// optional parameters:
//  name: Address, type: string
//  name: AddressType, type: string
//  name: InternetChargeType, type: string
//  name: LoadBalancerId, type: string
//  name: MasterZoneId, type: string
//  name: NetworkType, type: string
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: SecurityStatus, type: string
//  name: ServerId, type: string
//  name: SlaveZoneId, type: string
//  name: VSwitchId, type: string
//  name: VpcId, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DescribeLoadBalancers(optional openapi.M) (*DescribeLoadBalancersResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DescribeLoadBalancers")
	if v, ok := optional["Address"]; ok {
		if Address, ok := v.(string); ok {
			args.Query.Set("Address", Address)
		} else {
			return nil, errors.New("Address must be string")
		}
	}
	if v, ok := optional["AddressType"]; ok {
		if AddressType, ok := v.(string); ok {
			args.Query.Set("AddressType", AddressType)
		} else {
			return nil, errors.New("AddressType must be string")
		}
	}
	if v, ok := optional["InternetChargeType"]; ok {
		if InternetChargeType, ok := v.(string); ok {
			args.Query.Set("InternetChargeType", InternetChargeType)
		} else {
			return nil, errors.New("InternetChargeType must be string")
		}
	}
	if v, ok := optional["LoadBalancerId"]; ok {
		if LoadBalancerId, ok := v.(string); ok {
			args.Query.Set("LoadBalancerId", LoadBalancerId)
		} else {
			return nil, errors.New("LoadBalancerId must be string")
		}
	}
	if v, ok := optional["MasterZoneId"]; ok {
		if MasterZoneId, ok := v.(string); ok {
			args.Query.Set("MasterZoneId", MasterZoneId)
		} else {
			return nil, errors.New("MasterZoneId must be string")
		}
	}
	if v, ok := optional["NetworkType"]; ok {
		if NetworkType, ok := v.(string); ok {
			args.Query.Set("NetworkType", NetworkType)
		} else {
			return nil, errors.New("NetworkType must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["SecurityStatus"]; ok {
		if SecurityStatus, ok := v.(string); ok {
			args.Query.Set("SecurityStatus", SecurityStatus)
		} else {
			return nil, errors.New("SecurityStatus must be string")
		}
	}
	if v, ok := optional["ServerId"]; ok {
		if ServerId, ok := v.(string); ok {
			args.Query.Set("ServerId", ServerId)
		} else {
			return nil, errors.New("ServerId must be string")
		}
	}
	if v, ok := optional["SlaveZoneId"]; ok {
		if SlaveZoneId, ok := v.(string); ok {
			args.Query.Set("SlaveZoneId", SlaveZoneId)
		} else {
			return nil, errors.New("SlaveZoneId must be string")
		}
	}
	if v, ok := optional["VSwitchId"]; ok {
		if VSwitchId, ok := v.(string); ok {
			args.Query.Set("VSwitchId", VSwitchId)
		} else {
			return nil, errors.New("VSwitchId must be string")
		}
	}
	if v, ok := optional["VpcId"]; ok {
		if VpcId, ok := v.(string); ok {
			args.Query.Set("VpcId", VpcId)
		} else {
			return nil, errors.New("VpcId must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DescribeLoadBalancersResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeLoadBalancersResponse represents the response of the api DescribeLoadBalancers.
type DescribeLoadBalancersResponse struct {
	LoadBalancers struct {
		LoadBalancer []struct {
			Address            string
			AddressType        string
			InternetChargeType string
			LoadBalancerId     string
			LoadBalancerName   string
			LoadBalancerStatus string
			MasterZoneId       string
			MaxConnLimit       int
			NetworkType        string
			RegionId           string
			RegionIdAlias      string
			SecurityStatus     string
			SlaveZoneId        string
			SysBandwidth       int
			VSwitchId          string
			VpcId              string
		}
	}
}

// DescribeLocations version 2014-05-15
//
// optional parameters:
//  name: Namespace, type: string
//  name: NamespaceUid, type: string
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DescribeLocations(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DescribeLocations")
	if v, ok := optional["Namespace"]; ok {
		if Namespace, ok := v.(string); ok {
			args.Query.Set("Namespace", Namespace)
		} else {
			return nil, errors.New("Namespace must be string")
		}
	}
	if v, ok := optional["NamespaceUid"]; ok {
		if NamespaceUid, ok := v.(string); ok {
			args.Query.Set("NamespaceUid", NamespaceUid)
		} else {
			return nil, errors.New("NamespaceUid must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeRegions version 2014-05-15
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DescribeRegions(optional openapi.M) (*DescribeRegionsResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DescribeRegions")
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DescribeRegionsResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeRegionsResponse represents the response of the api DescribeRegions.
type DescribeRegionsResponse struct {
	Regions struct {
		Region []struct {
			LocalName string
			RegionId  string
		}
	}
}

// DescribeRegions4Location version 2014-05-15
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DescribeRegions4Location(optional openapi.M) (*DescribeRegions4LocationResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DescribeRegions4Location")
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DescribeRegions4LocationResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeRegions4LocationResponse represents the response of the api DescribeRegions4Location.
type DescribeRegions4LocationResponse struct {
	Regions struct {
		Region []struct {
			LocalName string
			RegionId  string
		}
	}
}

// DescribeServerCertificate version 2014-05-15
//
// required parameters:
//  name: ServerCertificateId, type: string
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DescribeServerCertificate(ServerCertificateId string, optional openapi.M) (*DescribeServerCertificateResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DescribeServerCertificate")
	args.Query.Set("ServerCertificateId", ServerCertificateId)
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DescribeServerCertificateResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeServerCertificateResponse represents the response of the api DescribeServerCertificate.
type DescribeServerCertificateResponse struct {
	Fingerprint           string
	RegionId              string
	RegionIdAlias         string
	ServerCertificateId   string
	ServerCertificateName string
}

// DescribeServerCertificates version 2014-05-15
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: ServerCertificateId, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DescribeServerCertificates(optional openapi.M) (*DescribeServerCertificatesResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DescribeServerCertificates")
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["ServerCertificateId"]; ok {
		if ServerCertificateId, ok := v.(string); ok {
			args.Query.Set("ServerCertificateId", ServerCertificateId)
		} else {
			return nil, errors.New("ServerCertificateId must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DescribeServerCertificatesResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeServerCertificatesResponse represents the response of the api DescribeServerCertificates.
type DescribeServerCertificatesResponse struct {
	ServerCertificates struct {
		ServerCertificate []struct {
			Fingerprint           string
			RegionId              string
			RegionIdAlias         string
			ServerCertificateId   string
			ServerCertificateName string
		}
	}
}

// DescribeZones version 2014-05-15
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DescribeZones(optional openapi.M) (*DescribeZonesResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DescribeZones")
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DescribeZonesResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeZonesResponse represents the response of the api DescribeZones.
type DescribeZonesResponse struct {
	Zones struct {
		Zone []struct {
			LocalName  string
			SlaveZones struct {
				SlaveZone []struct {
					LocalName string
					ZoneId    string
				}
			}
			ZoneId string
		}
	}
}

// ModifyLoadBalancerInternetSpec version 2014-05-15
//
// required parameters:
//  name: LoadBalancerId, type: string
//
// optional parameters:
//  name: Bandwidth, type: int, min value: 1, max value: 1000
//  name: InternetChargeType, type: string
//  name: MasterZoneId, type: string
//  name: MaxConnLimit, type: int
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: SecurityStatus, type: string
//  name: SlaveZoneId, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ModifyLoadBalancerInternetSpec(LoadBalancerId string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "ModifyLoadBalancerInternetSpec")
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	if v, ok := optional["Bandwidth"]; ok {
		if Bandwidth, ok := v.(int); ok {
			if Bandwidth < 1 {
				return nil, errors.New("Bandwidth must be equal or greater than 1")
			}
			if Bandwidth > 1000 {
				return nil, errors.New("Bandwidth must be equal or less than 1000")
			}
			args.Query.Set("Bandwidth", fmt.Sprint(Bandwidth))
		} else {
			return nil, errors.New("Bandwidth must be int")
		}
	}
	if v, ok := optional["InternetChargeType"]; ok {
		if InternetChargeType, ok := v.(string); ok {
			args.Query.Set("InternetChargeType", InternetChargeType)
		} else {
			return nil, errors.New("InternetChargeType must be string")
		}
	}
	if v, ok := optional["MasterZoneId"]; ok {
		if MasterZoneId, ok := v.(string); ok {
			args.Query.Set("MasterZoneId", MasterZoneId)
		} else {
			return nil, errors.New("MasterZoneId must be string")
		}
	}
	if v, ok := optional["MaxConnLimit"]; ok {
		if MaxConnLimit, ok := v.(int); ok {
			args.Query.Set("MaxConnLimit", fmt.Sprint(MaxConnLimit))
		} else {
			return nil, errors.New("MaxConnLimit must be int")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["SecurityStatus"]; ok {
		if SecurityStatus, ok := v.(string); ok {
			args.Query.Set("SecurityStatus", SecurityStatus)
		} else {
			return nil, errors.New("SecurityStatus must be string")
		}
	}
	if v, ok := optional["SlaveZoneId"]; ok {
		if SlaveZoneId, ok := v.(string); ok {
			args.Query.Set("SlaveZoneId", SlaveZoneId)
		} else {
			return nil, errors.New("SlaveZoneId must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// RemoveBackendServers version 2014-05-15
//
// required parameters:
//  name: BackendServers, type: string
//  name: LoadBalancerId, type: string
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) RemoveBackendServers(BackendServers, LoadBalancerId string, optional openapi.M) (*RemoveBackendServersResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "RemoveBackendServers")
	args.Query.Set("BackendServers", BackendServers)
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(RemoveBackendServersResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// RemoveBackendServersResponse represents the response of the api RemoveBackendServers.
type RemoveBackendServersResponse struct {
	BackendServers struct {
		BackendServer []struct {
			ServerId string
			Weight   int
		}
	}
	LoadBalancerId string
}

// RemoveListenerWhiteListItem version 2014-05-15
//
// required parameters:
//  name: ListenerPort, type: int, min value: 1, max value: 65535
//  name: LoadBalancerId, type: string
//  name: SourceItems, type: string
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) RemoveListenerWhiteListItem(ListenerPort int, LoadBalancerId, SourceItems string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "RemoveListenerWhiteListItem")
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	args.Query.Set("SourceItems", SourceItems)
	if ListenerPort < 1 {
		return nil, errors.New("ListenerPort must be equal or greater than 1")
	}
	if ListenerPort > 65535 {
		return nil, errors.New("ListenerPort must be equal or less than 65535")
	}
	args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// SetBackendServers version 2014-05-15
//
// required parameters:
//  name: LoadBalancerId, type: string
//
// optional parameters:
//  name: BackendServers, type: string
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) SetBackendServers(LoadBalancerId string, optional openapi.M) (*SetBackendServersResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "SetBackendServers")
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	if v, ok := optional["BackendServers"]; ok {
		if BackendServers, ok := v.(string); ok {
			args.Query.Set("BackendServers", BackendServers)
		} else {
			return nil, errors.New("BackendServers must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(SetBackendServersResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// SetBackendServersResponse represents the response of the api SetBackendServers.
type SetBackendServersResponse struct {
	BackendServers struct {
		BackendServer []struct {
			ServerId string
			Weight   string
		}
	}
	LoadBalancerId string
}

// SetListenerAccessControlStatus version 2014-05-15
//
// required parameters:
//  name: AccessControlStatus, type: string
//  name: ListenerPort, type: int, min value: 1, max value: 65535
//  name: LoadBalancerId, type: string
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) SetListenerAccessControlStatus(AccessControlStatus string, ListenerPort int, LoadBalancerId string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "SetListenerAccessControlStatus")
	args.Query.Set("AccessControlStatus", AccessControlStatus)
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	if ListenerPort < 1 {
		return nil, errors.New("ListenerPort must be equal or greater than 1")
	}
	if ListenerPort > 65535 {
		return nil, errors.New("ListenerPort must be equal or less than 65535")
	}
	args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// SetLoadBalancerHTTPListenerAttribute version 2014-05-15
//
// required parameters:
//  name: Bandwidth, type: int, min value: -1, max value: 1000
//  name: HealthCheck, type: string
//  name: ListenerPort, type: int, min value: 1, max value: 65535
//  name: LoadBalancerId, type: string
//  name: StickySession, type: string
//
// optional parameters:
//  name: Cookie, type: string
//  name: CookieTimeout, type: int, min value: 1, max value: 86400
//  name: HealthCheckConnectPort, type: int, min value: -520, max value: 65535
//  name: HealthCheckDomain, type: string
//  name: HealthCheckHttpCode, type: string
//  name: HealthCheckInterval, type: int, min value: 1, max value: 5
//  name: HealthCheckTimeout, type: int, min value: 1, max value: 50
//  name: HealthCheckURI, type: string
//  name: HealthyThreshold, type: int, min value: 1, max value: 10
//  name: MaxConnLimit, type: int
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: Scheduler, type: string
//  name: StickySessionType, type: string
//  name: UnhealthyThreshold, type: int, min value: 1, max value: 10
//  name: XForwardedFor, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) SetLoadBalancerHTTPListenerAttribute(Bandwidth int, HealthCheck string, ListenerPort int, LoadBalancerId, StickySession string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "SetLoadBalancerHTTPListenerAttribute")
	args.Query.Set("HealthCheck", HealthCheck)
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	args.Query.Set("StickySession", StickySession)
	if Bandwidth < -1 {
		return nil, errors.New("Bandwidth must be equal or greater than -1")
	}
	if Bandwidth > 1000 {
		return nil, errors.New("Bandwidth must be equal or less than 1000")
	}
	args.Query.Set("Bandwidth", fmt.Sprint(Bandwidth))
	if ListenerPort < 1 {
		return nil, errors.New("ListenerPort must be equal or greater than 1")
	}
	if ListenerPort > 65535 {
		return nil, errors.New("ListenerPort must be equal or less than 65535")
	}
	args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
	if v, ok := optional["Cookie"]; ok {
		if Cookie, ok := v.(string); ok {
			args.Query.Set("Cookie", Cookie)
		} else {
			return nil, errors.New("Cookie must be string")
		}
	}
	if v, ok := optional["CookieTimeout"]; ok {
		if CookieTimeout, ok := v.(int); ok {
			if CookieTimeout < 1 {
				return nil, errors.New("CookieTimeout must be equal or greater than 1")
			}
			if CookieTimeout > 86400 {
				return nil, errors.New("CookieTimeout must be equal or less than 86400")
			}
			args.Query.Set("CookieTimeout", fmt.Sprint(CookieTimeout))
		} else {
			return nil, errors.New("CookieTimeout must be int")
		}
	}
	if v, ok := optional["HealthCheckConnectPort"]; ok {
		if HealthCheckConnectPort, ok := v.(int); ok {
			if HealthCheckConnectPort < -520 {
				return nil, errors.New("HealthCheckConnectPort must be equal or greater than -520")
			}
			if HealthCheckConnectPort > 65535 {
				return nil, errors.New("HealthCheckConnectPort must be equal or less than 65535")
			}
			args.Query.Set("HealthCheckConnectPort", fmt.Sprint(HealthCheckConnectPort))
		} else {
			return nil, errors.New("HealthCheckConnectPort must be int")
		}
	}
	if v, ok := optional["HealthCheckDomain"]; ok {
		if HealthCheckDomain, ok := v.(string); ok {
			args.Query.Set("HealthCheckDomain", HealthCheckDomain)
		} else {
			return nil, errors.New("HealthCheckDomain must be string")
		}
	}
	if v, ok := optional["HealthCheckHttpCode"]; ok {
		if HealthCheckHttpCode, ok := v.(string); ok {
			args.Query.Set("HealthCheckHttpCode", HealthCheckHttpCode)
		} else {
			return nil, errors.New("HealthCheckHttpCode must be string")
		}
	}
	if v, ok := optional["HealthCheckInterval"]; ok {
		if HealthCheckInterval, ok := v.(int); ok {
			if HealthCheckInterval < 1 {
				return nil, errors.New("HealthCheckInterval must be equal or greater than 1")
			}
			if HealthCheckInterval > 5 {
				return nil, errors.New("HealthCheckInterval must be equal or less than 5")
			}
			args.Query.Set("HealthCheckInterval", fmt.Sprint(HealthCheckInterval))
		} else {
			return nil, errors.New("HealthCheckInterval must be int")
		}
	}
	if v, ok := optional["HealthCheckTimeout"]; ok {
		if HealthCheckTimeout, ok := v.(int); ok {
			if HealthCheckTimeout < 1 {
				return nil, errors.New("HealthCheckTimeout must be equal or greater than 1")
			}
			if HealthCheckTimeout > 50 {
				return nil, errors.New("HealthCheckTimeout must be equal or less than 50")
			}
			args.Query.Set("HealthCheckTimeout", fmt.Sprint(HealthCheckTimeout))
		} else {
			return nil, errors.New("HealthCheckTimeout must be int")
		}
	}
	if v, ok := optional["HealthCheckURI"]; ok {
		if HealthCheckURI, ok := v.(string); ok {
			args.Query.Set("HealthCheckURI", HealthCheckURI)
		} else {
			return nil, errors.New("HealthCheckURI must be string")
		}
	}
	if v, ok := optional["HealthyThreshold"]; ok {
		if HealthyThreshold, ok := v.(int); ok {
			if HealthyThreshold < 1 {
				return nil, errors.New("HealthyThreshold must be equal or greater than 1")
			}
			if HealthyThreshold > 10 {
				return nil, errors.New("HealthyThreshold must be equal or less than 10")
			}
			args.Query.Set("HealthyThreshold", fmt.Sprint(HealthyThreshold))
		} else {
			return nil, errors.New("HealthyThreshold must be int")
		}
	}
	if v, ok := optional["MaxConnLimit"]; ok {
		if MaxConnLimit, ok := v.(int); ok {
			args.Query.Set("MaxConnLimit", fmt.Sprint(MaxConnLimit))
		} else {
			return nil, errors.New("MaxConnLimit must be int")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["Scheduler"]; ok {
		if Scheduler, ok := v.(string); ok {
			args.Query.Set("Scheduler", Scheduler)
		} else {
			return nil, errors.New("Scheduler must be string")
		}
	}
	if v, ok := optional["StickySessionType"]; ok {
		if StickySessionType, ok := v.(string); ok {
			args.Query.Set("StickySessionType", StickySessionType)
		} else {
			return nil, errors.New("StickySessionType must be string")
		}
	}
	if v, ok := optional["UnhealthyThreshold"]; ok {
		if UnhealthyThreshold, ok := v.(int); ok {
			if UnhealthyThreshold < 1 {
				return nil, errors.New("UnhealthyThreshold must be equal or greater than 1")
			}
			if UnhealthyThreshold > 10 {
				return nil, errors.New("UnhealthyThreshold must be equal or less than 10")
			}
			args.Query.Set("UnhealthyThreshold", fmt.Sprint(UnhealthyThreshold))
		} else {
			return nil, errors.New("UnhealthyThreshold must be int")
		}
	}
	if v, ok := optional["XForwardedFor"]; ok {
		if XForwardedFor, ok := v.(string); ok {
			args.Query.Set("XForwardedFor", XForwardedFor)
		} else {
			return nil, errors.New("XForwardedFor must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// SetLoadBalancerHTTPSListenerAttribute version 2014-05-15
//
// required parameters:
//  name: Bandwidth, type: int, min value: -1, max value: 1000
//  name: HealthCheck, type: string
//  name: ListenerPort, type: int, min value: 1, max value: 65535
//  name: LoadBalancerId, type: string
//  name: StickySession, type: string
//
// optional parameters:
//  name: Cookie, type: string
//  name: CookieTimeout, type: int, min value: 1, max value: 86400
//  name: HealthCheckConnectPort, type: int, min value: -520, max value: 65535
//  name: HealthCheckDomain, type: string
//  name: HealthCheckHttpCode, type: string
//  name: HealthCheckInterval, type: int, min value: 1, max value: 5
//  name: HealthCheckTimeout, type: int, min value: 1, max value: 50
//  name: HealthCheckURI, type: string
//  name: HealthyThreshold, type: int, min value: 1, max value: 10
//  name: MaxConnLimit, type: int
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: Scheduler, type: string
//  name: ServerCertificateId, type: string
//  name: StickySessionType, type: string
//  name: UnhealthyThreshold, type: int, min value: 1, max value: 10
//  name: XForwardedFor, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) SetLoadBalancerHTTPSListenerAttribute(Bandwidth int, HealthCheck string, ListenerPort int, LoadBalancerId, StickySession string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "SetLoadBalancerHTTPSListenerAttribute")
	args.Query.Set("HealthCheck", HealthCheck)
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	args.Query.Set("StickySession", StickySession)
	if Bandwidth < -1 {
		return nil, errors.New("Bandwidth must be equal or greater than -1")
	}
	if Bandwidth > 1000 {
		return nil, errors.New("Bandwidth must be equal or less than 1000")
	}
	args.Query.Set("Bandwidth", fmt.Sprint(Bandwidth))
	if ListenerPort < 1 {
		return nil, errors.New("ListenerPort must be equal or greater than 1")
	}
	if ListenerPort > 65535 {
		return nil, errors.New("ListenerPort must be equal or less than 65535")
	}
	args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
	if v, ok := optional["Cookie"]; ok {
		if Cookie, ok := v.(string); ok {
			args.Query.Set("Cookie", Cookie)
		} else {
			return nil, errors.New("Cookie must be string")
		}
	}
	if v, ok := optional["CookieTimeout"]; ok {
		if CookieTimeout, ok := v.(int); ok {
			if CookieTimeout < 1 {
				return nil, errors.New("CookieTimeout must be equal or greater than 1")
			}
			if CookieTimeout > 86400 {
				return nil, errors.New("CookieTimeout must be equal or less than 86400")
			}
			args.Query.Set("CookieTimeout", fmt.Sprint(CookieTimeout))
		} else {
			return nil, errors.New("CookieTimeout must be int")
		}
	}
	if v, ok := optional["HealthCheckConnectPort"]; ok {
		if HealthCheckConnectPort, ok := v.(int); ok {
			if HealthCheckConnectPort < -520 {
				return nil, errors.New("HealthCheckConnectPort must be equal or greater than -520")
			}
			if HealthCheckConnectPort > 65535 {
				return nil, errors.New("HealthCheckConnectPort must be equal or less than 65535")
			}
			args.Query.Set("HealthCheckConnectPort", fmt.Sprint(HealthCheckConnectPort))
		} else {
			return nil, errors.New("HealthCheckConnectPort must be int")
		}
	}
	if v, ok := optional["HealthCheckDomain"]; ok {
		if HealthCheckDomain, ok := v.(string); ok {
			args.Query.Set("HealthCheckDomain", HealthCheckDomain)
		} else {
			return nil, errors.New("HealthCheckDomain must be string")
		}
	}
	if v, ok := optional["HealthCheckHttpCode"]; ok {
		if HealthCheckHttpCode, ok := v.(string); ok {
			args.Query.Set("HealthCheckHttpCode", HealthCheckHttpCode)
		} else {
			return nil, errors.New("HealthCheckHttpCode must be string")
		}
	}
	if v, ok := optional["HealthCheckInterval"]; ok {
		if HealthCheckInterval, ok := v.(int); ok {
			if HealthCheckInterval < 1 {
				return nil, errors.New("HealthCheckInterval must be equal or greater than 1")
			}
			if HealthCheckInterval > 5 {
				return nil, errors.New("HealthCheckInterval must be equal or less than 5")
			}
			args.Query.Set("HealthCheckInterval", fmt.Sprint(HealthCheckInterval))
		} else {
			return nil, errors.New("HealthCheckInterval must be int")
		}
	}
	if v, ok := optional["HealthCheckTimeout"]; ok {
		if HealthCheckTimeout, ok := v.(int); ok {
			if HealthCheckTimeout < 1 {
				return nil, errors.New("HealthCheckTimeout must be equal or greater than 1")
			}
			if HealthCheckTimeout > 50 {
				return nil, errors.New("HealthCheckTimeout must be equal or less than 50")
			}
			args.Query.Set("HealthCheckTimeout", fmt.Sprint(HealthCheckTimeout))
		} else {
			return nil, errors.New("HealthCheckTimeout must be int")
		}
	}
	if v, ok := optional["HealthCheckURI"]; ok {
		if HealthCheckURI, ok := v.(string); ok {
			args.Query.Set("HealthCheckURI", HealthCheckURI)
		} else {
			return nil, errors.New("HealthCheckURI must be string")
		}
	}
	if v, ok := optional["HealthyThreshold"]; ok {
		if HealthyThreshold, ok := v.(int); ok {
			if HealthyThreshold < 1 {
				return nil, errors.New("HealthyThreshold must be equal or greater than 1")
			}
			if HealthyThreshold > 10 {
				return nil, errors.New("HealthyThreshold must be equal or less than 10")
			}
			args.Query.Set("HealthyThreshold", fmt.Sprint(HealthyThreshold))
		} else {
			return nil, errors.New("HealthyThreshold must be int")
		}
	}
	if v, ok := optional["MaxConnLimit"]; ok {
		if MaxConnLimit, ok := v.(int); ok {
			args.Query.Set("MaxConnLimit", fmt.Sprint(MaxConnLimit))
		} else {
			return nil, errors.New("MaxConnLimit must be int")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["Scheduler"]; ok {
		if Scheduler, ok := v.(string); ok {
			args.Query.Set("Scheduler", Scheduler)
		} else {
			return nil, errors.New("Scheduler must be string")
		}
	}
	if v, ok := optional["ServerCertificateId"]; ok {
		if ServerCertificateId, ok := v.(string); ok {
			args.Query.Set("ServerCertificateId", ServerCertificateId)
		} else {
			return nil, errors.New("ServerCertificateId must be string")
		}
	}
	if v, ok := optional["StickySessionType"]; ok {
		if StickySessionType, ok := v.(string); ok {
			args.Query.Set("StickySessionType", StickySessionType)
		} else {
			return nil, errors.New("StickySessionType must be string")
		}
	}
	if v, ok := optional["UnhealthyThreshold"]; ok {
		if UnhealthyThreshold, ok := v.(int); ok {
			if UnhealthyThreshold < 1 {
				return nil, errors.New("UnhealthyThreshold must be equal or greater than 1")
			}
			if UnhealthyThreshold > 10 {
				return nil, errors.New("UnhealthyThreshold must be equal or less than 10")
			}
			args.Query.Set("UnhealthyThreshold", fmt.Sprint(UnhealthyThreshold))
		} else {
			return nil, errors.New("UnhealthyThreshold must be int")
		}
	}
	if v, ok := optional["XForwardedFor"]; ok {
		if XForwardedFor, ok := v.(string); ok {
			args.Query.Set("XForwardedFor", XForwardedFor)
		} else {
			return nil, errors.New("XForwardedFor must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// SetLoadBalancerName version 2014-05-15
//
// required parameters:
//  name: LoadBalancerId, type: string
//  name: LoadBalancerName, type: string
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) SetLoadBalancerName(LoadBalancerId, LoadBalancerName string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "SetLoadBalancerName")
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	args.Query.Set("LoadBalancerName", LoadBalancerName)
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// SetLoadBalancerStatus version 2014-05-15
//
// required parameters:
//  name: LoadBalancerId, type: string
//  name: LoadBalancerStatus, type: string
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) SetLoadBalancerStatus(LoadBalancerId, LoadBalancerStatus string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "SetLoadBalancerStatus")
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	args.Query.Set("LoadBalancerStatus", LoadBalancerStatus)
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// SetLoadBalancerTCPListenerAttribute version 2014-05-15
//
// required parameters:
//  name: Bandwidth, type: int, min value: -1, max value: 1000
//  name: ListenerPort, type: int, min value: 1, max value: 65535
//  name: LoadBalancerId, type: string
//
// optional parameters:
//  name: HealthCheckConnectPort, type: int, min value: 1, max value: 65535
//  name: HealthCheckConnectTimeout, type: int, min value: 1, max value: 50
//  name: HealthCheckDomain, type: string
//  name: HealthCheckHttpCode, type: string
//  name: HealthCheckInterval, type: int, min value: 1, max value: 5
//  name: HealthCheckType, type: string
//  name: HealthCheckURI, type: string
//  name: HealthyThreshold, type: int, min value: 1, max value: 10
//  name: MaxConnLimit, type: int
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: PersistenceTimeout, type: int, min value: 0, max value: 86400
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: Scheduler, type: string
//  name: SynProxy, type: string
//  name: UnhealthyThreshold, type: int, min value: 1, max value: 10
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) SetLoadBalancerTCPListenerAttribute(Bandwidth, ListenerPort int, LoadBalancerId string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "SetLoadBalancerTCPListenerAttribute")
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	if Bandwidth < -1 {
		return nil, errors.New("Bandwidth must be equal or greater than -1")
	}
	if Bandwidth > 1000 {
		return nil, errors.New("Bandwidth must be equal or less than 1000")
	}
	args.Query.Set("Bandwidth", fmt.Sprint(Bandwidth))
	if ListenerPort < 1 {
		return nil, errors.New("ListenerPort must be equal or greater than 1")
	}
	if ListenerPort > 65535 {
		return nil, errors.New("ListenerPort must be equal or less than 65535")
	}
	args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
	if v, ok := optional["HealthCheckConnectPort"]; ok {
		if HealthCheckConnectPort, ok := v.(int); ok {
			if HealthCheckConnectPort < 1 {
				return nil, errors.New("HealthCheckConnectPort must be equal or greater than 1")
			}
			if HealthCheckConnectPort > 65535 {
				return nil, errors.New("HealthCheckConnectPort must be equal or less than 65535")
			}
			args.Query.Set("HealthCheckConnectPort", fmt.Sprint(HealthCheckConnectPort))
		} else {
			return nil, errors.New("HealthCheckConnectPort must be int")
		}
	}
	if v, ok := optional["HealthCheckConnectTimeout"]; ok {
		if HealthCheckConnectTimeout, ok := v.(int); ok {
			if HealthCheckConnectTimeout < 1 {
				return nil, errors.New("HealthCheckConnectTimeout must be equal or greater than 1")
			}
			if HealthCheckConnectTimeout > 50 {
				return nil, errors.New("HealthCheckConnectTimeout must be equal or less than 50")
			}
			args.Query.Set("HealthCheckConnectTimeout", fmt.Sprint(HealthCheckConnectTimeout))
		} else {
			return nil, errors.New("HealthCheckConnectTimeout must be int")
		}
	}
	if v, ok := optional["HealthCheckDomain"]; ok {
		if HealthCheckDomain, ok := v.(string); ok {
			args.Query.Set("HealthCheckDomain", HealthCheckDomain)
		} else {
			return nil, errors.New("HealthCheckDomain must be string")
		}
	}
	if v, ok := optional["HealthCheckHttpCode"]; ok {
		if HealthCheckHttpCode, ok := v.(string); ok {
			args.Query.Set("HealthCheckHttpCode", HealthCheckHttpCode)
		} else {
			return nil, errors.New("HealthCheckHttpCode must be string")
		}
	}
	if v, ok := optional["HealthCheckInterval"]; ok {
		if HealthCheckInterval, ok := v.(int); ok {
			if HealthCheckInterval < 1 {
				return nil, errors.New("HealthCheckInterval must be equal or greater than 1")
			}
			if HealthCheckInterval > 5 {
				return nil, errors.New("HealthCheckInterval must be equal or less than 5")
			}
			args.Query.Set("HealthCheckInterval", fmt.Sprint(HealthCheckInterval))
		} else {
			return nil, errors.New("HealthCheckInterval must be int")
		}
	}
	if v, ok := optional["HealthCheckType"]; ok {
		if HealthCheckType, ok := v.(string); ok {
			args.Query.Set("HealthCheckType", HealthCheckType)
		} else {
			return nil, errors.New("HealthCheckType must be string")
		}
	}
	if v, ok := optional["HealthCheckURI"]; ok {
		if HealthCheckURI, ok := v.(string); ok {
			args.Query.Set("HealthCheckURI", HealthCheckURI)
		} else {
			return nil, errors.New("HealthCheckURI must be string")
		}
	}
	if v, ok := optional["HealthyThreshold"]; ok {
		if HealthyThreshold, ok := v.(int); ok {
			if HealthyThreshold < 1 {
				return nil, errors.New("HealthyThreshold must be equal or greater than 1")
			}
			if HealthyThreshold > 10 {
				return nil, errors.New("HealthyThreshold must be equal or less than 10")
			}
			args.Query.Set("HealthyThreshold", fmt.Sprint(HealthyThreshold))
		} else {
			return nil, errors.New("HealthyThreshold must be int")
		}
	}
	if v, ok := optional["MaxConnLimit"]; ok {
		if MaxConnLimit, ok := v.(int); ok {
			args.Query.Set("MaxConnLimit", fmt.Sprint(MaxConnLimit))
		} else {
			return nil, errors.New("MaxConnLimit must be int")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["PersistenceTimeout"]; ok {
		if PersistenceTimeout, ok := v.(int); ok {
			if PersistenceTimeout < 0 {
				return nil, errors.New("PersistenceTimeout must be equal or greater than 0")
			}
			if PersistenceTimeout > 86400 {
				return nil, errors.New("PersistenceTimeout must be equal or less than 86400")
			}
			args.Query.Set("PersistenceTimeout", fmt.Sprint(PersistenceTimeout))
		} else {
			return nil, errors.New("PersistenceTimeout must be int")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["Scheduler"]; ok {
		if Scheduler, ok := v.(string); ok {
			args.Query.Set("Scheduler", Scheduler)
		} else {
			return nil, errors.New("Scheduler must be string")
		}
	}
	if v, ok := optional["SynProxy"]; ok {
		if SynProxy, ok := v.(string); ok {
			args.Query.Set("SynProxy", SynProxy)
		} else {
			return nil, errors.New("SynProxy must be string")
		}
	}
	if v, ok := optional["UnhealthyThreshold"]; ok {
		if UnhealthyThreshold, ok := v.(int); ok {
			if UnhealthyThreshold < 1 {
				return nil, errors.New("UnhealthyThreshold must be equal or greater than 1")
			}
			if UnhealthyThreshold > 10 {
				return nil, errors.New("UnhealthyThreshold must be equal or less than 10")
			}
			args.Query.Set("UnhealthyThreshold", fmt.Sprint(UnhealthyThreshold))
		} else {
			return nil, errors.New("UnhealthyThreshold must be int")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// SetLoadBalancerUDPListenerAttribute version 2014-05-15
//
// required parameters:
//  name: Bandwidth, type: int, min value: -1, max value: 1000
//  name: ListenerPort, type: int, min value: 1, max value: 65535
//  name: LoadBalancerId, type: string
//
// optional parameters:
//  name: HealthCheckConnectPort, type: int, min value: 1, max value: 65535
//  name: HealthCheckConnectTimeout, type: int, min value: 1, max value: 50
//  name: HealthCheckInterval, type: int, min value: 1, max value: 5
//  name: HealthyThreshold, type: int, min value: 1, max value: 10
//  name: MaxConnLimit, type: int
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: PersistenceTimeout, type: int, min value: 0, max value: 86400
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: Scheduler, type: string
//  name: UnhealthyThreshold, type: int, min value: 1, max value: 10
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) SetLoadBalancerUDPListenerAttribute(Bandwidth, ListenerPort int, LoadBalancerId string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "SetLoadBalancerUDPListenerAttribute")
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	if Bandwidth < -1 {
		return nil, errors.New("Bandwidth must be equal or greater than -1")
	}
	if Bandwidth > 1000 {
		return nil, errors.New("Bandwidth must be equal or less than 1000")
	}
	args.Query.Set("Bandwidth", fmt.Sprint(Bandwidth))
	if ListenerPort < 1 {
		return nil, errors.New("ListenerPort must be equal or greater than 1")
	}
	if ListenerPort > 65535 {
		return nil, errors.New("ListenerPort must be equal or less than 65535")
	}
	args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
	if v, ok := optional["HealthCheckConnectPort"]; ok {
		if HealthCheckConnectPort, ok := v.(int); ok {
			if HealthCheckConnectPort < 1 {
				return nil, errors.New("HealthCheckConnectPort must be equal or greater than 1")
			}
			if HealthCheckConnectPort > 65535 {
				return nil, errors.New("HealthCheckConnectPort must be equal or less than 65535")
			}
			args.Query.Set("HealthCheckConnectPort", fmt.Sprint(HealthCheckConnectPort))
		} else {
			return nil, errors.New("HealthCheckConnectPort must be int")
		}
	}
	if v, ok := optional["HealthCheckConnectTimeout"]; ok {
		if HealthCheckConnectTimeout, ok := v.(int); ok {
			if HealthCheckConnectTimeout < 1 {
				return nil, errors.New("HealthCheckConnectTimeout must be equal or greater than 1")
			}
			if HealthCheckConnectTimeout > 50 {
				return nil, errors.New("HealthCheckConnectTimeout must be equal or less than 50")
			}
			args.Query.Set("HealthCheckConnectTimeout", fmt.Sprint(HealthCheckConnectTimeout))
		} else {
			return nil, errors.New("HealthCheckConnectTimeout must be int")
		}
	}
	if v, ok := optional["HealthCheckInterval"]; ok {
		if HealthCheckInterval, ok := v.(int); ok {
			if HealthCheckInterval < 1 {
				return nil, errors.New("HealthCheckInterval must be equal or greater than 1")
			}
			if HealthCheckInterval > 5 {
				return nil, errors.New("HealthCheckInterval must be equal or less than 5")
			}
			args.Query.Set("HealthCheckInterval", fmt.Sprint(HealthCheckInterval))
		} else {
			return nil, errors.New("HealthCheckInterval must be int")
		}
	}
	if v, ok := optional["HealthyThreshold"]; ok {
		if HealthyThreshold, ok := v.(int); ok {
			if HealthyThreshold < 1 {
				return nil, errors.New("HealthyThreshold must be equal or greater than 1")
			}
			if HealthyThreshold > 10 {
				return nil, errors.New("HealthyThreshold must be equal or less than 10")
			}
			args.Query.Set("HealthyThreshold", fmt.Sprint(HealthyThreshold))
		} else {
			return nil, errors.New("HealthyThreshold must be int")
		}
	}
	if v, ok := optional["MaxConnLimit"]; ok {
		if MaxConnLimit, ok := v.(int); ok {
			args.Query.Set("MaxConnLimit", fmt.Sprint(MaxConnLimit))
		} else {
			return nil, errors.New("MaxConnLimit must be int")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["PersistenceTimeout"]; ok {
		if PersistenceTimeout, ok := v.(int); ok {
			if PersistenceTimeout < 0 {
				return nil, errors.New("PersistenceTimeout must be equal or greater than 0")
			}
			if PersistenceTimeout > 86400 {
				return nil, errors.New("PersistenceTimeout must be equal or less than 86400")
			}
			args.Query.Set("PersistenceTimeout", fmt.Sprint(PersistenceTimeout))
		} else {
			return nil, errors.New("PersistenceTimeout must be int")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["Scheduler"]; ok {
		if Scheduler, ok := v.(string); ok {
			args.Query.Set("Scheduler", Scheduler)
		} else {
			return nil, errors.New("Scheduler must be string")
		}
	}
	if v, ok := optional["UnhealthyThreshold"]; ok {
		if UnhealthyThreshold, ok := v.(int); ok {
			if UnhealthyThreshold < 1 {
				return nil, errors.New("UnhealthyThreshold must be equal or greater than 1")
			}
			if UnhealthyThreshold > 10 {
				return nil, errors.New("UnhealthyThreshold must be equal or less than 10")
			}
			args.Query.Set("UnhealthyThreshold", fmt.Sprint(UnhealthyThreshold))
		} else {
			return nil, errors.New("UnhealthyThreshold must be int")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// SetServerCertificateName version 2014-05-15
//
// required parameters:
//  name: ServerCertificateId, type: string
//  name: ServerCertificateName, type: string
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) SetServerCertificateName(ServerCertificateId, ServerCertificateName string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "SetServerCertificateName")
	args.Query.Set("ServerCertificateId", ServerCertificateId)
	args.Query.Set("ServerCertificateName", ServerCertificateName)
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// StartLoadBalancerListener version 2014-05-15
//
// required parameters:
//  name: ListenerPort, type: int, min value: 1, max value: 65535
//  name: LoadBalancerId, type: string
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) StartLoadBalancerListener(ListenerPort int, LoadBalancerId string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "StartLoadBalancerListener")
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	if ListenerPort < 1 {
		return nil, errors.New("ListenerPort must be equal or greater than 1")
	}
	if ListenerPort > 65535 {
		return nil, errors.New("ListenerPort must be equal or less than 65535")
	}
	args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// StopLoadBalancerListener version 2014-05-15
//
// required parameters:
//  name: ListenerPort, type: int, min value: 1, max value: 65535
//  name: LoadBalancerId, type: string
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) StopLoadBalancerListener(ListenerPort int, LoadBalancerId string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "StopLoadBalancerListener")
	args.Query.Set("LoadBalancerId", LoadBalancerId)
	if ListenerPort < 1 {
		return nil, errors.New("ListenerPort must be equal or greater than 1")
	}
	if ListenerPort > 65535 {
		return nil, errors.New("ListenerPort must be equal or less than 65535")
	}
	args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// UploadServerCertificate version 2014-05-15
//
// required parameters:
//  name: PrivateKey, type: string
//  name: ServerCertificate, type: string
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: ServerCertificateName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) UploadServerCertificate(PrivateKey, ServerCertificate string, optional openapi.M) (*UploadServerCertificateResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "UploadServerCertificate")
	args.Query.Set("PrivateKey", PrivateKey)
	args.Query.Set("ServerCertificate", ServerCertificate)
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["ServerCertificateName"]; ok {
		if ServerCertificateName, ok := v.(string); ok {
			args.Query.Set("ServerCertificateName", ServerCertificateName)
		} else {
			return nil, errors.New("ServerCertificateName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(UploadServerCertificateResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// UploadServerCertificateResponse represents the response of the api UploadServerCertificate.
type UploadServerCertificateResponse struct {
	Fingerprint           string
	RegionId              string
	RegionIdAlias         string
	ServerCertificateId   string
	ServerCertificateName string
}
