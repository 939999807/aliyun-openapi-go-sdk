// Copyright 2015 Chen Xianren. All rights reserved.
// Code generated by openapi-meta; DO NOT EDIT

package slb // import "github.com/cxr29/aliyun-openapi-go-sdk/apis/slb/v20130221"

import (
	"errors"
	"fmt"

	"github.com/cxr29/aliyun-openapi-go-sdk"
)

var (
	_ = errors.New("")
	_ = fmt.Sprint("")
)

type API struct {
	openapi.Service
}

func New(accessKeyId, accessKeySecret string) API {
	return API{openapi.NewService(accessKeyId, accessKeySecret)}
}

func NewParams() openapi.Params {
	args := openapi.NewParams()
	args.Product = Product
	args.Style = Style
	args.Version = Version
	return args
}

const (
	Product = "Slb"
	Style   = "RPC"
	Version = "2013-02-21"
)

// AddBackendServers version 2013-02-21
//
// optional parameters:
//  name: BackendServers, type: string
//  name: HostId, type: string
//  name: LoadBalancerId, type: string
//  name: OwnerAccount, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) AddBackendServers(optional openapi.M) (*AddBackendServersResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "AddBackendServers")
	if v, ok := optional["BackendServers"]; ok {
		if BackendServers, ok := v.(string); ok {
			args.Query.Set("BackendServers", BackendServers)
		} else {
			return nil, errors.New("BackendServers must be string")
		}
	}
	if v, ok := optional["HostId"]; ok {
		if HostId, ok := v.(string); ok {
			args.Query.Set("HostId", HostId)
		} else {
			return nil, errors.New("HostId must be string")
		}
	}
	if v, ok := optional["LoadBalancerId"]; ok {
		if LoadBalancerId, ok := v.(string); ok {
			args.Query.Set("LoadBalancerId", LoadBalancerId)
		} else {
			return nil, errors.New("LoadBalancerId must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(AddBackendServersResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// AddBackendServersResponse represents the response of the api AddBackendServers.
type AddBackendServersResponse struct {
	BackendServers struct {
		BackendServer []struct {
			ServerId string
			Weight   int
		}
	}
	LoadBalancerId string
}

// CreateLoadBalancer version 2013-02-21
//
// optional parameters:
//  name: Address, type: string
//  name: ClientToken, type: string
//  name: IsPublicAddress, type: string
//  name: LoadBalancerMode, type: string
//  name: LoadBalancerName, type: string
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) CreateLoadBalancer(optional openapi.M) (*CreateLoadBalancerResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateLoadBalancer")
	if v, ok := optional["Address"]; ok {
		if Address, ok := v.(string); ok {
			args.Query.Set("Address", Address)
		} else {
			return nil, errors.New("Address must be string")
		}
	}
	if v, ok := optional["ClientToken"]; ok {
		if ClientToken, ok := v.(string); ok {
			args.Query.Set("ClientToken", ClientToken)
		} else {
			return nil, errors.New("ClientToken must be string")
		}
	}
	if v, ok := optional["IsPublicAddress"]; ok {
		if IsPublicAddress, ok := v.(string); ok {
			args.Query.Set("IsPublicAddress", IsPublicAddress)
		} else {
			return nil, errors.New("IsPublicAddress must be string")
		}
	}
	if v, ok := optional["LoadBalancerMode"]; ok {
		if LoadBalancerMode, ok := v.(string); ok {
			args.Query.Set("LoadBalancerMode", LoadBalancerMode)
		} else {
			return nil, errors.New("LoadBalancerMode must be string")
		}
	}
	if v, ok := optional["LoadBalancerName"]; ok {
		if LoadBalancerName, ok := v.(string); ok {
			args.Query.Set("LoadBalancerName", LoadBalancerName)
		} else {
			return nil, errors.New("LoadBalancerName must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(CreateLoadBalancerResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateLoadBalancerResponse represents the response of the api CreateLoadBalancer.
type CreateLoadBalancerResponse struct {
	Address          string
	LoadBalancerId   string
	LoadBalancerName string
}

// CreateLoadBalancerHTTPListener version 2013-02-21
//
// optional parameters:
//  name: BackendServerPort, type: int
//  name: Cookie, type: string
//  name: CookieTimeout, type: int
//  name: Domain, type: string
//  name: HealthCheck, type: string
//  name: HealthCheckTimeout, type: int
//  name: HealthyThreshold, type: int
//  name: HostId, type: string
//  name: Interval, type: int
//  name: ListenerPort, type: int
//  name: ListenerStatus, type: string
//  name: LoadBalancerId, type: string
//  name: OwnerAccount, type: string
//  name: Scheduler, type: string
//  name: StickySession, type: string
//  name: StickySessionType, type: string
//  name: URI, type: string
//  name: UnhealthyThreshold, type: int
//  name: XForwardedFor, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) CreateLoadBalancerHTTPListener(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateLoadBalancerHTTPListener")
	if v, ok := optional["BackendServerPort"]; ok {
		if BackendServerPort, ok := v.(int); ok {
			args.Query.Set("BackendServerPort", fmt.Sprint(BackendServerPort))
		} else {
			return nil, errors.New("BackendServerPort must be int")
		}
	}
	if v, ok := optional["Cookie"]; ok {
		if Cookie, ok := v.(string); ok {
			args.Query.Set("Cookie", Cookie)
		} else {
			return nil, errors.New("Cookie must be string")
		}
	}
	if v, ok := optional["CookieTimeout"]; ok {
		if CookieTimeout, ok := v.(int); ok {
			args.Query.Set("CookieTimeout", fmt.Sprint(CookieTimeout))
		} else {
			return nil, errors.New("CookieTimeout must be int")
		}
	}
	if v, ok := optional["Domain"]; ok {
		if Domain, ok := v.(string); ok {
			args.Query.Set("Domain", Domain)
		} else {
			return nil, errors.New("Domain must be string")
		}
	}
	if v, ok := optional["HealthCheck"]; ok {
		if HealthCheck, ok := v.(string); ok {
			args.Query.Set("HealthCheck", HealthCheck)
		} else {
			return nil, errors.New("HealthCheck must be string")
		}
	}
	if v, ok := optional["HealthCheckTimeout"]; ok {
		if HealthCheckTimeout, ok := v.(int); ok {
			args.Query.Set("HealthCheckTimeout", fmt.Sprint(HealthCheckTimeout))
		} else {
			return nil, errors.New("HealthCheckTimeout must be int")
		}
	}
	if v, ok := optional["HealthyThreshold"]; ok {
		if HealthyThreshold, ok := v.(int); ok {
			args.Query.Set("HealthyThreshold", fmt.Sprint(HealthyThreshold))
		} else {
			return nil, errors.New("HealthyThreshold must be int")
		}
	}
	if v, ok := optional["HostId"]; ok {
		if HostId, ok := v.(string); ok {
			args.Query.Set("HostId", HostId)
		} else {
			return nil, errors.New("HostId must be string")
		}
	}
	if v, ok := optional["Interval"]; ok {
		if Interval, ok := v.(int); ok {
			args.Query.Set("Interval", fmt.Sprint(Interval))
		} else {
			return nil, errors.New("Interval must be int")
		}
	}
	if v, ok := optional["ListenerPort"]; ok {
		if ListenerPort, ok := v.(int); ok {
			args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
		} else {
			return nil, errors.New("ListenerPort must be int")
		}
	}
	if v, ok := optional["ListenerStatus"]; ok {
		if ListenerStatus, ok := v.(string); ok {
			args.Query.Set("ListenerStatus", ListenerStatus)
		} else {
			return nil, errors.New("ListenerStatus must be string")
		}
	}
	if v, ok := optional["LoadBalancerId"]; ok {
		if LoadBalancerId, ok := v.(string); ok {
			args.Query.Set("LoadBalancerId", LoadBalancerId)
		} else {
			return nil, errors.New("LoadBalancerId must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["Scheduler"]; ok {
		if Scheduler, ok := v.(string); ok {
			args.Query.Set("Scheduler", Scheduler)
		} else {
			return nil, errors.New("Scheduler must be string")
		}
	}
	if v, ok := optional["StickySession"]; ok {
		if StickySession, ok := v.(string); ok {
			args.Query.Set("StickySession", StickySession)
		} else {
			return nil, errors.New("StickySession must be string")
		}
	}
	if v, ok := optional["StickySessionType"]; ok {
		if StickySessionType, ok := v.(string); ok {
			args.Query.Set("StickySessionType", StickySessionType)
		} else {
			return nil, errors.New("StickySessionType must be string")
		}
	}
	if v, ok := optional["URI"]; ok {
		if URI, ok := v.(string); ok {
			args.Query.Set("URI", URI)
		} else {
			return nil, errors.New("URI must be string")
		}
	}
	if v, ok := optional["UnhealthyThreshold"]; ok {
		if UnhealthyThreshold, ok := v.(int); ok {
			args.Query.Set("UnhealthyThreshold", fmt.Sprint(UnhealthyThreshold))
		} else {
			return nil, errors.New("UnhealthyThreshold must be int")
		}
	}
	if v, ok := optional["XForwardedFor"]; ok {
		if XForwardedFor, ok := v.(string); ok {
			args.Query.Set("XForwardedFor", XForwardedFor)
		} else {
			return nil, errors.New("XForwardedFor must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateLoadBalancerTCPListener version 2013-02-21
//
// optional parameters:
//  name: BackendServerPort, type: int
//  name: ConnectPort, type: int
//  name: ConnectTimeout, type: int
//  name: HealthCheck, type: string
//  name: HostId, type: string
//  name: Interval, type: int
//  name: ListenerPort, type: int
//  name: ListenerStatus, type: string
//  name: LoadBalancerId, type: string
//  name: OwnerAccount, type: string
//  name: PersistenceTimeout, type: int
//  name: Scheduler, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) CreateLoadBalancerTCPListener(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateLoadBalancerTCPListener")
	if v, ok := optional["BackendServerPort"]; ok {
		if BackendServerPort, ok := v.(int); ok {
			args.Query.Set("BackendServerPort", fmt.Sprint(BackendServerPort))
		} else {
			return nil, errors.New("BackendServerPort must be int")
		}
	}
	if v, ok := optional["ConnectPort"]; ok {
		if ConnectPort, ok := v.(int); ok {
			args.Query.Set("ConnectPort", fmt.Sprint(ConnectPort))
		} else {
			return nil, errors.New("ConnectPort must be int")
		}
	}
	if v, ok := optional["ConnectTimeout"]; ok {
		if ConnectTimeout, ok := v.(int); ok {
			args.Query.Set("ConnectTimeout", fmt.Sprint(ConnectTimeout))
		} else {
			return nil, errors.New("ConnectTimeout must be int")
		}
	}
	if v, ok := optional["HealthCheck"]; ok {
		if HealthCheck, ok := v.(string); ok {
			args.Query.Set("HealthCheck", HealthCheck)
		} else {
			return nil, errors.New("HealthCheck must be string")
		}
	}
	if v, ok := optional["HostId"]; ok {
		if HostId, ok := v.(string); ok {
			args.Query.Set("HostId", HostId)
		} else {
			return nil, errors.New("HostId must be string")
		}
	}
	if v, ok := optional["Interval"]; ok {
		if Interval, ok := v.(int); ok {
			args.Query.Set("Interval", fmt.Sprint(Interval))
		} else {
			return nil, errors.New("Interval must be int")
		}
	}
	if v, ok := optional["ListenerPort"]; ok {
		if ListenerPort, ok := v.(int); ok {
			args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
		} else {
			return nil, errors.New("ListenerPort must be int")
		}
	}
	if v, ok := optional["ListenerStatus"]; ok {
		if ListenerStatus, ok := v.(string); ok {
			args.Query.Set("ListenerStatus", ListenerStatus)
		} else {
			return nil, errors.New("ListenerStatus must be string")
		}
	}
	if v, ok := optional["LoadBalancerId"]; ok {
		if LoadBalancerId, ok := v.(string); ok {
			args.Query.Set("LoadBalancerId", LoadBalancerId)
		} else {
			return nil, errors.New("LoadBalancerId must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["PersistenceTimeout"]; ok {
		if PersistenceTimeout, ok := v.(int); ok {
			args.Query.Set("PersistenceTimeout", fmt.Sprint(PersistenceTimeout))
		} else {
			return nil, errors.New("PersistenceTimeout must be int")
		}
	}
	if v, ok := optional["Scheduler"]; ok {
		if Scheduler, ok := v.(string); ok {
			args.Query.Set("Scheduler", Scheduler)
		} else {
			return nil, errors.New("Scheduler must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteLoadBalancer version 2013-02-21
//
// optional parameters:
//  name: LoadBalancerId, type: string
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DeleteLoadBalancer(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteLoadBalancer")
	if v, ok := optional["LoadBalancerId"]; ok {
		if LoadBalancerId, ok := v.(string); ok {
			args.Query.Set("LoadBalancerId", LoadBalancerId)
		} else {
			return nil, errors.New("LoadBalancerId must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteLoadBalancerListener version 2013-02-21
//
// optional parameters:
//  name: HostId, type: string
//  name: ListenerPort, type: []string
//  name: LoadBalancerId, type: string
//  name: OwnerAccount, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DeleteLoadBalancerListener(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteLoadBalancerListener")
	if v, ok := optional["HostId"]; ok {
		if HostId, ok := v.(string); ok {
			args.Query.Set("HostId", HostId)
		} else {
			return nil, errors.New("HostId must be string")
		}
	}
	if v, ok := optional["ListenerPort"]; ok {
		if ListenerPort, ok := v.([]string); ok {
			args.Query["ListenerPort"] = ListenerPort
		} else {
			return nil, errors.New("ListenerPort must be []string")
		}
	}
	if v, ok := optional["LoadBalancerId"]; ok {
		if LoadBalancerId, ok := v.(string); ok {
			args.Query.Set("LoadBalancerId", LoadBalancerId)
		} else {
			return nil, errors.New("LoadBalancerId must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeBackendServers version 2013-02-21
//
// optional parameters:
//  name: HostId, type: string
//  name: ListenerPort, type: int
//  name: LoadBalancerId, type: string
//  name: OwnerAccount, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DescribeBackendServers(optional openapi.M) (*DescribeBackendServersResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DescribeBackendServers")
	if v, ok := optional["HostId"]; ok {
		if HostId, ok := v.(string); ok {
			args.Query.Set("HostId", HostId)
		} else {
			return nil, errors.New("HostId must be string")
		}
	}
	if v, ok := optional["ListenerPort"]; ok {
		if ListenerPort, ok := v.(int); ok {
			args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
		} else {
			return nil, errors.New("ListenerPort must be int")
		}
	}
	if v, ok := optional["LoadBalancerId"]; ok {
		if LoadBalancerId, ok := v.(string); ok {
			args.Query.Set("LoadBalancerId", LoadBalancerId)
		} else {
			return nil, errors.New("LoadBalancerId must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DescribeBackendServersResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeBackendServersResponse represents the response of the api DescribeBackendServers.
type DescribeBackendServersResponse struct {
	Listeners struct {
		Listener []struct {
			BackendServers struct {
				BackendServer []struct {
					ServerHealthStatus string
					ServerId           string
				}
			}
			ListenerPort int
		}
	}
}

// DescribeLoadBalancerAttribute version 2013-02-21
//
// optional parameters:
//  name: HostId, type: string
//  name: LoadBalancerId, type: string
//  name: OwnerAccount, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DescribeLoadBalancerAttribute(optional openapi.M) (*DescribeLoadBalancerAttributeResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DescribeLoadBalancerAttribute")
	if v, ok := optional["HostId"]; ok {
		if HostId, ok := v.(string); ok {
			args.Query.Set("HostId", HostId)
		} else {
			return nil, errors.New("HostId must be string")
		}
	}
	if v, ok := optional["LoadBalancerId"]; ok {
		if LoadBalancerId, ok := v.(string); ok {
			args.Query.Set("LoadBalancerId", LoadBalancerId)
		} else {
			return nil, errors.New("LoadBalancerId must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DescribeLoadBalancerAttributeResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeLoadBalancerAttributeResponse represents the response of the api DescribeLoadBalancerAttribute.
type DescribeLoadBalancerAttributeResponse struct {
	Address        string
	BackendServers struct {
		BackendServer []struct {
			ServerId string
			Weight   int
		}
	}
	IsPublicAddress    string
	LoadBalancerId     string
	LoadBalancerName   string
	LoadBalancerStatus string
	RegionId           string
}

// DescribeLoadBalancerHTTPListenerAttribute version 2013-02-21
//
// optional parameters:
//  name: HostId, type: string
//  name: ListenerPort, type: int
//  name: LoadBalancerId, type: string
//  name: OwnerAccount, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DescribeLoadBalancerHTTPListenerAttribute(optional openapi.M) (*DescribeLoadBalancerHTTPListenerAttributeResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DescribeLoadBalancerHTTPListenerAttribute")
	if v, ok := optional["HostId"]; ok {
		if HostId, ok := v.(string); ok {
			args.Query.Set("HostId", HostId)
		} else {
			return nil, errors.New("HostId must be string")
		}
	}
	if v, ok := optional["ListenerPort"]; ok {
		if ListenerPort, ok := v.(int); ok {
			args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
		} else {
			return nil, errors.New("ListenerPort must be int")
		}
	}
	if v, ok := optional["LoadBalancerId"]; ok {
		if LoadBalancerId, ok := v.(string); ok {
			args.Query.Set("LoadBalancerId", LoadBalancerId)
		} else {
			return nil, errors.New("LoadBalancerId must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DescribeLoadBalancerHTTPListenerAttributeResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeLoadBalancerHTTPListenerAttributeResponse represents the response of the api DescribeLoadBalancerHTTPListenerAttribute.
type DescribeLoadBalancerHTTPListenerAttributeResponse struct {
	BackendServerPort    int
	Cookie               string
	CookieTimeout        int
	Domain               string
	HealthCheck          string
	HealthCheckTimeout   int
	HealthyThreshold     int
	Interval             int
	ListenerPort         int
	Scheduler            string
	Status               string
	StickySession        string
	StickySessionapiType string
	URI                  string
	UnhealthyThreshold   int
	XForwardedFor        string
}

// DescribeLoadBalancerTCPListenerAttribute version 2013-02-21
//
// optional parameters:
//  name: HostId, type: string
//  name: ListenerPort, type: int
//  name: LoadBalancerId, type: string
//  name: OwnerAccount, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DescribeLoadBalancerTCPListenerAttribute(optional openapi.M) (*DescribeLoadBalancerTCPListenerAttributeResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DescribeLoadBalancerTCPListenerAttribute")
	if v, ok := optional["HostId"]; ok {
		if HostId, ok := v.(string); ok {
			args.Query.Set("HostId", HostId)
		} else {
			return nil, errors.New("HostId must be string")
		}
	}
	if v, ok := optional["ListenerPort"]; ok {
		if ListenerPort, ok := v.(int); ok {
			args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
		} else {
			return nil, errors.New("ListenerPort must be int")
		}
	}
	if v, ok := optional["LoadBalancerId"]; ok {
		if LoadBalancerId, ok := v.(string); ok {
			args.Query.Set("LoadBalancerId", LoadBalancerId)
		} else {
			return nil, errors.New("LoadBalancerId must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DescribeLoadBalancerTCPListenerAttributeResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeLoadBalancerTCPListenerAttributeResponse represents the response of the api DescribeLoadBalancerTCPListenerAttribute.
type DescribeLoadBalancerTCPListenerAttributeResponse struct {
	BackendServerPort  int
	ConnectPort        int
	ConnectTimeout     int
	HealthCheck        string
	HealthyThreshold   int
	Interval           int
	ListenerPort       int
	PersistenceTimeout int
	Scheduler          string
	Status             string
	UnhealthyThreshold int
}

// DescribeLoadBalancers version 2013-02-21
//
// optional parameters:
//  name: HostId, type: string
//  name: LoadBalancerId, type: string
//  name: OwnerAccount, type: string
//  name: ServerId, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DescribeLoadBalancers(optional openapi.M) (*DescribeLoadBalancersResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DescribeLoadBalancers")
	if v, ok := optional["HostId"]; ok {
		if HostId, ok := v.(string); ok {
			args.Query.Set("HostId", HostId)
		} else {
			return nil, errors.New("HostId must be string")
		}
	}
	if v, ok := optional["LoadBalancerId"]; ok {
		if LoadBalancerId, ok := v.(string); ok {
			args.Query.Set("LoadBalancerId", LoadBalancerId)
		} else {
			return nil, errors.New("LoadBalancerId must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["ServerId"]; ok {
		if ServerId, ok := v.(string); ok {
			args.Query.Set("ServerId", ServerId)
		} else {
			return nil, errors.New("ServerId must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DescribeLoadBalancersResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeLoadBalancersResponse represents the response of the api DescribeLoadBalancers.
type DescribeLoadBalancersResponse struct {
	LoadBalancers struct {
		LoadBalancer []struct {
			LoadBalancerId     string
			LoadBalancerName   string
			LoadBalancerStatus string
		}
	}
}

// DescribeRegions version 2013-02-21
//
// optional parameters:
//  name: HostId, type: string
//  name: OwnerAccount, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DescribeRegions(optional openapi.M) (*DescribeRegionsResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DescribeRegions")
	if v, ok := optional["HostId"]; ok {
		if HostId, ok := v.(string); ok {
			args.Query.Set("HostId", HostId)
		} else {
			return nil, errors.New("HostId must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DescribeRegionsResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeRegionsResponse represents the response of the api DescribeRegions.
type DescribeRegionsResponse struct {
	Regions struct {
		Region []struct {
			RegionId string
		}
	}
}

// RemoveBackendServers version 2013-02-21
//
// optional parameters:
//  name: BackendServers, type: string
//  name: HostId, type: string
//  name: LoadBalancerId, type: string
//  name: OwnerAccount, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) RemoveBackendServers(optional openapi.M) (*RemoveBackendServersResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "RemoveBackendServers")
	if v, ok := optional["BackendServers"]; ok {
		if BackendServers, ok := v.(string); ok {
			args.Query.Set("BackendServers", BackendServers)
		} else {
			return nil, errors.New("BackendServers must be string")
		}
	}
	if v, ok := optional["HostId"]; ok {
		if HostId, ok := v.(string); ok {
			args.Query.Set("HostId", HostId)
		} else {
			return nil, errors.New("HostId must be string")
		}
	}
	if v, ok := optional["LoadBalancerId"]; ok {
		if LoadBalancerId, ok := v.(string); ok {
			args.Query.Set("LoadBalancerId", LoadBalancerId)
		} else {
			return nil, errors.New("LoadBalancerId must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(RemoveBackendServersResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// RemoveBackendServersResponse represents the response of the api RemoveBackendServers.
type RemoveBackendServersResponse struct {
	BackendServers struct {
		BackendServer []struct {
			ServerId string
			Weight   int
		}
	}
	LoadBalancerId string
}

// SetLoadBalancerHTTPListenerAttribute version 2013-02-21
//
// optional parameters:
//  name: Cookie, type: string
//  name: CookieTimeout, type: int
//  name: Domain, type: string
//  name: HealthCheck, type: string
//  name: HealthCheckTimeout, type: int
//  name: HealthyThreshold, type: int
//  name: HostId, type: string
//  name: Interval, type: int
//  name: ListenerPort, type: int
//  name: LoadBalancerId, type: string
//  name: OwnerAccount, type: string
//  name: Scheduler, type: string
//  name: StickySession, type: string
//  name: StickySessionType, type: string
//  name: URI, type: string
//  name: UnhealthyThreshold, type: int
//  name: XForwardedFor, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) SetLoadBalancerHTTPListenerAttribute(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "SetLoadBalancerHTTPListenerAttribute")
	if v, ok := optional["Cookie"]; ok {
		if Cookie, ok := v.(string); ok {
			args.Query.Set("Cookie", Cookie)
		} else {
			return nil, errors.New("Cookie must be string")
		}
	}
	if v, ok := optional["CookieTimeout"]; ok {
		if CookieTimeout, ok := v.(int); ok {
			args.Query.Set("CookieTimeout", fmt.Sprint(CookieTimeout))
		} else {
			return nil, errors.New("CookieTimeout must be int")
		}
	}
	if v, ok := optional["Domain"]; ok {
		if Domain, ok := v.(string); ok {
			args.Query.Set("Domain", Domain)
		} else {
			return nil, errors.New("Domain must be string")
		}
	}
	if v, ok := optional["HealthCheck"]; ok {
		if HealthCheck, ok := v.(string); ok {
			args.Query.Set("HealthCheck", HealthCheck)
		} else {
			return nil, errors.New("HealthCheck must be string")
		}
	}
	if v, ok := optional["HealthCheckTimeout"]; ok {
		if HealthCheckTimeout, ok := v.(int); ok {
			args.Query.Set("HealthCheckTimeout", fmt.Sprint(HealthCheckTimeout))
		} else {
			return nil, errors.New("HealthCheckTimeout must be int")
		}
	}
	if v, ok := optional["HealthyThreshold"]; ok {
		if HealthyThreshold, ok := v.(int); ok {
			args.Query.Set("HealthyThreshold", fmt.Sprint(HealthyThreshold))
		} else {
			return nil, errors.New("HealthyThreshold must be int")
		}
	}
	if v, ok := optional["HostId"]; ok {
		if HostId, ok := v.(string); ok {
			args.Query.Set("HostId", HostId)
		} else {
			return nil, errors.New("HostId must be string")
		}
	}
	if v, ok := optional["Interval"]; ok {
		if Interval, ok := v.(int); ok {
			args.Query.Set("Interval", fmt.Sprint(Interval))
		} else {
			return nil, errors.New("Interval must be int")
		}
	}
	if v, ok := optional["ListenerPort"]; ok {
		if ListenerPort, ok := v.(int); ok {
			args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
		} else {
			return nil, errors.New("ListenerPort must be int")
		}
	}
	if v, ok := optional["LoadBalancerId"]; ok {
		if LoadBalancerId, ok := v.(string); ok {
			args.Query.Set("LoadBalancerId", LoadBalancerId)
		} else {
			return nil, errors.New("LoadBalancerId must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["Scheduler"]; ok {
		if Scheduler, ok := v.(string); ok {
			args.Query.Set("Scheduler", Scheduler)
		} else {
			return nil, errors.New("Scheduler must be string")
		}
	}
	if v, ok := optional["StickySession"]; ok {
		if StickySession, ok := v.(string); ok {
			args.Query.Set("StickySession", StickySession)
		} else {
			return nil, errors.New("StickySession must be string")
		}
	}
	if v, ok := optional["StickySessionType"]; ok {
		if StickySessionType, ok := v.(string); ok {
			args.Query.Set("StickySessionType", StickySessionType)
		} else {
			return nil, errors.New("StickySessionType must be string")
		}
	}
	if v, ok := optional["URI"]; ok {
		if URI, ok := v.(string); ok {
			args.Query.Set("URI", URI)
		} else {
			return nil, errors.New("URI must be string")
		}
	}
	if v, ok := optional["UnhealthyThreshold"]; ok {
		if UnhealthyThreshold, ok := v.(int); ok {
			args.Query.Set("UnhealthyThreshold", fmt.Sprint(UnhealthyThreshold))
		} else {
			return nil, errors.New("UnhealthyThreshold must be int")
		}
	}
	if v, ok := optional["XForwardedFor"]; ok {
		if XForwardedFor, ok := v.(string); ok {
			args.Query.Set("XForwardedFor", XForwardedFor)
		} else {
			return nil, errors.New("XForwardedFor must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// SetLoadBalancerListenerStatus version 2013-02-21
//
// optional parameters:
//  name: HostId, type: string
//  name: ListenerPort, type: int
//  name: ListenerStatus, type: string
//  name: LoadBalancerId, type: string
//  name: OwnerAccount, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) SetLoadBalancerListenerStatus(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "SetLoadBalancerListenerStatus")
	if v, ok := optional["HostId"]; ok {
		if HostId, ok := v.(string); ok {
			args.Query.Set("HostId", HostId)
		} else {
			return nil, errors.New("HostId must be string")
		}
	}
	if v, ok := optional["ListenerPort"]; ok {
		if ListenerPort, ok := v.(int); ok {
			args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
		} else {
			return nil, errors.New("ListenerPort must be int")
		}
	}
	if v, ok := optional["ListenerStatus"]; ok {
		if ListenerStatus, ok := v.(string); ok {
			args.Query.Set("ListenerStatus", ListenerStatus)
		} else {
			return nil, errors.New("ListenerStatus must be string")
		}
	}
	if v, ok := optional["LoadBalancerId"]; ok {
		if LoadBalancerId, ok := v.(string); ok {
			args.Query.Set("LoadBalancerId", LoadBalancerId)
		} else {
			return nil, errors.New("LoadBalancerId must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// SetLoadBalancerName version 2013-02-21
//
// optional parameters:
//  name: HostId, type: string
//  name: LoadBalancerId, type: string
//  name: LoadBalancerName, type: string
//  name: OwnerAccount, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) SetLoadBalancerName(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "SetLoadBalancerName")
	if v, ok := optional["HostId"]; ok {
		if HostId, ok := v.(string); ok {
			args.Query.Set("HostId", HostId)
		} else {
			return nil, errors.New("HostId must be string")
		}
	}
	if v, ok := optional["LoadBalancerId"]; ok {
		if LoadBalancerId, ok := v.(string); ok {
			args.Query.Set("LoadBalancerId", LoadBalancerId)
		} else {
			return nil, errors.New("LoadBalancerId must be string")
		}
	}
	if v, ok := optional["LoadBalancerName"]; ok {
		if LoadBalancerName, ok := v.(string); ok {
			args.Query.Set("LoadBalancerName", LoadBalancerName)
		} else {
			return nil, errors.New("LoadBalancerName must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// SetLoadBalancerStatus version 2013-02-21
//
// optional parameters:
//  name: HostId, type: string
//  name: LoadBalancerId, type: string
//  name: LoadBalancerStatus, type: string
//  name: OwnerAccount, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) SetLoadBalancerStatus(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "SetLoadBalancerStatus")
	if v, ok := optional["HostId"]; ok {
		if HostId, ok := v.(string); ok {
			args.Query.Set("HostId", HostId)
		} else {
			return nil, errors.New("HostId must be string")
		}
	}
	if v, ok := optional["LoadBalancerId"]; ok {
		if LoadBalancerId, ok := v.(string); ok {
			args.Query.Set("LoadBalancerId", LoadBalancerId)
		} else {
			return nil, errors.New("LoadBalancerId must be string")
		}
	}
	if v, ok := optional["LoadBalancerStatus"]; ok {
		if LoadBalancerStatus, ok := v.(string); ok {
			args.Query.Set("LoadBalancerStatus", LoadBalancerStatus)
		} else {
			return nil, errors.New("LoadBalancerStatus must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// SetLoadBalancerTCPListenerAttribute version 2013-02-21
//
// optional parameters:
//  name: ConnectPort, type: int
//  name: ConnectTimeout, type: int
//  name: HealthCheck, type: string
//  name: HealthyThreshold, type: int, min value: 1, max value: 10
//  name: HostId, type: string
//  name: Interval, type: int
//  name: ListenerPort, type: int
//  name: LoadBalancerId, type: string
//  name: OwnerAccount, type: string
//  name: PersistenceTimeout, type: int
//  name: Scheduler, type: string
//  name: UnhealthyThreshold, type: int, min value: 1, max value: 10
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) SetLoadBalancerTCPListenerAttribute(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "SetLoadBalancerTCPListenerAttribute")
	if v, ok := optional["ConnectPort"]; ok {
		if ConnectPort, ok := v.(int); ok {
			args.Query.Set("ConnectPort", fmt.Sprint(ConnectPort))
		} else {
			return nil, errors.New("ConnectPort must be int")
		}
	}
	if v, ok := optional["ConnectTimeout"]; ok {
		if ConnectTimeout, ok := v.(int); ok {
			args.Query.Set("ConnectTimeout", fmt.Sprint(ConnectTimeout))
		} else {
			return nil, errors.New("ConnectTimeout must be int")
		}
	}
	if v, ok := optional["HealthCheck"]; ok {
		if HealthCheck, ok := v.(string); ok {
			args.Query.Set("HealthCheck", HealthCheck)
		} else {
			return nil, errors.New("HealthCheck must be string")
		}
	}
	if v, ok := optional["HealthyThreshold"]; ok {
		if HealthyThreshold, ok := v.(int); ok {
			if HealthyThreshold < 1 {
				return nil, errors.New("HealthyThreshold must be equal or greater than 1")
			}
			if HealthyThreshold > 10 {
				return nil, errors.New("HealthyThreshold must be equal or less than 10")
			}
			args.Query.Set("HealthyThreshold", fmt.Sprint(HealthyThreshold))
		} else {
			return nil, errors.New("HealthyThreshold must be int")
		}
	}
	if v, ok := optional["HostId"]; ok {
		if HostId, ok := v.(string); ok {
			args.Query.Set("HostId", HostId)
		} else {
			return nil, errors.New("HostId must be string")
		}
	}
	if v, ok := optional["Interval"]; ok {
		if Interval, ok := v.(int); ok {
			args.Query.Set("Interval", fmt.Sprint(Interval))
		} else {
			return nil, errors.New("Interval must be int")
		}
	}
	if v, ok := optional["ListenerPort"]; ok {
		if ListenerPort, ok := v.(int); ok {
			args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
		} else {
			return nil, errors.New("ListenerPort must be int")
		}
	}
	if v, ok := optional["LoadBalancerId"]; ok {
		if LoadBalancerId, ok := v.(string); ok {
			args.Query.Set("LoadBalancerId", LoadBalancerId)
		} else {
			return nil, errors.New("LoadBalancerId must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["PersistenceTimeout"]; ok {
		if PersistenceTimeout, ok := v.(int); ok {
			args.Query.Set("PersistenceTimeout", fmt.Sprint(PersistenceTimeout))
		} else {
			return nil, errors.New("PersistenceTimeout must be int")
		}
	}
	if v, ok := optional["Scheduler"]; ok {
		if Scheduler, ok := v.(string); ok {
			args.Query.Set("Scheduler", Scheduler)
		} else {
			return nil, errors.New("Scheduler must be string")
		}
	}
	if v, ok := optional["UnhealthyThreshold"]; ok {
		if UnhealthyThreshold, ok := v.(int); ok {
			if UnhealthyThreshold < 1 {
				return nil, errors.New("UnhealthyThreshold must be equal or greater than 1")
			}
			if UnhealthyThreshold > 10 {
				return nil, errors.New("UnhealthyThreshold must be equal or less than 10")
			}
			args.Query.Set("UnhealthyThreshold", fmt.Sprint(UnhealthyThreshold))
		} else {
			return nil, errors.New("UnhealthyThreshold must be int")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// SetLoadBanancerListenerStatus version 2013-02-21
//
// optional parameters:
//  name: HostId, type: string
//  name: ListenerPort, type: int
//  name: ListenerStatus, type: string
//  name: LoadBalancerId, type: string
//  name: OwnerAccount, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) SetLoadBanancerListenerStatus(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "SetLoadBanancerListenerStatus")
	if v, ok := optional["HostId"]; ok {
		if HostId, ok := v.(string); ok {
			args.Query.Set("HostId", HostId)
		} else {
			return nil, errors.New("HostId must be string")
		}
	}
	if v, ok := optional["ListenerPort"]; ok {
		if ListenerPort, ok := v.(int); ok {
			args.Query.Set("ListenerPort", fmt.Sprint(ListenerPort))
		} else {
			return nil, errors.New("ListenerPort must be int")
		}
	}
	if v, ok := optional["ListenerStatus"]; ok {
		if ListenerStatus, ok := v.(string); ok {
			args.Query.Set("ListenerStatus", ListenerStatus)
		} else {
			return nil, errors.New("ListenerStatus must be string")
		}
	}
	if v, ok := optional["LoadBalancerId"]; ok {
		if LoadBalancerId, ok := v.(string); ok {
			args.Query.Set("LoadBalancerId", LoadBalancerId)
		} else {
			return nil, errors.New("LoadBalancerId must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}
