// Copyright 2015 Chen Xianren. All rights reserved.
// Code generated by openapi-meta; DO NOT EDIT

package push

import (
	"errors"
	"fmt"

	"git.oschina.net/cxr29/aliyun-openapi-go-sdk"
)

var (
	_ = errors.New("")
	_ = fmt.Sprint("")
	_ = make(openapi.M)
)

type API struct {
	openapi.Service
}

func New(accessKeyId, accessKeySecret string) API {
	return API{openapi.NewService(accessKeyId, accessKeySecret)}
}

func NewParams() openapi.Params {
	args := openapi.NewParams()
	args.Product = Product
	args.Style = Style
	args.Version = Version
	return args
}

const (
	Product = "Push"
	Style   = "RPC"
	Version = "2015-08-27"
)

// BatchGetDevicesInfo version 2015-08-27
//
// required parameters:
//  name: AppId, type: int64
//  name: Devices, type: string
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) BatchGetDevicesInfo(AppId int64, Devices string, optional openapi.M) (*BatchGetDevicesInfoResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "BatchGetDevicesInfo")
	args.Query.Set("AppId", fmt.Sprint(AppId))
	args.Query.Set("Devices", Devices)
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(BatchGetDevicesInfoResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// BatchGetDevicesInfoResponse represents the response of the api BatchGetDevicesInfo.
type BatchGetDevicesInfoResponse struct {
	DeviceInfos struct {
		DeviceInfo []struct {
			DeviceId string
			IsOnline bool
			Status   int
		}
	}
}

// PushByteMessage version 2015-08-27
//
// required parameters:
//  name: AppId, type: int64
//  name: PushContent, type: string
//  name: SendType, type: int
//
// optional parameters:
//  name: Accounts, type: string
//  name: DeviceIds, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) PushByteMessage(AppId int64, PushContent string, SendType int, optional openapi.M) (*PushByteMessageResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "PushByteMessage")
	args.Query.Set("AppId", fmt.Sprint(AppId))
	args.Query.Set("PushContent", PushContent)
	args.Query.Set("SendType", fmt.Sprint(SendType))
	if v, ok := optional["Accounts"]; ok {
		if Accounts, ok := v.(string); ok {
			args.Query.Set("Accounts", Accounts)
		} else {
			return nil, errors.New("Accounts must be string")
		}
	}
	if v, ok := optional["DeviceIds"]; ok {
		if DeviceIds, ok := v.(string); ok {
			args.Query.Set("DeviceIds", DeviceIds)
		} else {
			return nil, errors.New("DeviceIds must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(PushByteMessageResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// PushByteMessageResponse represents the response of the api PushByteMessage.
type PushByteMessageResponse struct {
	ResponseId string
}

// RevertRpc version 2015-08-27
//
// required parameters:
//  name: AppId, type: int64
//  name: DeviceId, type: string
//  name: RpcContent, type: string
//  name: TimeOut, type: int
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) RevertRpc(AppId int64, DeviceId, RpcContent string, TimeOut int, optional openapi.M) (*RevertRpcResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "RevertRpc")
	args.Query.Set("AppId", fmt.Sprint(AppId))
	args.Query.Set("DeviceId", DeviceId)
	args.Query.Set("RpcContent", RpcContent)
	args.Query.Set("TimeOut", fmt.Sprint(TimeOut))
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(RevertRpcResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// RevertRpcResponse represents the response of the api RevertRpc.
type RevertRpcResponse struct {
	ResponseContent string
	RpcCode         string
}
