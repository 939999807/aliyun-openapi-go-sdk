// Copyright 2015 Chen Xianren. All rights reserved.
// Code generated by openapi-meta; DO NOT EDIT

package batchcompute

import (
	"errors"
	"fmt"

	"git.oschina.net/cxr29/aliyun-openapi-go-sdk"
)

var (
	_ = errors.New("")
	_ = fmt.Sprint("")
	_ = make(openapi.M)
)

type API struct {
	openapi.Service
}

func New(accessKeyId, accessKeySecret string) API {
	return API{openapi.NewService(accessKeyId, accessKeySecret)}
}

func NewParams() openapi.Params {
	args := openapi.NewParams()
	args.Product = Product
	args.Style = Style
	args.Version = Version
	return args
}

const (
	Product = "BatchCompute"
	Style   = "ROA"
	Version = "2013-01-11"
)

// DeleteImage version 2013-01-11
//
// required parameters:
//  name: ResourceName, type: string
//
// optional parameters:
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DeleteImage(ResourceName string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteImage")
	args.Method = "DELETE"
	args.Path["ResourceName"] = ResourceName
	args.Pattern = `/images/[ResourceName]`
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteJob version 2013-01-11
//
// required parameters:
//  name: ResourceName, type: string
//
// optional parameters:
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DeleteJob(ResourceName string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteJob")
	args.Method = "DELETE"
	args.Path["ResourceName"] = ResourceName
	args.Pattern = `/jobs/[ResourceName]`
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteSnapshot version 2013-01-11
//
// required parameters:
//  name: ResourceName, type: string
//
// optional parameters:
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DeleteSnapshot(ResourceName string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteSnapshot")
	args.Method = "DELETE"
	args.Path["ResourceName"] = ResourceName
	args.Pattern = `/snapshots/[ResourceName]`
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetImage version 2013-01-11
//
// required parameters:
//  name: ResourceName, type: string
//
// optional parameters:
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) GetImage(ResourceName string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "GetImage")
	args.Method = "GET"
	args.Path["ResourceName"] = ResourceName
	args.Pattern = `/images/[ResourceName]`
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetJob version 2013-01-11
//
// required parameters:
//  name: ResourceName, type: string
//
// optional parameters:
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) GetJob(ResourceName string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "GetJob")
	args.Method = "GET"
	args.Path["ResourceName"] = ResourceName
	args.Pattern = `/jobs/[ResourceName]`
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetJobDescription version 2013-01-11
//
// required parameters:
//  name: ResourceName, type: string
//
// optional parameters:
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) GetJobDescription(ResourceName string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "GetJobDescription")
	args.Method = "GET"
	args.Path["ResourceName"] = ResourceName
	args.Pattern = `/jobs/[ResourceName]/description`
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetSnapshot version 2013-01-11
//
// required parameters:
//  name: ResourceName, type: string
//
// optional parameters:
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) GetSnapshot(ResourceName string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "GetSnapshot")
	args.Method = "GET"
	args.Path["ResourceName"] = ResourceName
	args.Pattern = `/snapshots/[ResourceName]`
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetTasks version 2013-01-11
//
// required parameters:
//  name: ResourceName, type: string
//
// optional parameters:
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) GetTasks(ResourceName string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "GetTasks")
	args.Method = "GET"
	args.Path["ResourceName"] = ResourceName
	args.Pattern = `/jobs/[ResourceName]/tasks`
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListImages version 2013-01-11
//
// optional parameters:
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ListImages(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "ListImages")
	args.Method = "GET"
	args.Pattern = `/images`
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListJobs version 2013-01-11
//
// optional parameters:
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ListJobs(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "ListJobs")
	args.Method = "GET"
	args.Pattern = `/jobs`
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListSnapshots version 2013-01-11
//
// optional parameters:
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ListSnapshots(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "ListSnapshots")
	args.Method = "GET"
	args.Pattern = `/snapshots`
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// PostJob version 2013-01-11
//
// optional parameters:
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) PostJob(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "PostJob")
	args.Method = "POST"
	args.Pattern = `/jobs`
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// PutJob version 2013-01-11
//
// required parameters:
//  name: ResourceName, type: string
//
// optional parameters:
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) PutJob(ResourceName string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "PutJob")
	args.Method = "PUT"
	args.Path["ResourceName"] = ResourceName
	args.Pattern = `/jobs/[ResourceName]/Priority`
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ReleaseJob version 2013-01-11
//
// required parameters:
//  name: ResourceName, type: string
//
// optional parameters:
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ReleaseJob(ResourceName string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "ReleaseJob")
	args.Method = "DELETE"
	args.Path["ResourceName"] = ResourceName
	args.Pattern = `/jobs/[ResourceName]`
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// StartJob version 2013-01-11
//
// required parameters:
//  name: ResourceName, type: string
//
// optional parameters:
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) StartJob(ResourceName string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "Start")
	args.Method = "PUT"
	args.Path["ResourceName"] = ResourceName
	args.Pattern = `/jobs/[ResourceName]`
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// StopJob version 2013-01-11
//
// required parameters:
//  name: ResourceName, type: string
//
// optional parameters:
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) StopJob(ResourceName string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "Stop")
	args.Method = "PUT"
	args.Path["ResourceName"] = ResourceName
	args.Pattern = `/jobs/[ResourceName]`
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}
