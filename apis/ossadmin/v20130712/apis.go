// Copyright 2015 Chen Xianren. All rights reserved.
// Code generated by openapi-meta; DO NOT EDIT

package ossadmin

import (
	"errors"
	"fmt"

	"git.oschina.net/cxr29/aliyun-openapi-go-sdk"
)

var (
	_ = errors.New("")
	_ = fmt.Sprint("")
)

type API struct {
	openapi.Service
}

func New(accessKeyId, accessKeySecret string) API {
	return API{openapi.NewService(accessKeyId, accessKeySecret)}
}

func NewParams() openapi.Params {
	args := openapi.NewParams()
	args.Product = Product
	args.Style = Style
	args.Version = Version
	return args
}

const (
	Product = "OssAdmin"
	Style   = "RPC"
	Version = "2013-07-12"
)

// GetBucketPolicy version 2013-07-12
//
// required parameters:
//  name: BucketName, type: string
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
//  name: bid, type: string
//  name: uid, type: string
func (api API) GetBucketPolicy(BucketName string, optional openapi.M) (*GetBucketPolicyResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "GetBucketPolicy")
	args.Query.Set("BucketName", BucketName)
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}
	if v, ok := optional["bid"]; ok {
		if bid, ok := v.(string); ok {
			args.Query.Set("bid", bid)
		} else {
			return nil, errors.New("bid must be string")
		}
	}
	if v, ok := optional["uid"]; ok {
		if uid, ok := v.(string); ok {
			args.Query.Set("uid", uid)
		} else {
			return nil, errors.New("uid must be string")
		}
	}

	result := new(GetBucketPolicyResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// GetBucketPolicyResponse represents the response of the api GetBucketPolicy.
type GetBucketPolicyResponse struct {
	DisallowEmptyRefer bool
	EnableDualCluster  bool
	ErrorFile          string
	IamPolicy          string
	IndexFile          string
	Location           string
	LogBucket          string
	LogPrefix          string
	WhiteReferList     struct {
	}
}

// PutBucketLimit version 2013-07-12
//
// required parameters:
//  name: BucketLimit, type: int
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
//  name: bid, type: string
//  name: uid, type: string
func (api API) PutBucketLimit(BucketLimit int, optional openapi.M) (*PutBucketLimitResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "PutBucketLimit")
	args.Query.Set("BucketLimit", fmt.Sprint(BucketLimit))
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}
	if v, ok := optional["bid"]; ok {
		if bid, ok := v.(string); ok {
			args.Query.Set("bid", bid)
		} else {
			return nil, errors.New("bid must be string")
		}
	}
	if v, ok := optional["uid"]; ok {
		if uid, ok := v.(string); ok {
			args.Query.Set("uid", uid)
		} else {
			return nil, errors.New("uid must be string")
		}
	}

	result := new(PutBucketLimitResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// PutBucketLimitResponse represents the response of the api PutBucketLimit.
type PutBucketLimitResponse struct {
	Code    string
	Message string
	Success bool
}

// PutBucketPolicy version 2013-07-12
//
// required parameters:
//  name: BucketName, type: string
//
// optional parameters:
//  name: DisallowEmptyRefer, type: bool
//  name: EnableDualCluster, type: bool
//  name: ErrorFile, type: string
//  name: IamPolicy, type: string
//  name: IndexFile, type: string
//  name: Location, type: string
//  name: LogBucket, type: string
//  name: LogPrefix, type: string
//  name: OwnerAccount, type: string
//  name: WhiteReferList, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
//  name: bid, type: string
//  name: uid, type: string
func (api API) PutBucketPolicy(BucketName string, optional openapi.M) (*PutBucketPolicyResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "PutBucketPolicy")
	args.Query.Set("BucketName", BucketName)
	if v, ok := optional["DisallowEmptyRefer"]; ok {
		if DisallowEmptyRefer, ok := v.(bool); ok {
			args.Query.Set("DisallowEmptyRefer", fmt.Sprint(DisallowEmptyRefer))
		} else {
			return nil, errors.New("DisallowEmptyRefer must be bool")
		}
	}
	if v, ok := optional["EnableDualCluster"]; ok {
		if EnableDualCluster, ok := v.(bool); ok {
			args.Query.Set("EnableDualCluster", fmt.Sprint(EnableDualCluster))
		} else {
			return nil, errors.New("EnableDualCluster must be bool")
		}
	}
	if v, ok := optional["ErrorFile"]; ok {
		if ErrorFile, ok := v.(string); ok {
			args.Query.Set("ErrorFile", ErrorFile)
		} else {
			return nil, errors.New("ErrorFile must be string")
		}
	}
	if v, ok := optional["IamPolicy"]; ok {
		if IamPolicy, ok := v.(string); ok {
			args.Query.Set("IamPolicy", IamPolicy)
		} else {
			return nil, errors.New("IamPolicy must be string")
		}
	}
	if v, ok := optional["IndexFile"]; ok {
		if IndexFile, ok := v.(string); ok {
			args.Query.Set("IndexFile", IndexFile)
		} else {
			return nil, errors.New("IndexFile must be string")
		}
	}
	if v, ok := optional["Location"]; ok {
		if Location, ok := v.(string); ok {
			args.Query.Set("Location", Location)
		} else {
			return nil, errors.New("Location must be string")
		}
	}
	if v, ok := optional["LogBucket"]; ok {
		if LogBucket, ok := v.(string); ok {
			args.Query.Set("LogBucket", LogBucket)
		} else {
			return nil, errors.New("LogBucket must be string")
		}
	}
	if v, ok := optional["LogPrefix"]; ok {
		if LogPrefix, ok := v.(string); ok {
			args.Query.Set("LogPrefix", LogPrefix)
		} else {
			return nil, errors.New("LogPrefix must be string")
		}
	}
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["WhiteReferList"]; ok {
		if WhiteReferList, ok := v.(string); ok {
			args.Query.Set("WhiteReferList", WhiteReferList)
		} else {
			return nil, errors.New("WhiteReferList must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}
	if v, ok := optional["bid"]; ok {
		if bid, ok := v.(string); ok {
			args.Query.Set("bid", bid)
		} else {
			return nil, errors.New("bid must be string")
		}
	}
	if v, ok := optional["uid"]; ok {
		if uid, ok := v.(string); ok {
			args.Query.Set("uid", uid)
		} else {
			return nil, errors.New("uid must be string")
		}
	}

	result := new(PutBucketPolicyResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// PutBucketPolicyResponse represents the response of the api PutBucketPolicy.
type PutBucketPolicyResponse struct {
	Code    string
	Message string
	Success bool
}

// PutBucketStatus version 2013-07-12
//
// required parameters:
//  name: Bucket, type: string
//  name: Status, type: string
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
//  name: bid, type: string
//  name: uid, type: string
func (api API) PutBucketStatus(Bucket, Status string, optional openapi.M) (*PutBucketStatusResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "PutBucketStatus")
	args.Query.Set("Bucket", Bucket)
	args.Query.Set("Status", Status)
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}
	if v, ok := optional["bid"]; ok {
		if bid, ok := v.(string); ok {
			args.Query.Set("bid", bid)
		} else {
			return nil, errors.New("bid must be string")
		}
	}
	if v, ok := optional["uid"]; ok {
		if uid, ok := v.(string); ok {
			args.Query.Set("uid", uid)
		} else {
			return nil, errors.New("uid must be string")
		}
	}

	result := new(PutBucketStatusResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// PutBucketStatusResponse represents the response of the api PutBucketStatus.
type PutBucketStatusResponse struct {
	Code    string
	Message string
	Success bool
}

// CreateOssInstance version 2013-07-12
//
// optional parameters:
//  name: OwnerAccount, type: string
//  name: OwnerId, type: int64
//  name: ResourceOwnerAccount, type: string
//  name: ResourceOwnerId, type: int64
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
//  name: aliUid, type: int
//  name: region, type: string
func (api API) CreateOssInstance(optional openapi.M) (*CreateOssInstanceResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateOssInstance")
	if v, ok := optional["OwnerAccount"]; ok {
		if OwnerAccount, ok := v.(string); ok {
			args.Query.Set("OwnerAccount", OwnerAccount)
		} else {
			return nil, errors.New("OwnerAccount must be string")
		}
	}
	if v, ok := optional["OwnerId"]; ok {
		if OwnerId, ok := v.(int64); ok {
			args.Query.Set("OwnerId", fmt.Sprint(OwnerId))
		} else {
			return nil, errors.New("OwnerId must be int64")
		}
	}
	if v, ok := optional["ResourceOwnerAccount"]; ok {
		if ResourceOwnerAccount, ok := v.(string); ok {
			args.Query.Set("ResourceOwnerAccount", ResourceOwnerAccount)
		} else {
			return nil, errors.New("ResourceOwnerAccount must be string")
		}
	}
	if v, ok := optional["ResourceOwnerId"]; ok {
		if ResourceOwnerId, ok := v.(int64); ok {
			args.Query.Set("ResourceOwnerId", fmt.Sprint(ResourceOwnerId))
		} else {
			return nil, errors.New("ResourceOwnerId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}
	if v, ok := optional["aliUid"]; ok {
		if aliUid, ok := v.(int); ok {
			args.Query.Set("aliUid", fmt.Sprint(aliUid))
		} else {
			return nil, errors.New("aliUid must be int")
		}
	}
	if v, ok := optional["region"]; ok {
		if region, ok := v.(string); ok {
			args.Query.Set("region", region)
		} else {
			return nil, errors.New("region must be string")
		}
	}

	result := new(CreateOssInstanceResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateOssInstanceResponse represents the response of the api CreateOssInstance.
type CreateOssInstanceResponse struct {
	AliUid         int64 `json:"aliUid" xml:"aliUid"`
	Code           string
	EndTime        string `json:"endTime" xml:"endTime"`
	InstacneStatus string `json:"instacneStatus" xml:"instacneStatus"`
	InstanceId     string `json:"instanceId" xml:"instanceId"`
	InstanceName   string `json:"instanceName" xml:"instanceName"`
	Message        string
	StartTime      string `json:"startTime" xml:"startTime"`
	Success        bool
}
