// Copyright 2015 Chen Xianren. All rights reserved.
// Code generated by openapi-meta; DO NOT EDIT

package emr

import (
	"errors"
	"fmt"

	"git.oschina.net/cxr29/aliyun-openapi-go-sdk"
)

var (
	_ = errors.New("")
	_ = fmt.Sprint("")
	_ = make(openapi.M)
)

type API struct {
	openapi.Service
}

func New(accessKeyId, accessKeySecret string) API {
	return API{openapi.NewService(accessKeyId, accessKeySecret)}
}

func NewParams() openapi.Params {
	args := openapi.NewParams()
	args.Product = Product
	args.Style = Style
	args.Version = Version
	return args
}

const (
	Product = "Emr"
	Style   = "RPC"
	Version = "2015-09-10"
)

// CreateCluster version 2015-09-10
//
// required parameters:
//  name: ClusterType, type: string
//  name: EcsOrder, type: string
//  name: EmrRole4ECS, type: string
//  name: EmrRole4Oss, type: string
//  name: EmrVer, type: string
//  name: Name, type: string
//  name: PayType, type: int, optional values: 1|2
//
// optional parameters:
//  name: Install, type: string
//  name: IsOpenPublicIp, type: bool
//  name: LogEnable, type: bool
//  name: LogPath, type: string
//  name: MasterIndex, type: int
//  name: Period, type: int
//  name: SecurityGroup, type: string
//  name: SecurityGroupName, type: string
//  name: ZoneId, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) CreateCluster(ClusterType, EcsOrder, EmrRole4ECS, EmrRole4Oss, EmrVer, Name string, PayType int, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateCluster")
	args.Query.Set("ClusterType", ClusterType)
	args.Query.Set("EcsOrder", EcsOrder)
	args.Query.Set("EmrRole4ECS", EmrRole4ECS)
	args.Query.Set("EmrRole4Oss", EmrRole4Oss)
	args.Query.Set("EmrVer", EmrVer)
	args.Query.Set("Name", Name)
	if !openapi.IsIn(fmt.Sprint(PayType), "1|2") {
		return nil, errors.New("PayType must be 1|2")
	}

	args.Query.Set("PayType", fmt.Sprint(PayType))
	if v, ok := optional["Install"]; ok {
		if Install, ok := v.(string); ok {
			args.Query.Set("Install", Install)
		} else {
			return nil, errors.New("Install must be string")
		}
	}
	if v, ok := optional["IsOpenPublicIp"]; ok {
		if IsOpenPublicIp, ok := v.(bool); ok {
			args.Query.Set("IsOpenPublicIp", fmt.Sprint(IsOpenPublicIp))
		} else {
			return nil, errors.New("IsOpenPublicIp must be bool")
		}
	}
	if v, ok := optional["LogEnable"]; ok {
		if LogEnable, ok := v.(bool); ok {
			args.Query.Set("LogEnable", fmt.Sprint(LogEnable))
		} else {
			return nil, errors.New("LogEnable must be bool")
		}
	}
	if v, ok := optional["LogPath"]; ok {
		if LogPath, ok := v.(string); ok {
			args.Query.Set("LogPath", LogPath)
		} else {
			return nil, errors.New("LogPath must be string")
		}
	}
	if v, ok := optional["MasterIndex"]; ok {
		if MasterIndex, ok := v.(int); ok {
			args.Query.Set("MasterIndex", fmt.Sprint(MasterIndex))
		} else {
			return nil, errors.New("MasterIndex must be int")
		}
	}
	if v, ok := optional["Period"]; ok {
		if Period, ok := v.(int); ok {
			args.Query.Set("Period", fmt.Sprint(Period))
		} else {
			return nil, errors.New("Period must be int")
		}
	}
	if v, ok := optional["SecurityGroup"]; ok {
		if SecurityGroup, ok := v.(string); ok {
			args.Query.Set("SecurityGroup", SecurityGroup)
		} else {
			return nil, errors.New("SecurityGroup must be string")
		}
	}
	if v, ok := optional["SecurityGroupName"]; ok {
		if SecurityGroupName, ok := v.(string); ok {
			args.Query.Set("SecurityGroupName", SecurityGroupName)
		} else {
			return nil, errors.New("SecurityGroupName must be string")
		}
	}
	if v, ok := optional["ZoneId"]; ok {
		if ZoneId, ok := v.(string); ok {
			args.Query.Set("ZoneId", ZoneId)
		} else {
			return nil, errors.New("ZoneId must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateExecutePlan version 2015-09-10
//
// required parameters:
//  name: JobId, type: string
//
// optional parameters:
//  name: ClusterId, type: int64
//  name: Name, type: string
//  name: StartTime, type: string
//  name: Strategy, type: int
//  name: TimeInterval, type: int
//  name: TimeUnit, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) CreateExecutePlan(JobId string, optional openapi.M) (*CreateExecutePlanResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateExecutePlan")
	args.Query.Set("JobId", JobId)
	if v, ok := optional["ClusterId"]; ok {
		if ClusterId, ok := v.(int64); ok {
			args.Query.Set("ClusterId", fmt.Sprint(ClusterId))
		} else {
			return nil, errors.New("ClusterId must be int64")
		}
	}
	if v, ok := optional["Name"]; ok {
		if Name, ok := v.(string); ok {
			args.Query.Set("Name", Name)
		} else {
			return nil, errors.New("Name must be string")
		}
	}
	if v, ok := optional["StartTime"]; ok {
		if StartTime, ok := v.(string); ok {
			args.Query.Set("StartTime", StartTime)
		} else {
			return nil, errors.New("StartTime must be string")
		}
	}
	if v, ok := optional["Strategy"]; ok {
		if Strategy, ok := v.(int); ok {
			args.Query.Set("Strategy", fmt.Sprint(Strategy))
		} else {
			return nil, errors.New("Strategy must be int")
		}
	}
	if v, ok := optional["TimeInterval"]; ok {
		if TimeInterval, ok := v.(int); ok {
			args.Query.Set("TimeInterval", fmt.Sprint(TimeInterval))
		} else {
			return nil, errors.New("TimeInterval must be int")
		}
	}
	if v, ok := optional["TimeUnit"]; ok {
		if TimeUnit, ok := v.(string); ok {
			args.Query.Set("TimeUnit", TimeUnit)
		} else {
			return nil, errors.New("TimeUnit must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(CreateExecutePlanResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateExecutePlanResponse represents the response of the api CreateExecutePlan.
type CreateExecutePlanResponse struct {
	Id int64
}

// CreateExecutePlanWithCluster version 2015-09-10
//
// required parameters:
//  name: ClusterName, type: string
//  name: ClusterType, type: string
//  name: EcsOrder, type: string
//  name: EmrRole4ECS, type: string
//  name: EmrRole4Oss, type: string
//  name: EmrVer, type: string
//  name: JobId, type: string
//  name: PayType, type: int, optional values: 1|2
//
// optional parameters:
//  name: Install, type: string
//  name: IsOpenPublicIp, type: bool
//  name: LogEnable, type: bool
//  name: LogPath, type: string
//  name: MasterIndex, type: int
//  name: Name, type: string
//  name: Period, type: int
//  name: SecurityGroup, type: string
//  name: SecurityGroupName, type: string
//  name: StartTime, type: string
//  name: Strategy, type: int
//  name: TimeInterval, type: int
//  name: TimeUnit, type: string
//  name: ZoneId, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) CreateExecutePlanWithCluster(ClusterName, ClusterType, EcsOrder, EmrRole4ECS, EmrRole4Oss, EmrVer, JobId string, PayType int, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateExecutePlanWithCluster")
	args.Query.Set("ClusterName", ClusterName)
	args.Query.Set("ClusterType", ClusterType)
	args.Query.Set("EcsOrder", EcsOrder)
	args.Query.Set("EmrRole4ECS", EmrRole4ECS)
	args.Query.Set("EmrRole4Oss", EmrRole4Oss)
	args.Query.Set("EmrVer", EmrVer)
	args.Query.Set("JobId", JobId)
	if !openapi.IsIn(fmt.Sprint(PayType), "1|2") {
		return nil, errors.New("PayType must be 1|2")
	}

	args.Query.Set("PayType", fmt.Sprint(PayType))
	if v, ok := optional["Install"]; ok {
		if Install, ok := v.(string); ok {
			args.Query.Set("Install", Install)
		} else {
			return nil, errors.New("Install must be string")
		}
	}
	if v, ok := optional["IsOpenPublicIp"]; ok {
		if IsOpenPublicIp, ok := v.(bool); ok {
			args.Query.Set("IsOpenPublicIp", fmt.Sprint(IsOpenPublicIp))
		} else {
			return nil, errors.New("IsOpenPublicIp must be bool")
		}
	}
	if v, ok := optional["LogEnable"]; ok {
		if LogEnable, ok := v.(bool); ok {
			args.Query.Set("LogEnable", fmt.Sprint(LogEnable))
		} else {
			return nil, errors.New("LogEnable must be bool")
		}
	}
	if v, ok := optional["LogPath"]; ok {
		if LogPath, ok := v.(string); ok {
			args.Query.Set("LogPath", LogPath)
		} else {
			return nil, errors.New("LogPath must be string")
		}
	}
	if v, ok := optional["MasterIndex"]; ok {
		if MasterIndex, ok := v.(int); ok {
			args.Query.Set("MasterIndex", fmt.Sprint(MasterIndex))
		} else {
			return nil, errors.New("MasterIndex must be int")
		}
	}
	if v, ok := optional["Name"]; ok {
		if Name, ok := v.(string); ok {
			args.Query.Set("Name", Name)
		} else {
			return nil, errors.New("Name must be string")
		}
	}
	if v, ok := optional["Period"]; ok {
		if Period, ok := v.(int); ok {
			args.Query.Set("Period", fmt.Sprint(Period))
		} else {
			return nil, errors.New("Period must be int")
		}
	}
	if v, ok := optional["SecurityGroup"]; ok {
		if SecurityGroup, ok := v.(string); ok {
			args.Query.Set("SecurityGroup", SecurityGroup)
		} else {
			return nil, errors.New("SecurityGroup must be string")
		}
	}
	if v, ok := optional["SecurityGroupName"]; ok {
		if SecurityGroupName, ok := v.(string); ok {
			args.Query.Set("SecurityGroupName", SecurityGroupName)
		} else {
			return nil, errors.New("SecurityGroupName must be string")
		}
	}
	if v, ok := optional["StartTime"]; ok {
		if StartTime, ok := v.(string); ok {
			args.Query.Set("StartTime", StartTime)
		} else {
			return nil, errors.New("StartTime must be string")
		}
	}
	if v, ok := optional["Strategy"]; ok {
		if Strategy, ok := v.(int); ok {
			args.Query.Set("Strategy", fmt.Sprint(Strategy))
		} else {
			return nil, errors.New("Strategy must be int")
		}
	}
	if v, ok := optional["TimeInterval"]; ok {
		if TimeInterval, ok := v.(int); ok {
			args.Query.Set("TimeInterval", fmt.Sprint(TimeInterval))
		} else {
			return nil, errors.New("TimeInterval must be int")
		}
	}
	if v, ok := optional["TimeUnit"]; ok {
		if TimeUnit, ok := v.(string); ok {
			args.Query.Set("TimeUnit", TimeUnit)
		} else {
			return nil, errors.New("TimeUnit must be string")
		}
	}
	if v, ok := optional["ZoneId"]; ok {
		if ZoneId, ok := v.(string); ok {
			args.Query.Set("ZoneId", ZoneId)
		} else {
			return nil, errors.New("ZoneId must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateJob version 2015-09-10
//
// required parameters:
//  name: JobFailAct, type: int
//  name: JobType, type: string
//  name: Parameter, type: string
//
// optional parameters:
//  name: JobName, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) CreateJob(JobFailAct int, JobType, Parameter string, optional openapi.M) (*CreateJobResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "CreateJob")
	args.Query.Set("JobFailAct", fmt.Sprint(JobFailAct))
	args.Query.Set("JobType", JobType)
	args.Query.Set("Parameter", Parameter)
	if v, ok := optional["JobName"]; ok {
		if JobName, ok := v.(string); ok {
			args.Query.Set("JobName", JobName)
		} else {
			return nil, errors.New("JobName must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(CreateJobResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// CreateJobResponse represents the response of the api CreateJob.
type CreateJobResponse struct {
	Id int64
}

// DeleteExecutePlan version 2015-09-10
//
// optional parameters:
//  name: Id, type: int64, min value: 1
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DeleteExecutePlan(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteExecutePlan")
	if v, ok := optional["Id"]; ok {
		if Id, ok := v.(int64); ok {
			if Id < 1 {
				return nil, errors.New("Id must be equal or greater than 1")
			}
			args.Query.Set("Id", fmt.Sprint(Id))
		} else {
			return nil, errors.New("Id must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteJob version 2015-09-10
//
// required parameters:
//  name: Id, type: int64, min value: 1
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DeleteJob(Id int64, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "DeleteJob")
	if Id < 1 {
		return nil, errors.New("Id must be equal or greater than 1")
	}
	args.Query.Set("Id", fmt.Sprint(Id))
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeCluster version 2015-09-10
//
// required parameters:
//  name: ClusterId, type: int64, min value: 1
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DescribeCluster(ClusterId int64, optional openapi.M) (*DescribeClusterResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DescribeCluster")
	if ClusterId < 1 {
		return nil, errors.New("ClusterId must be equal or greater than 1")
	}
	args.Query.Set("ClusterId", fmt.Sprint(ClusterId))
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DescribeClusterResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeClusterResponse represents the response of the api DescribeCluster.
type DescribeClusterResponse struct {
	ClusterInfo struct {
		BizId             string
		ClusterId         int64
		ClusterName       string
		EmrRole4ECS       string
		EmrRole4Oss       string
		FailReason        string
		IsOpenOssLog      bool
		IsOpenPublicIp    bool
		LastJobStatus     int
		OssPath           string
		ReleaseSetting    int
		RunningTime       int
		Status            int
		TimeOutEnable     int
		TimeOutOperate    int
		TimeOutTime       string
		TimeOutWarningWay int
		UtcStartTime      string
		UtcStopTime       string
	}
	EcsInfo struct {
		EcsRoles struct {
			EcsRole []struct {
				BandWidth      string
				CpuCore        string
				DiskCapacity   int
				DiskType       int
				EcsPayType     string
				InstanceType   string
				IsMaster       bool
				MemoryCapacity string
				NetPayType     string
				Nodes          struct {
					Node []struct {
						DiskInfo   string
						InnerIp    string
						InstanceId string
						PubIp      string
					}
				}
				Payment string
			}
		}
		ImageId         string
		ImageName       string
		MasterCount     int
		RegionId        string
		SecurityGroupId string
		SlaveCount      int
		SparkVersion    string
		TotalCount      int
		ZoneId          string
	}
	SoftwareInfo struct {
		ClusterType string
		EmrVer      string
		Softwares   string
	}
}

// DescribeExecutePlan version 2015-09-10
//
// required parameters:
//  name: Id, type: int64, min value: 1
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DescribeExecutePlan(Id int64, optional openapi.M) (*DescribeExecutePlanResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DescribeExecutePlan")
	if Id < 1 {
		return nil, errors.New("Id must be equal or greater than 1")
	}
	args.Query.Set("Id", fmt.Sprint(Id))
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DescribeExecutePlanResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeExecutePlanResponse represents the response of the api DescribeExecutePlan.
type DescribeExecutePlanResponse struct {
	ClusterInfo struct {
		BizId             string
		ClusterId         int64
		ClusterName       string
		EmrRole4ECS       string
		EmrRole4Oss       string
		FailReason        string
		IsOpenOssLog      bool
		IsOpenPublicIp    bool
		LastJobStatus     int
		OssPath           string
		ReleaseSetting    int
		RunningTime       int
		Status            int
		TimeOutEnable     int
		TimeOutOperate    int
		TimeOutTime       string
		TimeOutWarningWay int
		UtcStartTime      string
		UtcStopTime       string
	}
	EcsInfo struct {
		EcsRoles struct {
			EcsRole []struct {
				BandWidth      string
				CpuCore        string
				DiskCapacity   int
				DiskType       int
				EcsPayType     string
				InstanceType   string
				IsMaster       bool
				MemoryCapacity string
				NetPayType     string
				Nodes          struct {
					Node []struct {
						DiskInfo   string
						InnerIp    string
						InstanceId string
						PubIp      string
					}
				}
				Payment string
			}
		}
		ImageId         string
		ImageName       string
		MasterCount     int
		RegionId        string
		SecurityGroupId string
		SlaveCount      int
		SparkVersion    string
		TotalCount      int
		ZoneId          string
	}
	Id              int64
	IsCreateCluster bool
	JobInfos        struct {
		JobInfo []struct {
			Id int64
		}
	}
	Name         string
	SoftwareInfo struct {
		ClusterType string
		EmrVer      string
		Softwares   string
	}
	StartTime    string
	Strategy     int
	TimeInterval int
	TimeUnit     string
}

// DescribeJob version 2015-09-10
//
// required parameters:
//  name: Id, type: int64, min value: 1
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) DescribeJob(Id int64, optional openapi.M) (*DescribeJobResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "DescribeJob")
	if Id < 1 {
		return nil, errors.New("Id must be equal or greater than 1")
	}
	args.Query.Set("Id", fmt.Sprint(Id))
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(DescribeJobResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// DescribeJobResponse represents the response of the api DescribeJob.
type DescribeJobResponse struct {
	EnvParam string
	FailAct  int
	Id       int64
	Name     string
	Type     int
}

// JobResource version 2015-09-10
//
// required parameters:
//  name: Bucket, type: string
//
// optional parameters:
//  name: Path, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) JobResource(Bucket string, optional openapi.M) (*JobResourceResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "JobResource")
	args.Query.Set("Bucket", Bucket)
	if v, ok := optional["Path"]; ok {
		if Path, ok := v.(string); ok {
			args.Query.Set("Path", Path)
		} else {
			return nil, errors.New("Path must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(JobResourceResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// JobResourceResponse represents the response of the api JobResource.
type JobResourceResponse struct {
	JobResourceInfoList struct {
		JobResourceInfo []struct {
			Filename string
			Region   string
			Size     int64
			Type     int
		}
	}
}

// KillExecutePlanRecordNode version 2015-09-10
//
// required parameters:
//  name: ExecutePlanRecordNodeId, type: int64, min value: 1
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) KillExecutePlanRecordNode(ExecutePlanRecordNodeId int64, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "KillExecutePlanRecordNode")
	if ExecutePlanRecordNodeId < 1 {
		return nil, errors.New("ExecutePlanRecordNodeId must be equal or greater than 1")
	}
	args.Query.Set("ExecutePlanRecordNodeId", fmt.Sprint(ExecutePlanRecordNodeId))
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListClusters version 2015-09-10
//
// optional parameters:
//  name: ClusterType, type: string
//  name: IsDesc, type: bool
//  name: PageNumber, type: int, min value: 1
//  name: PageSize, type: int, min value: 1, max value: 500
//  name: PayType, type: string
//  name: Status, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ListClusters(optional openapi.M) (*ListClustersResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListClusters")
	if v, ok := optional["ClusterType"]; ok {
		if ClusterType, ok := v.(string); ok {
			args.Query.Set("ClusterType", ClusterType)
		} else {
			return nil, errors.New("ClusterType must be string")
		}
	}
	if v, ok := optional["IsDesc"]; ok {
		if IsDesc, ok := v.(bool); ok {
			args.Query.Set("IsDesc", fmt.Sprint(IsDesc))
		} else {
			return nil, errors.New("IsDesc must be bool")
		}
	}
	if v, ok := optional["PageNumber"]; ok {
		if PageNumber, ok := v.(int); ok {
			if PageNumber < 1 {
				return nil, errors.New("PageNumber must be equal or greater than 1")
			}
			args.Query.Set("PageNumber", fmt.Sprint(PageNumber))
		} else {
			return nil, errors.New("PageNumber must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			if PageSize < 1 {
				return nil, errors.New("PageSize must be equal or greater than 1")
			}
			if PageSize > 500 {
				return nil, errors.New("PageSize must be equal or less than 500")
			}
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["PayType"]; ok {
		if PayType, ok := v.(string); ok {
			args.Query.Set("PayType", PayType)
		} else {
			return nil, errors.New("PayType must be string")
		}
	}
	if v, ok := optional["Status"]; ok {
		if Status, ok := v.(string); ok {
			args.Query.Set("Status", Status)
		} else {
			return nil, errors.New("Status must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(ListClustersResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListClustersResponse represents the response of the api ListClusters.
type ListClustersResponse struct {
	Clusters struct {
		ClusterInfo []struct {
			CreateTime  string
			FailReason  string
			Id          int64
			Name        string
			PayType     int
			RunningTime string
			Status      int
			Type        int
		}
	}
	PageNumber int
	PageSize   int
	TotalCount int
}

// ListConfigType version 2015-09-10
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ListConfigType(optional openapi.M) (*ListConfigTypeResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListConfigType")
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(ListConfigTypeResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListConfigTypeResponse represents the response of the api ListConfigType.
type ListConfigTypeResponse struct {
	EmrVerTypes struct {
		EmrVerType []struct {
			Name       string
			SubModules struct {
				SubModule []struct {
					Name     string
					Optional string
					Required string
				}
			}
		}
	}
	InstanceTypes struct {
		InstanceType []struct {
			Classify     string
			CpuCore      string
			HasCloudDisk bool
			HasCloudSSD  bool
			HasLocalDisk bool
			HasLocalSSD  bool
			MemSize      string
			State        string
			Type         string
		}
	} `json:"instanceTypes" xml:"instanceTypes"`
	SecurityGroupTypes struct {
		SecurityGroupType []struct {
			Id    string
			Name  string
			State string
		}
	} `json:"securityGroupTypes" xml:"securityGroupTypes"`
	ZoneTypes struct {
		ZoneType []struct {
			Id   string
			Name string
		}
	}
}

// ListExecutePlanExecuteRecordNodes version 2015-09-10
//
// optional parameters:
//  name: ExecutePlanExecRecordId, type: int64
//  name: IsDesc, type: bool
//  name: PageNumber, type: int
//  name: PageSize, type: int, max value: 500
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ListExecutePlanExecuteRecordNodes(optional openapi.M) (*ListExecutePlanExecuteRecordNodesResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListExecutePlanExecuteRecordNodes")
	if v, ok := optional["ExecutePlanExecRecordId"]; ok {
		if ExecutePlanExecRecordId, ok := v.(int64); ok {
			args.Query.Set("ExecutePlanExecRecordId", fmt.Sprint(ExecutePlanExecRecordId))
		} else {
			return nil, errors.New("ExecutePlanExecRecordId must be int64")
		}
	}
	if v, ok := optional["IsDesc"]; ok {
		if IsDesc, ok := v.(bool); ok {
			args.Query.Set("IsDesc", fmt.Sprint(IsDesc))
		} else {
			return nil, errors.New("IsDesc must be bool")
		}
	}
	if v, ok := optional["PageNumber"]; ok {
		if PageNumber, ok := v.(int); ok {
			args.Query.Set("PageNumber", fmt.Sprint(PageNumber))
		} else {
			return nil, errors.New("PageNumber must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			if PageSize > 500 {
				return nil, errors.New("PageSize must be equal or less than 500")
			}
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(ListExecutePlanExecuteRecordNodesResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListExecutePlanExecuteRecordNodesResponse represents the response of the api ListExecutePlanExecuteRecordNodes.
type ListExecutePlanExecuteRecordNodesResponse struct {
	ExecutePlanNode struct {
		ExecutePlanNodeInfo []struct {
			ClusterId    int64
			JobId        int64
			JobType      int
			RunTime      int64
			StartTime    string
			Status       int
			WorkNodeId   string
			WorkNodeName string
		}
	} `json:"executePlanNode" xml:"executePlanNode"`
	PageNumber int
	PageSize   int
	TotalCount int
}

// ListExecutePlanExecuteRecords version 2015-09-10
//
// required parameters:
//  name: ExecutePlanId, type: int64
//
// optional parameters:
//  name: IsDesc, type: bool
//  name: PageNumber, type: int
//  name: PageSize, type: int, max value: 500
//  name: Status, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ListExecutePlanExecuteRecords(ExecutePlanId int64, optional openapi.M) (*ListExecutePlanExecuteRecordsResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListExecutePlanExecuteRecords")
	args.Query.Set("ExecutePlanId", fmt.Sprint(ExecutePlanId))
	if v, ok := optional["IsDesc"]; ok {
		if IsDesc, ok := v.(bool); ok {
			args.Query.Set("IsDesc", fmt.Sprint(IsDesc))
		} else {
			return nil, errors.New("IsDesc must be bool")
		}
	}
	if v, ok := optional["PageNumber"]; ok {
		if PageNumber, ok := v.(int); ok {
			args.Query.Set("PageNumber", fmt.Sprint(PageNumber))
		} else {
			return nil, errors.New("PageNumber must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			if PageSize > 500 {
				return nil, errors.New("PageSize must be equal or less than 500")
			}
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["Status"]; ok {
		if Status, ok := v.(string); ok {
			args.Query.Set("Status", Status)
		} else {
			return nil, errors.New("Status must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(ListExecutePlanExecuteRecordsResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListExecutePlanExecuteRecordsResponse represents the response of the api ListExecutePlanExecuteRecords.
type ListExecutePlanExecuteRecordsResponse struct {
	ExecutePlanExecRecord struct {
		ExecutePlanRecordInfo []struct {
			ClusterId       int64
			ClusterName     string
			ClusterType     int
			ExecutePlanId   int64
			ExecutePlanName string
			Id              int64
			LogEnable       bool
			LogPath         string
			RunTime         int64
			StartTime       string
			Status          int
		}
	}
	PageNumber int
	PageSize   int
	TotalCount int
}

// ListExecutePlanJobs version 2015-09-10
//
// optional parameters:
//  name: ExecutePlanExecRecordId, type: string
//  name: ExecutePlanExecuteNodeId, type: string
//  name: IsDesc, type: bool
//  name: PageNumber, type: int
//  name: PageSize, type: int, max value: 50
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ListExecutePlanJobs(optional openapi.M) (*ListExecutePlanJobsResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListExecutePlanJobs")
	if v, ok := optional["ExecutePlanExecRecordId"]; ok {
		if ExecutePlanExecRecordId, ok := v.(string); ok {
			args.Query.Set("ExecutePlanExecRecordId", ExecutePlanExecRecordId)
		} else {
			return nil, errors.New("ExecutePlanExecRecordId must be string")
		}
	}
	if v, ok := optional["ExecutePlanExecuteNodeId"]; ok {
		if ExecutePlanExecuteNodeId, ok := v.(string); ok {
			args.Query.Set("ExecutePlanExecuteNodeId", ExecutePlanExecuteNodeId)
		} else {
			return nil, errors.New("ExecutePlanExecuteNodeId must be string")
		}
	}
	if v, ok := optional["IsDesc"]; ok {
		if IsDesc, ok := v.(bool); ok {
			args.Query.Set("IsDesc", fmt.Sprint(IsDesc))
		} else {
			return nil, errors.New("IsDesc must be bool")
		}
	}
	if v, ok := optional["PageNumber"]; ok {
		if PageNumber, ok := v.(int); ok {
			args.Query.Set("PageNumber", fmt.Sprint(PageNumber))
		} else {
			return nil, errors.New("PageNumber must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			if PageSize > 50 {
				return nil, errors.New("PageSize must be equal or less than 50")
			}
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(ListExecutePlanJobsResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListExecutePlanJobsResponse represents the response of the api ListExecutePlanJobs.
type ListExecutePlanJobsResponse struct {
	ExecutePlanJobs struct {
		ExecutePlanJobInfo []struct {
			ClusterName   string
			Id            string `json:"id" xml:"id"`
			IsMaster      string `json:"isMaster" xml:"isMaster"`
			LastRunStatus string
			RunTime       string
			Status        string
		}
	}
	PageNumber int
	PageSize   int
	TotalCount int
}

// ListExecutePlanNodeInstances version 2015-09-10
//
// required parameters:
//  name: ExecutePlanWorkNodeId, type: int64
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ListExecutePlanNodeInstances(ExecutePlanWorkNodeId int64, optional openapi.M) (*ListExecutePlanNodeInstancesResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListExecutePlanNodeInstances")
	args.Query.Set("ExecutePlanWorkNodeId", fmt.Sprint(ExecutePlanWorkNodeId))
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(ListExecutePlanNodeInstancesResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListExecutePlanNodeInstancesResponse represents the response of the api ListExecutePlanNodeInstances.
type ListExecutePlanNodeInstancesResponse struct {
	ExecutePlanNodeInstance struct {
		ExecutePlanNodeInstanceInfo []struct {
			ApplicationId string
			ContainerInfo string
			InstanceInfo  string
		}
	}
}

// ListExecutePlans version 2015-09-10
//
// optional parameters:
//  name: IsDesc, type: bool
//  name: PageNumber, type: int
//  name: PageSize, type: int, max value: 500
//  name: Status, type: string
//  name: Strategy, type: int
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ListExecutePlans(optional openapi.M) (*ListExecutePlansResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListExecutePlans")
	if v, ok := optional["IsDesc"]; ok {
		if IsDesc, ok := v.(bool); ok {
			args.Query.Set("IsDesc", fmt.Sprint(IsDesc))
		} else {
			return nil, errors.New("IsDesc must be bool")
		}
	}
	if v, ok := optional["PageNumber"]; ok {
		if PageNumber, ok := v.(int); ok {
			args.Query.Set("PageNumber", fmt.Sprint(PageNumber))
		} else {
			return nil, errors.New("PageNumber must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			if PageSize > 500 {
				return nil, errors.New("PageSize must be equal or less than 500")
			}
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["Status"]; ok {
		if Status, ok := v.(string); ok {
			args.Query.Set("Status", Status)
		} else {
			return nil, errors.New("Status must be string")
		}
	}
	if v, ok := optional["Strategy"]; ok {
		if Strategy, ok := v.(int); ok {
			args.Query.Set("Strategy", fmt.Sprint(Strategy))
		} else {
			return nil, errors.New("Strategy must be int")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(ListExecutePlansResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListExecutePlansResponse represents the response of the api ListExecutePlans.
type ListExecutePlansResponse struct {
	ExecutePlans struct {
		ExecutePlanInfo []struct {
			ClusterName     string
			Id              int64
			IsCreateCluster bool
			LastRunStatus   string
			Name            string
			RunTime         int64
			StartTime       string
			Status          string
			Stragety        int
			TimeInterval    int
			TimeUnit        string
		}
	}
	PageNumber int
	PageSize   int
	TotalCount int
}

// ListJobs version 2015-09-10
//
// optional parameters:
//  name: IsDesc, type: bool
//  name: PageNumber, type: int
//  name: PageSize, type: int, max value: 500
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ListJobs(optional openapi.M) (*ListJobsResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListJobs")
	if v, ok := optional["IsDesc"]; ok {
		if IsDesc, ok := v.(bool); ok {
			args.Query.Set("IsDesc", fmt.Sprint(IsDesc))
		} else {
			return nil, errors.New("IsDesc must be bool")
		}
	}
	if v, ok := optional["PageNumber"]; ok {
		if PageNumber, ok := v.(int); ok {
			args.Query.Set("PageNumber", fmt.Sprint(PageNumber))
		} else {
			return nil, errors.New("PageNumber must be int")
		}
	}
	if v, ok := optional["PageSize"]; ok {
		if PageSize, ok := v.(int); ok {
			if PageSize > 500 {
				return nil, errors.New("PageSize must be equal or less than 500")
			}
			args.Query.Set("PageSize", fmt.Sprint(PageSize))
		} else {
			return nil, errors.New("PageSize must be int")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(ListJobsResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListJobsResponse represents the response of the api ListJobs.
type ListJobsResponse struct {
	Jobs struct {
		JobInfo []struct {
			EnvConfig  string
			JobFailAct int
			JobId      int64
			JobName    string
			JobType    int
		}
	}
	PageNumber int
	PageSize   int
	TotalCount int
}

// ListRegions version 2015-09-10
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ListRegions(optional openapi.M) (*ListRegionsResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ListRegions")
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(ListRegionsResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ListRegionsResponse represents the response of the api ListRegions.
type ListRegionsResponse struct {
	RegionTypes struct {
		RegionType []struct {
			AsUrl string
			Id    string
			Name  string
		}
	}
}

// ModifyClusterName version 2015-09-10
//
// required parameters:
//  name: ClusterId, type: int64, min value: 1
//  name: ClusterName, type: string
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ModifyClusterName(ClusterId int64, ClusterName string, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "ModifyClusterName")
	args.Query.Set("ClusterName", ClusterName)
	if ClusterId < 1 {
		return nil, errors.New("ClusterId must be equal or greater than 1")
	}
	args.Query.Set("ClusterId", fmt.Sprint(ClusterId))
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ModifyExecutePlan version 2015-09-10
//
// required parameters:
//  name: JobId, type: string
//
// optional parameters:
//  name: ClusterId, type: int64
//  name: ExecutePlanId, type: int64
//  name: Name, type: string
//  name: StartTime, type: string
//  name: Strategy, type: int
//  name: TimeInterval, type: int
//  name: TimeUnit, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ModifyExecutePlan(JobId string, optional openapi.M) (*ModifyExecutePlanResponse, error) {
	args := NewParams()

	args.Query.Set("Action", "ModifyExecutePlan")
	args.Query.Set("JobId", JobId)
	if v, ok := optional["ClusterId"]; ok {
		if ClusterId, ok := v.(int64); ok {
			args.Query.Set("ClusterId", fmt.Sprint(ClusterId))
		} else {
			return nil, errors.New("ClusterId must be int64")
		}
	}
	if v, ok := optional["ExecutePlanId"]; ok {
		if ExecutePlanId, ok := v.(int64); ok {
			args.Query.Set("ExecutePlanId", fmt.Sprint(ExecutePlanId))
		} else {
			return nil, errors.New("ExecutePlanId must be int64")
		}
	}
	if v, ok := optional["Name"]; ok {
		if Name, ok := v.(string); ok {
			args.Query.Set("Name", Name)
		} else {
			return nil, errors.New("Name must be string")
		}
	}
	if v, ok := optional["StartTime"]; ok {
		if StartTime, ok := v.(string); ok {
			args.Query.Set("StartTime", StartTime)
		} else {
			return nil, errors.New("StartTime must be string")
		}
	}
	if v, ok := optional["Strategy"]; ok {
		if Strategy, ok := v.(int); ok {
			args.Query.Set("Strategy", fmt.Sprint(Strategy))
		} else {
			return nil, errors.New("Strategy must be int")
		}
	}
	if v, ok := optional["TimeInterval"]; ok {
		if TimeInterval, ok := v.(int); ok {
			args.Query.Set("TimeInterval", fmt.Sprint(TimeInterval))
		} else {
			return nil, errors.New("TimeInterval must be int")
		}
	}
	if v, ok := optional["TimeUnit"]; ok {
		if TimeUnit, ok := v.(string); ok {
			args.Query.Set("TimeUnit", TimeUnit)
		} else {
			return nil, errors.New("TimeUnit must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(ModifyExecutePlanResponse)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ModifyExecutePlanResponse represents the response of the api ModifyExecutePlan.
type ModifyExecutePlanResponse struct {
	ExecutePlanId int64
}

// ModifyExecutePlanWithCluster version 2015-09-10
//
// required parameters:
//  name: ClusterName, type: string
//  name: ClusterType, type: string
//  name: EcsOrder, type: string
//  name: EmrRole4ECS, type: string
//  name: EmrRole4Oss, type: string
//  name: EmrVer, type: string
//  name: JobId, type: string
//  name: PayType, type: int, optional values: 1|2
//
// optional parameters:
//  name: ExecutePlanId, type: int64
//  name: Install, type: string
//  name: IsOpenPublicIp, type: bool
//  name: LogEnable, type: bool
//  name: LogPath, type: string
//  name: MasterIndex, type: int
//  name: Name, type: string
//  name: Period, type: int
//  name: SecurityGroup, type: string
//  name: SecurityGroupName, type: string
//  name: StartTime, type: string
//  name: Strategy, type: int
//  name: TimeInterval, type: int
//  name: TimeUnit, type: string
//  name: ZoneId, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ModifyExecutePlanWithCluster(ClusterName, ClusterType, EcsOrder, EmrRole4ECS, EmrRole4Oss, EmrVer, JobId string, PayType int, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "ModifyExecutePlanWithCluster")
	args.Query.Set("ClusterName", ClusterName)
	args.Query.Set("ClusterType", ClusterType)
	args.Query.Set("EcsOrder", EcsOrder)
	args.Query.Set("EmrRole4ECS", EmrRole4ECS)
	args.Query.Set("EmrRole4Oss", EmrRole4Oss)
	args.Query.Set("EmrVer", EmrVer)
	args.Query.Set("JobId", JobId)
	if !openapi.IsIn(fmt.Sprint(PayType), "1|2") {
		return nil, errors.New("PayType must be 1|2")
	}

	args.Query.Set("PayType", fmt.Sprint(PayType))
	if v, ok := optional["ExecutePlanId"]; ok {
		if ExecutePlanId, ok := v.(int64); ok {
			args.Query.Set("ExecutePlanId", fmt.Sprint(ExecutePlanId))
		} else {
			return nil, errors.New("ExecutePlanId must be int64")
		}
	}
	if v, ok := optional["Install"]; ok {
		if Install, ok := v.(string); ok {
			args.Query.Set("Install", Install)
		} else {
			return nil, errors.New("Install must be string")
		}
	}
	if v, ok := optional["IsOpenPublicIp"]; ok {
		if IsOpenPublicIp, ok := v.(bool); ok {
			args.Query.Set("IsOpenPublicIp", fmt.Sprint(IsOpenPublicIp))
		} else {
			return nil, errors.New("IsOpenPublicIp must be bool")
		}
	}
	if v, ok := optional["LogEnable"]; ok {
		if LogEnable, ok := v.(bool); ok {
			args.Query.Set("LogEnable", fmt.Sprint(LogEnable))
		} else {
			return nil, errors.New("LogEnable must be bool")
		}
	}
	if v, ok := optional["LogPath"]; ok {
		if LogPath, ok := v.(string); ok {
			args.Query.Set("LogPath", LogPath)
		} else {
			return nil, errors.New("LogPath must be string")
		}
	}
	if v, ok := optional["MasterIndex"]; ok {
		if MasterIndex, ok := v.(int); ok {
			args.Query.Set("MasterIndex", fmt.Sprint(MasterIndex))
		} else {
			return nil, errors.New("MasterIndex must be int")
		}
	}
	if v, ok := optional["Name"]; ok {
		if Name, ok := v.(string); ok {
			args.Query.Set("Name", Name)
		} else {
			return nil, errors.New("Name must be string")
		}
	}
	if v, ok := optional["Period"]; ok {
		if Period, ok := v.(int); ok {
			args.Query.Set("Period", fmt.Sprint(Period))
		} else {
			return nil, errors.New("Period must be int")
		}
	}
	if v, ok := optional["SecurityGroup"]; ok {
		if SecurityGroup, ok := v.(string); ok {
			args.Query.Set("SecurityGroup", SecurityGroup)
		} else {
			return nil, errors.New("SecurityGroup must be string")
		}
	}
	if v, ok := optional["SecurityGroupName"]; ok {
		if SecurityGroupName, ok := v.(string); ok {
			args.Query.Set("SecurityGroupName", SecurityGroupName)
		} else {
			return nil, errors.New("SecurityGroupName must be string")
		}
	}
	if v, ok := optional["StartTime"]; ok {
		if StartTime, ok := v.(string); ok {
			args.Query.Set("StartTime", StartTime)
		} else {
			return nil, errors.New("StartTime must be string")
		}
	}
	if v, ok := optional["Strategy"]; ok {
		if Strategy, ok := v.(int); ok {
			args.Query.Set("Strategy", fmt.Sprint(Strategy))
		} else {
			return nil, errors.New("Strategy must be int")
		}
	}
	if v, ok := optional["TimeInterval"]; ok {
		if TimeInterval, ok := v.(int); ok {
			args.Query.Set("TimeInterval", fmt.Sprint(TimeInterval))
		} else {
			return nil, errors.New("TimeInterval must be int")
		}
	}
	if v, ok := optional["TimeUnit"]; ok {
		if TimeUnit, ok := v.(string); ok {
			args.Query.Set("TimeUnit", TimeUnit)
		} else {
			return nil, errors.New("TimeUnit must be string")
		}
	}
	if v, ok := optional["ZoneId"]; ok {
		if ZoneId, ok := v.(string); ok {
			args.Query.Set("ZoneId", ZoneId)
		} else {
			return nil, errors.New("ZoneId must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ModifyJob version 2015-09-10
//
// required parameters:
//  name: Id, type: int64, min value: 1
//
// optional parameters:
//  name: EnvParameter, type: string
//  name: FailAct, type: int
//  name: Name, type: string
//  name: Type, type: string
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ModifyJob(Id int64, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "ModifyJob")
	if Id < 1 {
		return nil, errors.New("Id must be equal or greater than 1")
	}
	args.Query.Set("Id", fmt.Sprint(Id))
	if v, ok := optional["EnvParameter"]; ok {
		if EnvParameter, ok := v.(string); ok {
			args.Query.Set("EnvParameter", EnvParameter)
		} else {
			return nil, errors.New("EnvParameter must be string")
		}
	}
	if v, ok := optional["FailAct"]; ok {
		if FailAct, ok := v.(int); ok {
			args.Query.Set("FailAct", fmt.Sprint(FailAct))
		} else {
			return nil, errors.New("FailAct must be int")
		}
	}
	if v, ok := optional["Name"]; ok {
		if Name, ok := v.(string); ok {
			args.Query.Set("Name", Name)
		} else {
			return nil, errors.New("Name must be string")
		}
	}
	if v, ok := optional["Type"]; ok {
		if Type, ok := v.(string); ok {
			args.Query.Set("Type", Type)
		} else {
			return nil, errors.New("Type must be string")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ReleaseCluster version 2015-09-10
//
// required parameters:
//  name: ClusterId, type: int64, min value: 1
//
// optional parameters:
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ReleaseCluster(ClusterId int64, optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "ReleaseCluster")
	if ClusterId < 1 {
		return nil, errors.New("ClusterId must be equal or greater than 1")
	}
	args.Query.Set("ClusterId", fmt.Sprint(ClusterId))
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeExecutePlan version 2015-09-10
//
// optional parameters:
//  name: Id, type: int64, min value: 1
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) ResumeExecutePlan(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "ResumeExecutePlan")
	if v, ok := optional["Id"]; ok {
		if Id, ok := v.(int64); ok {
			if Id < 1 {
				return nil, errors.New("Id must be equal or greater than 1")
			}
			args.Query.Set("Id", fmt.Sprint(Id))
		} else {
			return nil, errors.New("Id must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// RunExecutePlan version 2015-09-10
//
// optional parameters:
//  name: ExecutePlanId, type: int64, min value: 1
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) RunExecutePlan(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "RunExecutePlan")
	if v, ok := optional["ExecutePlanId"]; ok {
		if ExecutePlanId, ok := v.(int64); ok {
			if ExecutePlanId < 1 {
				return nil, errors.New("ExecutePlanId must be equal or greater than 1")
			}
			args.Query.Set("ExecutePlanId", fmt.Sprint(ExecutePlanId))
		} else {
			return nil, errors.New("ExecutePlanId must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}

// StopExecutePlan version 2015-09-10
//
// optional parameters:
//  name: Id, type: int64, min value: 1
//  name: _method, type: string, optional values: GET|POST
//  name: _region, type: string
//  name: _scheme, type: string, optional values: http|https
func (api API) StopExecutePlan(optional openapi.M) (*openapi.Response, error) {
	args := NewParams()

	args.Query.Set("Action", "StopExecutePlan")
	if v, ok := optional["Id"]; ok {
		if Id, ok := v.(int64); ok {
			if Id < 1 {
				return nil, errors.New("Id must be equal or greater than 1")
			}
			args.Query.Set("Id", fmt.Sprint(Id))
		} else {
			return nil, errors.New("Id must be int64")
		}
	}
	if v, ok := optional["_method"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "GET|POST") {
				return nil, errors.New("_method must be GET|POST")
			}
			args.Method = s
		} else {
			return nil, errors.New("_method must be string")
		}
	}
	if v, ok := optional["_region"]; ok {
		if s, ok := v.(string); ok {
			args.Region = s
		} else {
			return nil, errors.New("_region must be string")
		}
	}
	if v, ok := optional["_scheme"]; ok {
		if s, ok := v.(string); ok {
			if !openapi.IsIn(s, "http|https") {
				return nil, errors.New("_scheme must be http|https")
			}
			args.Scheme = s
		} else {
			return nil, errors.New("_scheme must be string")
		}
	}

	result := new(openapi.Response)
	if err := api.Service.Do(result, args); err != nil {
		return nil, err
	}
	return result, nil
}
